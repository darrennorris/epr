[["index.html", "Ecologia de Paisagens com R Bem-vindos Agradecimentos", " Ecologia de Paisagens com R Darren Norris 2023-05-10 Bem-vindos Este é um trabalho em andamento do 1ª edição: “Ecologia de Paisagens com R”. Este é um material introdutório destinado principalmente a estudantes de graduação e cursos de pós-graduação em ecologia e áreas correlatas. O objetivo é de apresentar os capacidades e opções para desenvolver e integrar pesquisas na Ecologia da Paisagem no ambiente estatística de R. Esperamos que ele seja utilizado tanto por quem quer se aprofundar em análises comumente utilizadas em Ecologia da Paisagem, quanto por quem não tem nenhuma ou poucas habilidades quantitativas. Agradecimentos Este livro não é apenas o resulto dos autores. Mas é o resultado de muitas pessoas na comunidade R e Ecologia da Paisagem no Brasil. Muito obrigado! "],["prefácio-à-primeira-edição.html", "Prefácio à primeira edição", " Prefácio à primeira edição Há quem diga que a velocidade com que a tecnologia e a ciência avançam tende a tornar livros e manuais sobre métodos rapidamente obsoletos. A evolução dos computadores pessoais e a ampliação do acesso a estes e à Internet têm transformado o jeito como aprendemos e ensinamos. Portanto, um livro aberto e disponível livremente que as pessoas possam compartilhar e contribuir torna-se uma opção cada vez mais relevante. O conteudo e organização dos capítulos esta separado em partes. O primeiro grupo – que inclui dos capítulos x ao y, inclui os aspectos mais gerais da estrutura do livro, seus objetivos e sobre o funcionamento da linguagem R. No segundo grupo de capítulos (do x ao y), temos contato com análises específicas e atualmente usadas em Ecologia da Paisasgem, incluindo …. "],["introdução.html", "Introdução O que você vai aprender Como este livro está organizado O que você não vai aprender Prerequisites", " Introdução Ecologia da Paisagem é uma disciplina empolgante que permite transformar dados brutos em compreensão, insight e conhecimento. O que você vai aprender Ecologia da Paisagem é um campo vasto e não há como dominar tudo lendo um único livro. Este livro visa fornecer uma base sólida nas ferramentas mais importantes e conhecimento suficiente para encontrar os recursos para aprender mais quando necessário. Um modelo das etapas de um projeto típico de Ecologia da Paisagem se parece com….. Como este livro está organizado A descrição anterior das ferramentas da Ecologia da Paisagem é organizada aproximadamente de acordo com a ordem em que você as usa em uma análise (embora, é claro, você as itere várias vezes). Em nossa experiência, no entanto, aprender a importar e organizar os dados primeiro não é o ideal, porque 80% do tempo é rotineiro e chato e, nos outros 20% do tempo, é estranho e frustrante. Esse é um péssimo lugar para começar a aprender um novo assunto! Em vez disso, começaremos com a visualização e transformação dos dados que já foram importados e organizados. Dessa forma, quando você ingerir e organizar seus próprios dados, sua motivação permanecerá alta porque você sabe que a dor vale o esforço. Dentro de cada capítulo, tentamos aderir a um padrão consistente: comece com alguns exemplos motivadores para que você possa ver o quadro geral e depois mergulhe nos detalhes. Cada seção do livro é combinada com exercícios para ajudá-lo a praticar o que aprendeu. Embora possa ser tentador pular os exercícios, não há melhor maneira de aprender do que praticar em problemas reais. O que você não vai aprender Prerequisites Fizemos algumas suposições sobre o que você já sabe para aproveitar ao máximo este livro. Você deve ser geralmente alfabetizado numericamente, e com conhecimento previsa de ecologia, geoprocessamento e uso de sistemas de informação geografica. Você precisa de quatro coisas para executar o código deste livro: R, RStudio, uma coleção de pacotes R chamada tidyverse e um punhado de outros pacotes. Os pacotes são as unidades fundamentais do código R reproduzível. Eles incluem funções reutilizáveis, documentação que descreve como usá-los e dados de amostra. R Para fazer o download do R, acesse CRAN, a comprehensive R archive nnetwork, https://cloud.r-project.org. Uma nova versão principal do R é lançada uma vez por ano e há 2 a 3 versões secundárias a cada ano. É uma boa ideia atualizar regularmente. A atualização pode ser um pouco complicada, especialmente para as versões principais que exigem a reinstalação de todos os seus pacotes, mas adiar só piora as coisas. Recomendamos R 4.2.0 ou posterior para este livro. RStudio RStudio é um ambiente de desenvolvimento integrado, ou IDE, para programação R, que você pode baixar em https://posit.co/download/rstudio-desktop/. O RStudio é atualizado algumas vezes por ano e avisa automaticamente quando uma nova versão é lançada, para que não haja necessidade de verificar novamente. É uma boa ideia atualizar regularmente para aproveitar os melhores e mais recentes recursos. Para este livro, certifique-se de ter pelo menos o RStudio 2022.02.0. O universo arrumado - tidyverse Você também precisará instalar alguns pacotes do R. Um pacote do R é uma coleção de funções, dados e documentação que estende os recursos do R base. O uso de pacotes é a chave para o uso bem-sucedido do R. A maioria dos pacotes que você aprenderá neste livro faz parte do chamado tidyverse. Todos os pacotes no tidyverse compartilham uma filosofia comum de programação de dados e R e são projetados para trabalhar juntos. Você pode instalar o tidyverse completo com uma única linha de código: install.packages(&quot;tidyverse&quot;) No seu computador, digite essa linha de código no console e pressione enter para executá-lo. R irá baixar os pacotes do CRAN e instalá-los em seu computador. Você não poderá usar as funções, objetos ou arquivos de ajuda em um pacote até carregá-lo com library(). Depois de instalar um pacote, você pode carregá-lo usando a função library(): library(tidyverse) Isso diz a você que o tidyverse carrega nove pacotes: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, alignr. Eles são considerados o núcleo do tidyverse porque você os usará em quase todas as análises. Os pacotes no tidyverse mudam com bastante frequência. Você pode ver se há atualizações disponíveis executando tidyverse_update(). Outros pacotes Existem muitos outros pacotes excelentes que não fazem parte do tidyverse porque resolvem problemas em um domínio diferente ou são projetados com um conjunto diferente de princípios subjacentes. Isso não os torna melhores ou piores, apenas diferentes. Em outras palavras, o complemento do tidyverse não é o universo bagunçado, mas muitos outros universos de pacotes inter-relacionados. Ao lidar com mais projetos de Ecologia da Paisagem com R, você aprenderá novos pacotes e novas formas de pensar sobre os dados. Usaremos outras pacotes de fora do tidyverse neste livro. Por exemplo, usaremos os seguintes pacotes porque eles fornecem conjuntos de funcões e dados interessantes para trabalharmos no processo de aprendizado de R: install.packages(c(&quot;sp&quot;, &quot;sf&quot;,&quot;raster&quot;, &quot;mapview&quot;,&quot;tmap&quot;, &quot;terra&quot;, &quot;kableExtra&quot;, &quot;landscapemetrics&quot;)) "],["escala.html", "Capítulo 1 Escala 1.1 Apresentação 1.2 Pacotes e dados 1.3 Alterando a resolução 1.4 Escala espacial e desenho amostral 1.5 Comparação multiescala 1.6 Próximos passos: repetindo para muitas amostras.", " Capítulo 1 Escala 1.1 Apresentação Nesta capitulo vamos entender a importância de escala na ecologia da paisagem através cálculos com a proporção de floresta. Durante o capitulo você aprenderá a Alterar escala (resolução e extensão espacial), Calcular a área de uma classe de habitat, Desenvolve uma comparação multiescala. É muito importante ficar claro para você o que é escala (e o que não é!) e qual a importância desse conceito na elaboração do desenho amostral, na coleta de dados, nas análises e na tomada de decisão. Nesse tutorial usaremos conteudo baseado no Capítulo 2 do livro (Fletcher and Fortin 2018) e “Tutorial Escala” do Dr. Alexandre Martensen. 1.1.1 Escala: breve definação Todos os processos e padrões ecológicos têm uma dimensão temporal e espacial. Assim sendo, o conceito de escala não somente representar essas dimensões, mas também, ajudar nos apresentá-los de uma forma que facilite o entendimento sobre os processos e padrões sendo estudados. Na ecologia o termo escala refere-se à dimensão ou domínio espaço-temporal de um processo ou padrão. Na ecologia da paisagem, a escala é frequentemente descrita por sua componentes: resolução e extensão. Resolução: menor unidade espacial de medida para um padrão ou processo. Extensão: descreve o comprimento ou tamanho de área sob investigação. Resolução e extensão tendem a covariar – estudos com maior extensão tendem a ter resolução maiores também. Parte dessa covariância é prática: é difícil trabalhar em grandes extensões com dados coletados em tamanhos de resolução finos. No entanto, parte dessa covariância também é conceitual: muitas vezes em grandes extensões, podemos esperar que processos operando em resolução muito finos forneçam somente “ruído” e não dados/informações relevantes sobre os sistemas. Como os desafios computacionais diminuíram e a disponibilidade de dados de alta resolução aumentou, a covariância entre resolução e extensão nas investigações diminuiu. 1.2 Pacotes e dados Agora vamos olhar um exemplo do mundo real. Uma pequena amostra do Rio Araguari, perto de Porto Grande. O ponto central da raster é de longitude: -51.406312 latitude: 0.726236. Para visualizar o ponto no Google Earth: https://earthengine.google.com/timelapse#v=0.72154,-51.41543,11.8,latLng&amp;t=2.24&amp;ps=25&amp;bt=19840101&amp;et=20201231&amp;startDwell=0&amp;endDwell=0 . Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, sf, mapview, tmap. Carregar pacotes: library(tidyverse) library(sf) library(terra) library(mapview) library(tmap) O arquivo raster tem uma pequena amostra com a classificação da terra feito pela MapBiomas, que produz mapeamento anual da cobertura e uso da terra no Brasil desde 1985. Baixar arquivo com os dados (formato “.tif”), link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/amostra_mapbiomas_2020.tif . Lembrando-se de salvar o arquivo (“amostra_mapbiomas_2020.tif”) em um local conhecido no seu computador. Carregar o arquivo trabalhamos com o pacote terra. O pacote tem varios funçoes para a análise e modelagem de dados geográficos. Nós podemos ler os dados de cobertura da terra no arquivo “.tif” com a função rast. # ramostra &lt;- rast(file.choose()) Plotar para verificar. plot(ramostra) Figura 1.1: Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. Podemos também verificar informações sobre o raster (metadados). ramostra ## class : SpatRaster ## dimensions : 8, 9, 1 (nrow, ncol, nlyr) ## resolution : 29.89281, 29.89281 (x, y) ## extent : 454659.8, 454928.9, 80160.06, 80399.2 (xmin, xmax, ymin, ymax) ## coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) ## source : amostra_mapbiomas_2020.tif ## name : mapbiomas_2020 ## min value : 3 ## max value : 33 Isso nos mostra informações sobre escala espacial (resolução e extensão) e a sistema de coordenadas (SIRGAS 2000 / UTM zone 22N (EPSG:31976\\[https://epsg.io/31976\\])). Além disso é possível obter informações específicas através de funções específicas. # Obter informações sobre escala espacial # resolução res(ramostra) # numero de colunas ncol(ramostra) # numero de linhas nrow(ramostra) 1.2.0.1 Pergunta 1 Com base nos resultados obtidos até agora em relação ao objeto raster ramostra, qual o tamanho do pixel em metros quadrados? Qual o tamnaho total da raster ramostra em hectares e quilometros quadrados? Vamos olhar o mapa de novo. plot(ramostra) Figura 1.2: Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. O mapa mostra três classes com valores de 3, 12 e 33. Lembrando, o objetivo principal não é de fazer mapas. Mas, a visualização dos dados é um passo importante para verificar e entender os padrões. Portanto, segue exemplo mostrando uma forma de visualizar o arquivo de raster como mapa. Para entender o que os valores (3, 12, 33) representam no mundo real precisamos de uma referência (legenda). Para a MapBiomas Coleção 6, arquivo: Cod_Class_legenda_Col6_MapBiomas_BR.pdf. Existe também arquivos para fazer as mapas com cores corretas em QGIS ou ArcGIS. Olhando a legenda (Cod_Class_legenda_Col6_MapBiomas_BR.pdf), sabemos que “3”, “12” e “33” representem cobertura de “Formação Florestal”, “Formação Campestre”, e “Rio, Lago e Oceano”. Então podemos fazer um mapa mostrando tais informações. Daqui pra frente vamos aproveitar uma forma mais elegante de apresentar mapas e gráficos. Isso seria atraves a função “ggplot” (pacote ggplot2), que faz parte do “tidyverse”. Mais exemplos no R cookbook : http://www.cookbook-r.com/Graphs/ . E com mais exemplos de mapas e dados espaciais no R: sf e ggplot2 : https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html Capitulo 9 no livro Geocomputation with R : https://geocompr.robinlovelace.net/adv-map.html Primeiramente precisamos incluir as informações relevantes da legenda. Ou seja, incluir os nomes para cada valor de classe. # legenda e cores na sequencia correta classe_valor &lt;- c(3, 12, 33) classe_legenda &lt;- c(&quot;Formação Florestal&quot;, &quot;Formação Campestre&quot;, &quot;Rio, Lago e Oceano&quot;) classe_cores &lt;- c(&quot;#006400&quot;, &quot;#B8AF4F&quot;, &quot;#0000FF&quot;) Agora podemos fazer o mapa com as classes e os cores seguindo o padrão recomendado pela MapBiomas para Coleção 6. # Passo necessario para mostrar os valores ramostra_df &lt;- as.data.frame(ramostra, xy = TRUE) ggplot(ramostra_df, aes(x=x, y=y)) + geom_raster(aes(fill = factor(mapbiomas_2020))) + scale_fill_manual(&quot;classe&quot;, values = classe_cores, labels = classe_legenda) + coord_equal() + geom_text(data = ramostra_df, aes(x = x, y = y, label = mapbiomas_2020)) + theme(legend.position=&quot;top&quot;) + guides(fill=guide_legend(nrow=2,byrow=TRUE)) Figura 1.3: Paisagem com valores e classes de cobertura da terra. Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. 1.3 Alterando a resolução Alterando a resolução serve como exemplo mostrando como os passos/etapas/cálculos mude dependendo o tipo de dados. Ou seja, é preciso adotar metodologias diferentes para dados categóricos (por exemplo classificação de cobertura da terra) e dados contínuos (por exemplo distância até rio). Alterando a resolução às vezes seria necessário, por exemplo, quando preciso padronizar dados/imagens oriundos de fontes diferentes com resoluções diferentes e/ou para reduzir a complexidade da modelagem. Lembrando - em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Agora iremos degradar a resolução desses dados, ou seja, iremos alterar o tamanho dos pixels. Como exemplo, iremos juntar (agregar) 3 pixels em um único pixel. Como você acha que podemos fazer isso? Quais valores esse pixel que vai substituir os 3 originais deve ter? Existem diversas maneiras de se fazer isso, uma das formas é através da média. ramostra_media&lt;-aggregate(ramostra, fact=3, fun=&quot;mean&quot;) ramostra_media &lt;- resample(ramostra, ramostra_media) Visualizar. Os valores calculados pela função não fazem sentido para uma classificação categórica. # Tidy as.data.frame(ramostra_media, xy = TRUE) %&gt;% mutate(mapbiomas_2020 = round(mapbiomas_2020,1)) -&gt; ramostra_media_df # Plot ggplot(ramostra_media_df, aes(x=x, y=y)) + geom_raster(aes(fill = factor(mapbiomas_2020))) + scale_fill_discrete(&quot;valor&quot;) + coord_equal() + geom_text(data = ramostra_media_df, aes(x = x, y = y, label = mapbiomas_2020)) Figura 1.4: Agregação errado para dados categóricos. Uso da média cria valores categóricos errados e impossíveis. Outra opção é utilizar o valor mais comum da área, o que é particularmente adequado quando temos um mapa categórico, como por exemplo floresta/não-floresta. Segue exemplo com o valor mais frequente (modal). ramostra_modal&lt;- aggregate(ramostra, fact=3, fun=&quot;modal&quot;) ramostra_modal &lt;- resample(ramostra, ramostra_modal, method=&quot;near&quot;) Visualizar. Os valores calculados pela função são consistentes com o original e fazem sentido. # Tidy ramostra_modal_df &lt;- as.data.frame(ramostra_modal, xy = TRUE) # Plot ggplot(ramostra_modal_df, aes(x=x, y=y)) + geom_raster(aes(fill = factor(mapbiomas_2020))) + scale_fill_manual(&quot;classe&quot;, values = classe_cores) + coord_equal() + geom_text(data=ramostra_modal_df, aes(x=x, y=y, label=mapbiomas_2020)) Figura 1.5: Agregação pela mais frequente. Em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Aqui por exemplo, mudamos a proporção de cobertura florestal em nossa pequeno paisagem quando juntamos 3 pixels em um único: a proporção de floresta moudou de 4% (3/72) para 11% (1/9). Ou seja, com cada passo mudamos a representção do mundo. Figura 1.6: Mudanças causadas pela agregação. 1.3.0.1 Pergunta 2 Confira o codigo e os resultados obtidos anteriormente, quando mudamos a resolução da ratser ramostra (por exemplo figuras 5.1, 5.2 e 5.3). Explique o que aconteceu. Como e porque moudou os valores em cada caso (média e modal)? 1.4 Escala espacial e desenho amostral Dado o papel que a escala pode desempenhar em nossa compreensão dos padrões e processos ecológicos, como escala deve ser considerada no desenho do estudo? Claramente, a resposta a esta pergunta irá variar dependendo dos fenômenos de interesse, mas ecologistas e estatísticos têm forneceu algumas orientações importantes. As questões-chave incluem o tamanho da unidade de amostragem (resoloção), o tipo de unidade de amostra e localizações da unidade de amostra, incluindo o espacamento entre as amostras (distância entre as amostras) e o tamanho da área de estudo. Com a disponibilidade de imagens de satélite é possível responder questões importantes relacionadas ao desenho do estudo antes de qualquer trabalho de campo. Uma tecnica de geoprocessamento (bordas - Buffers) é um dos mais frequentemente adotados para quantificar escala espacial na ecologia da paisagem. O objetivo é criar buffers circulares de diferentes extensões ao redor dos sitios de amostragem (pontos, pixels, manchas, transetos lineares etc). Aqui, vamos entender a escala em que a cobertura de floresta muda ao redor dos rios. Para isso, quantificamos a quantidade de floresta que ocorre em várias distâncias em pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Para ilustrar esta abordagem geral, usamos o banco de dados MapBiomas Coleção 6 de 2020, e vincule esses dados de cobertura da terra aos pontos de amostragem em rios. 1.4.1 Obter e carregar dados (vectores) Precisamos carregar os dados para rios e pontos de amostragem. Baixar arquivo (vector) com os dados (formato “GPKG”, tamanho 54.9 MB). Este arquivo contém diferentes camadas vetoriais usadas para avaliar impactos de barragens hidroelétricas em tracajas ((Bárcenas-García et al. 2022)) e ariranhas ((Raffo et al. 2022)). Mais sobre dados vetoriais. O formato aberto GeoPackage é um contêiner que permite armazenar dados SIG (feições/camadas) em um único arquivo. Por exemplo, um arquivo GeoPackage pode conter vários dados (dados vetoriais e raster) em diferentes sistemas de coordenadas. Todos esses recursos permitem que você compartilhe dados facilmente e evite a duplicação de arquivos. Baixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.gpkg . Lembrando-se de salvar o arquivo (“rivers.gpkg”) em um local conhecido no seu computador. O formato “GPKG” e diferente de “tif” (raster), o processo de importação é, portanto, diferente. Primeira, avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “rivers.GPKG”: meuSIG &lt;- file.choose() Agora vamos olhar o que tem no arquivo. Depois que voces rodar o codigo st_layers(meuSIG), o resultado mostra que o arquivo rivers.GPKG inclui camadas diferentes com pontos (“Point”), linhas (“Line String”) e polígonos (“Polygon”). Alem disso, a coluna “crs_name” mostrar que a sistema de coordenadas é geográfica (WGS84, (EPSG: 4326)\\[https://epsg.io/4326\\], e é diferente do arquivo raster: sf::st_layers(meuSIG) ## Driver: GPKG ## Available layers: ## layer_name geometry_type features fields crs_name ## 1 centerline Line String 52 15 WGS 84 ## 2 forestloss Point 276086 12 WGS 84 ## 3 canalpoly Polygon 3 6 WGS 84 ## 4 extentpoly50km Polygon 1 0 WGS 84 ## 5 midpoints Point 52 17 WGS 84 ## 6 midpoints_hansen Point 52 37 WGS 84 ## 7 cachoeira_caldeirao Point 1 2 WGS 84 ## 8 porto_grande Point 1 1 WGS 84 ## 9 icmbio_base Point 1 1 WGS 84 ## 10 direct_affect Polygon 1 2 WGS 84 ## 11 midpoints_hansen_distances Point 52 43 WGS 84 ## 12 midpoints_hansen_ffr Point 52 82 WGS 84 ## 13 midpoints_hansen_ffril Point 52 91 WGS 84 ## 14 direct_affect_line Line String 1 2 WGS 84 Nós só precisamos de duas dessas camadas. O código abaixo vai carregar as camadas que precisamos e criar os objetos “rsm” e “rsl”. Assim, agora temos dados com: pontos cada 5 km ao longo os rios (“rsm”) e a linha central de rios (“rsl”). # pontos cada 5 km rsm &lt;- sf::st_read(meuSIG, layer = &quot;midpoints&quot;) ## Reading layer `midpoints&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 17 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -52.01259 ymin: 0.7175827 xmax: -51.29688 ymax: 1.330365 ## Geodetic CRS: WGS 84 # linha central de rios rsl &lt;- sf::st_read(meuSIG, layer = &quot;centerline&quot;) ## Reading layer `centerline&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 15 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -52.01443 ymin: 0.7094595 xmax: -51.2924 ymax: 1.352094 ## Geodetic CRS: WGS 84 1.4.2 Visualizar os arquivos (camadas vector) Visualizar para verificar. Mapa com linha central e pontos de rios em trechos de 5km. ggplot(rsl) + geom_sf(aes(color=rio)) + geom_sf(data = rsm, shape=21, aes(fill=zone)) Figura 1.7: Pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Mapa interativo (funcione somente com internet) Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc) # mapview(rsl, zcol = &quot;rio&quot;) 1.4.3 Obter e carregar dados (raster) Mais uma vez vamos aproveitar os dados de MapBiomas. Agora baixar arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 3.3 MB). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif . Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “utm_cover_AP_rio_2020.tif”: meuSIGr &lt;- file.choose() O código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”. mapbiomas_2020 &lt;- rast(meuSIGr) 1.4.4 Visualizar os arquivos (camadas raster e vector) Visualizar para verificar. É possível de visualizar camadas de raster e vetor juntos com funcões no pacote Tmap (https://r-tmap.github.io/tmap-book/index.html). # Passo necessario para agilizar o processamento mapbiomas_2020_modal&lt;-aggregate(mapbiomas_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(mapbiomas_2020_modal) + tm_raster(title = &quot;Classe&quot;, style = &quot;cat&quot;, palette = &quot;Set3&quot;) + tm_shape(rsl) + tm_lines(col=&quot;blue&quot;) + tm_shape(rsm) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_compass(position=c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;), legend.bg.color=&quot;white&quot;) Figura 1.8: Cobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. 1.4.5 Reclassificação Para simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente). # criar uma nova camada de floresta floresta_2020 &lt;- mapbiomas_2020 # Com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar categorias florestais agrupados com valor de 1 floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 Vizualizar para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_shape(rsl) + tm_lines(col=&quot;blue&quot;) + tm_shape(rsm) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, text.color = &quot;white&quot;, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;),legend.bg.color = &quot;white&quot;) Figura 1.9: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. 1.5 Comparação multiescala Em seguida, com as coordenadas dos pontos das localizações das amostras calculamos a quantidade de floresta que circunda cada local de amostragem em diferentes extensões. rsm_31976 &lt;- st_transform(rsm, 31976) # Buffer rsm_31976_b1000 &lt;- st_buffer(rsm_31976[1, ], dist = 1000) # Recorte com buffer de 1000 metros (mudando a extensão). buffer.forest1.1km &lt;- crop(floresta_2020, snap=&quot;out&quot;, rsm_31976_b1000) # Máscara para que os pixels fora do polígono sejam nulos. buffer.forest1.1km &lt;- mask(buffer.forest1.1km, rsm_31976_b1000, touches=TRUE) names(buffer.forest1.1km) &lt;- &quot;forest_2020_1km&quot; Vizualizar para verificar. # Plot tm_shape(buffer.forest1.1km) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_shape(rsm_31976[1, ]) + tm_symbols(shape =21, col = &quot;yellow&quot;, border.col = &quot;black&quot;, border.lwd = 0.2, size=0.5) + tm_shape(rsm_31976_b1000) + tm_borders(col = &quot;black&quot;, lwd = 4, lty = &quot;dashed&quot;) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_compass(position=c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 0.5, 1), text.size = 1, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;), legend.bg.color = &quot;white&quot;) Figura 1.10: Ilustração da determinação da quantidade de habitat ao redor de um ponto. Para um determinada extensão, o habitat de interesse é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e o número de células (pixels) que contém o habitat é somado e multiplicado pela área de cada pixel. 1.5.1 Pergunta 3 Qual é a extensão em número de pixels desse recorte (buffer.forest1.1km)? Temos valores de 0 (não-floresta) e 1 (floresta). Então, para saber a aréa de floresta podemos somar o número de células (pixels) que contém o habitat e multiplica pela área de cada pixel conforme o codigo: # 1) Somatório. # No caso igual o numero de pixels de floresta. # Para todo a paisagem, somatorio &quot;global&quot;. # Não deve incluir pixels nulos, então use &quot;na.rm = TRUE&quot;. soma_floresta &lt;- global(buffer.forest1.1km, &quot;sum&quot;, na.rm = TRUE) soma_floresta ## sum ## forest_2020_1km 943 # 2) Área de cada pixel. # Sabemos o sistema de coordenadas (EPSG = 31976). # EPSG 31976 é uma sistema projetado com unidade em metros. buffer.forest1.1km ## class : SpatRaster ## dimensions : 68, 68, 1 (nrow, ncol, nlyr) ## resolution : 29.89281, 29.89281 (x, y) ## extent : 465959.3, 467992, 90921.47, 92954.18 (xmin, xmax, ymin, ymax) ## coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) ## source(s) : memory ## name : forest_2020_1km ## min value : 0 ## max value : 1 # Portanto, o tamanho de cada pixel é igual. area_pixel_m2 &lt;- 29.89281 * 29.89281 area_pixel_m2 ## [1] 893.5801 # 3) Calculos de aréa. # Aréa de floresta m2 area_floresta_m2 &lt;- soma_floresta * area_pixel_m2 area_floresta_m2 ## sum ## forest_2020_1km 842646 # Aréa de floresta hectares area_floresta_ha &lt;- area_floresta_m2 / 10000 area_floresta_ha ## sum ## forest_2020_1km 84.2646 Para uma comparação multiescala, vamos repetir o mesmo processo, mas agora com distancias de 250, 500, 1000, 2000 e 4000 metros, doubrando a escala (extensão) em cada passo. Figura 1.11: Cobertura florestal em extensões diferentes ao redor de um local de amostragem. Aspectos quantitativos das paisagens mudam fundamentalmente com a escala. Por exemplo, nesse caso, parece que a proporção de floresta aumenta à medida que a extensão aumenta de 500 para 4000 metros. Esta percepção visual é confirmada pelos valores calculados, onde as áreas são: raio 250 m = 0 hectares de floresta raio 500 m = 6,3 hectares de floresta raio 1000 m = 84,3 hectares de floresta raio 2000 m = 502.6 hectares de floresta raio 4000 m = 3351.0 hectares de floresta 1.5.2 Pergunta 4 Usando os valores listadas acima de raio e área de floresta para os diferentes buffers circulares, calcule a proporção de floresta em cada uma das diferentes extensões de buffer. Apresente 1) os resultados incluindo cálculos. 2) um gráfico com valores de extensão no eixo x e proporção da floresta no eixo y. 3) Em menos de 200 palavras apresente a sua interpretação do gráfico. 1.5.3 Pergunta 5 A modelagem multiescala quantifica as condições do ambiente em múltiplas escalas alterando o resolução ou a extensão da análise e, em seguida, avaliando qual das escalas consideradas explica melhor um padrão ou processo. Escolha 1 espécie aquático e 1 espécie terrestre que ocorram na região a montante das hidrelétricas no Rio Araguari. Com base nas diferenças entre extensões (indicados no exemplo anterior) e as características funcionais das espécies (por exemplo área de vida), escolher as extensões mais adequadas para um estudo multiescala de cada espécie. 1.6 Próximos passos: repetindo para muitas amostras. Neste exemplo comparamos a área de floresta em torno de um único ponto de amostragem. Para calcular o mesmo para todos os 52 pontos, seriam necessárias varias repetições (52 pontos x 5 extensões = 260 repetições). Poderíamos escrever código para executar esse processo automaticamente. Felizmente, alguém já escreveu funções para fazer isso e muito mais. O próximo tutorial sobre métricas de paisagem mostrará exemplos usando o pacote “landscapemetrics” (https://r-spatialecology.github.io/landscapemetrics/). "],["métricas-da-paisagem.html", "Capítulo 2 Métricas da paisagem 2.1 Apresentação 2.2 Métricas da paisagem e pacote “landscapemetrics” 2.3 Dados 2.4 Calculo de métricas 2.5 Ponto único, distâncias variados, métricas variadas", " Capítulo 2 Métricas da paisagem 2.1 Apresentação As métricas da paisagem nos ajudam a entender as mudanças na paisagem de diferentes perspectivas (visual, ecológica, cultural). Asssim sendo, análises com métricas de paisagem é um atividade fundamental na ecologia da paisagem. Nesta capitulo aprenderemos sobre como analisar a cobertura da terra com métricas de paisagem em R. As tecnicas será ilustrada através cálculos usando a cobertura florestal ao redor do Rio Araguari. Ao longo do caminho, revisaremos modelos lineares e não lineares, aprenderemos sobre manipulação de dados em R e aprenderemos como criar gráficos com o pacote ggplot2. No capitulo você aprenderá a: Importar e plotar dados raster em R e mapear locais de amostragem com os pacotes terra, sf e tmap. Calcular métricas de paisagem com o pacote landscapemetrics. Calcular métricas de paisagem em locais de amostragem e dentro de um buffer ao redor deles (comparação multiescala). Construir gráficos com o pacote ggplot2. Comparação de padrões lineares e não-lineares. 2.2 Métricas da paisagem e pacote “landscapemetrics” As métricas de paisagem são a forma que os ecólogos de paisagem usam para descrever os padrões espaciais de paisagens para depois avaliar a influência destes padrões espaciais nos padrões e processos ecológicos. landscapemetrics tem funções para calcular métricas de paisagem em paisagems categóricos (onde tem uma classificação de cobertura de terra/habitat - modelo mancha-corredor-matriz), em um fluxo de trabalho organizado. O pacote pode ser usado como um substituto do FRAGSTATS (McGarigal et al. 1995, https://doi.org/10.2737/PNW-GTR-351), pois oferece um fluxo de trabalho reproduzível para análise de paisagem em um único ambiente (Professor McGarigal se aposentou, então FRAGSTATS não é mais apoiado). landscapemetrics também permite cálculos de quatro métricas teóricas de complexidade da paisagem: entropia marginal, entropia condicional, entropia conjunta e informação mútua (Nowosad e Stepinski 2019 https://doi.org/10.1007/s10980-019-00830-x). 2.2.1 Pacotes Além do “landscapemetrics”, precisamos carregar alguns pacotes a mais para facilitar a organização e apresentação de dados espaciais (vector e raster) e os resultados. Carregar pacotes (que deve esta instalado antes): library(tidyverse) library(sf) library(raster) library(terra) library(tmap) library(gridExtra) library(kableExtra) library(mgcv) Agora, digite o código abaixo e veja o resultado. Leia com atenção e preste particular atenção na organização da página de ajuda. library(landscapemetrics) ?landscapemetrics No final da página você vai encontrar a palavra “Index”. Clique nela e você verá todas as funções do pacote. Desca até as lsm_. . . e clique em algumas delas ali. Explorar! Para listar todas as métricas disponíveis, você pode usar a função list_lsm() . A função também permite mostrar métricas filtradas por nível, tipo ou nome da métrica. Para obter mais informações sobre as métricas, consulte os arquivos de ajuda correspondentes ou https://r-spatialecology.github.io/landscapemetrics. Digite o código abaixo e veja o resultados, mostrando exemplos das métricas diferentes. # métricas de agregação, nível de fragmento landscapemetrics::list_lsm(level = &quot;patch&quot;, type = &quot;aggregation metric&quot;) # métricas de agregação, nível de classe landscapemetrics::list_lsm(level = &quot;class&quot;, type = &quot;aggregation metric&quot;) # landscapemetrics::list_lsm(metric = &quot;area&quot;) # ajudar com opções da função ?landscapemetrics::list_lsm Nesse pacote o formato geral para uma função é o seguinte “lsm_nível_métrica”: A primeira parte é sempre lsm_ (“landscapemetric”), seguinda do “nível_” e por fim a “métrica”. Ou seja, todas as funções que calculam métricas começam com lsm_ ……. Daí você deve incluir o nível da análise “p” para patch (ou seja, para a mancha/fragmento), “c” para classe e “l” para landscape ou seja, métricas para a paisagem como um todo. E daí existem inúmeras métricas, como por exemplo a cpland que é o percentual de área central - “core area” na paisagem, como vimos na aula teórica. Assim sendo, a função lsm_c_cpland vai calacular a métrica porcentagem da área central em cada classe. Lembrando existem metricas que podem se calculados nos trés niveis, e metricas que so pode se calculados somente para um nivel espcifco. Digite o código abaixo e veja o resultados, mostrando exemplos das métricas diferentes. # ajudar com opções para uma função especifica ?landscapemetrics::lsm_c_cpland 2.2.1.1 Pergunta 1 Descreva brevemente 2 métricas de cada nível usando ajudar (usando ? e/ou list_lsm) e/ou a leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises). Incluindo na descrição - o nome, porque serve, unidades de medida, e relevância ecológica. 2.3 Dados Existem varios formas de importar e exportar dados geoespaciais. Aqui, precisamos o arquivo com os dados de MapBiomas “utm_cover_AP_rio_2020.tif”, que voces baixaram no tutorial anterior (tutorial Escala https://rpubs.com/darren75/escala). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora, nós podemos carregar os dados de cobertura da terra “utm_cover_AP_rio_2020.tif” com a função rast. # Selecionar e carregar arquivo &quot;utm_cover_AP_rio_2020.tif&quot; mapbiomas_2020 &lt;- rast(file.choose()) # Reclassificação - # Criar uma nova camada de floresta (novo objeto de raster copiando mapbiomas_2020, # assim para ter os mesmos coordenados, resolução e extensão) floresta_2020 &lt;- mapbiomas_2020 # Todos os pixels com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar com valor de 1 quando pixels originais são de floresta (classe 3 e 4) floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 ## |---------|---------|---------|---------| ========================================= |---------|---------|---------|---------| ========================================= Plotar para verificar, incluindo nomes e os cores para classes de floresta (valor = 1) e não-floresta (valor = 0). # Passo necessario para agilizar o processamento floresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_layout(legend.bg.color = &quot;white&quot;) Se esta todo certo, voces devem ter uma imagem assim: Figura 2.1: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. 2.3.1 Exibir dados raster e sobreposição com locais de amostragem Agora temos a paisagem, precisamos tambem os pontos de amostra. Por isso, precisamos carregar os dados de rios e pontos de amostragem que usamos no tutorial Escala - arquivo “rivers.GPKG”. Vamos carregar as camadas que voces baixaram no tutorial anterior. Baixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.GPKG . Lembrando-se de salvar o arquivo (“rivers.GPKG”) em um local conhecido no seu computador. Agora, com o proximo bloco de codigo, podemos selecionar o arquivo “rivers.GPKG”, e carregar primeiramente a camada “midpoints” e depois “centerline”. No exemplo, usamos %&gt;%, que estabelece a ligação entre os passos do processo. Ou seja, %&gt;% passa o objeto resultante automaticamente para a próxima função como primeiro argumento. Primeiramente carregamos os dados e em seguida converter (reprojeção) as coordenadas para o mesmo sistema de referência que o arquivo raster (com a função st_transform). # Selecionar o arquivo &quot;rivers.GPKG&quot;, meuSIG &lt;- file.choose() # Carregar pontos cada 5 km, camada midpoints rsm_31976 &lt;- sf::st_read(meuSIG, layer = &quot;midpoints&quot;) %&gt;% st_transform(31976) # Carregar linha central de rios, camada centerline rsl_31976 &lt;- sf::st_read(meuSIG, layer = &quot;centerline&quot;) %&gt;% st_transform(31976) Visualizer para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_shape(rsl_31976) + tm_lines(col=&quot;blue&quot;) + tm_shape(rsm_31976) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_layout(legend.bg.color=&quot;white&quot;) Depois de executar (“run”) o código acima, você deverá ver a figura a seguir. Figura 2.2: Cobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio (linha azul). 2.4 Calculo de métricas Para ilustrar como rodar as funções e cálculos com landscapemetrics, vamos calcular a área central na paisagem. Vamos estudar uma classe (floresta), portanto vamos incluir as métricas para nível de classe. Além disso, as métricas de paisagem em nível de classe são mais eficazes na definição de processos ecológicos (Tischendorf, L. Can landscape indices predict ecological processes consistently?. Landscape Ecology 16, 235–254 (2001). https://doi.org/10.1023/A:1011112719782.). Para calcular as métricas de paisagem dentro de um certo buffer em torno de pontos de amostra, existe a função sample_lsm(). Através da função sample_lsm() podemos calcular mais de 50 métricas da paisagem, dentro de extensões (raios/distancias) diferentes. 2.4.1 Ponto único, raio único, métrica única Métricas de área central (“core area”) são consideradas medidas da qualidade de hábitat, uma vez que indica quanto existe realmente de área efetiva de um fragmento, após descontar-se o efeito de borda. Vamos calcular a percentual de área central (“core area”) no entorno de um ponto de amostragem. Isso seria, a percentual de áreas centrais (excluídas as bordas de 30 m) de cada classe em relação à área total da paisagem. Para a função sample_lsm() funcionar, precisamos informar (i) a paisagem (arquivo de raster), (ii) ponto (arquivo vector), (iii) raio, (iv) forma do buffer (círculo ou quadrado) e por final (v) a métrica desejada. Cada opção tem especificações particulares assim para que a função pode receber dados em formatos diferentes e produzir resultados confiorme necessidades de diversos casos. minha_amostra_1000 &lt;- sample_lsm(landscape = floresta_2020, y = rsm_31976[1, ], size = 1000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;, edge_depth = 1) Depois que executar (“run”), podemos olhar os dados com o codigo a seguir. Os dados deve ter os valores (coluna value) da métrica (coluna metric) de cada classe (coluna class): minha_amostra_1000 layer level class id metric value plot_id percentage_inside 1 class 0 NA cpland 66.94191 1 99.9608 1 class 1 NA cpland 19.07745 1 99.9608 2.4.1.1 Pergunta 2 O modelo mancha-corredor-matriz é frequentemente adotado na ecologia da paisagem. Com base nas aulas teóricas e usando os valores no objeto minha_amostra_1000 apresentados na tabela acima, identificar qual classe representar a matriz na paisagem. Há alguma informação faltando que limita a sua capacidade de identificar qual classe representar a matriz? Se sim, o que precisa ser adicionado? Justifique as suas respostas de forma clara e concisa. 2.4.2 Ponto único, distâncias variados, métrica única Figura 2.3: Cobertura florestal em extensões diferentes ao redor de um ponto de amostragem. Para uma comparação multiescala, vamos calcular a mesma métrica, no mesmo ponto, mas agora com extensões diferentes. Continuando o exemplo no tutorial anteriio (Escala), vamos repetir o mesmo processo, mas agora com raios de 250, 500, 1000, 2000, 4000, 8000 e 16000 metros, doubrando a escala (extensão) em cada passo. Para obter resultados com extensões diferentes, precisamos primeiramente repetir o código, ajustando para cada extensão, e depois juntar os resultados. O código a seguir calculará a mesma métrica para as diferentes distâncias. No exemplo, usamos %&gt;%, que estabelece a ligação entre os passos do processo. Neste caso, para incluir uma coluna nova (raio) para manter o valor das diferentes distâncias. # raio 250 metros sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 250, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 250) -&gt; minha_amostra_250 # raio 500 metros sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 500, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 500) -&gt; minha_amostra_500 # raio 1 km (1000 metros) sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 1000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 1000) -&gt; minha_amostra_1000 # raio 2 km sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 2000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 2000) -&gt; minha_amostra_2000 # raio 4 km sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 4000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 4000) -&gt; minha_amostra_4000 # raio 8 km sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 8000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 8000) -&gt; minha_amostra_8000 # raio 16 km sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 16000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) %&gt;% mutate(raio = 16000) -&gt; minha_amostra_16000 E agora, o código a seguir juntará os resultados das diferentes extensões. bind_rows(minha_amostra_250, minha_amostra_500, minha_amostra_1000, minha_amostra_2000, minha_amostra_4000, minha_amostra_8000, minha_amostra_16000) -&gt; amostras_metrica Depois que executar (“run”), podemos olhar os dados “amostras_metrica” com o codigo a seguir. amostras_metrica Os dados deve ter os valores (coluna value) da métrica (coluna metric) de cada classe (coluna class) para cada distância (coluna raio): layer level class id metric value plot_id percentage_inside raio 1 class 0 NA cpland 79.4 1 99 250 1 class 0 NA cpland 86.9 1 100 500 1 class 1 NA cpland 0.7 1 100 500 1 class 0 NA cpland 66.9 1 100 1000 1 class 1 NA cpland 19.1 1 100 1000 1 class 0 NA cpland 57.6 1 100 2000 1 class 1 NA cpland 26.9 1 100 2000 1 class 0 NA cpland 36.2 1 100 4000 1 class 1 NA cpland 42.2 1 100 4000 1 class 0 NA cpland 35.8 1 100 8000 1 class 1 NA cpland 45.4 1 100 8000 1 class 0 NA cpland 37.1 1 100 16000 1 class 1 NA cpland 46.3 1 100 16000 2.4.2.1 Faça um gráfico Uma imagem vale mais que mil palavras. Portanto, gráficos/figuras/imagens são uma das mais importantes formas de comunicar a ciência. Os dados apresentados em uma tabela podem ser difíceis de entender. Portanto, a primeira pergunta que você deve se fazer é se você pode transformar aquela tabela (chata e feia) em algum tipo de gráfico. Lembrando, sempre pode incluir a tabela como anexo. Aqui, vamos fazer um grafico com os dados amostras_metrica, usando o pacote ggplot2. O ggplot2 faz parte do conjunto de pacotes tidyverse, e é um pacote de visualização de dados. “gg” se refere a uma gramática de gráficos. A ideia principal é criar um gráfico como se fosse uma frase, onde cada elemento do gráfico seria uma palavra, organizados em uma sequencia logica para construir uma frase completo (gráfico final). Você fornece os dados, informa ao ggplot2 como mapear variáveis para estética, quais tipos/formatos gráficas usar e ele cuida dos detalhes. Isto nos permite construir gráficos tão complexos quanto quisermos. Os gráficos criados com ggplot2 são, em geral, mais elegantes do que os gráficos tradicionais do R. Para mais exemplos e tutoriais com mais detalhes veja os capitulos sobre ggplot2 nos livros: Ciência de Dados com R Análises Ecológicas no R No livro em ingles R Graphics Cookbook . E sempre pode buscar exemplos no Google, por exemplo digitando: ggplot2 grafico de barra no Google, tem mais de 50 mil resultados com paginas de imagens, codigo pronto e exemplos no YouTube. O ggplot2 exige que os dados a serem plotados estejam em um “dataframe” (tabela de dados). Ou seja, sempre teremos que transformar os dados para dataframe ou construir um dataframe com os dados que possuímos. Dataframe é um formato comum e fácil de trabalhar. Por exemplo, se você importar uma planilha de dados, o resultado seria como dataframe (para mais detalhes veja Estrutura e manipulação de objetos e lendo dados ). Além disso, o resultado dos funções de landscapemetrics é sempre um dataframe, ou seja os resultados da função sample_lsm() são prontos para um grafico. O principal função a ser utilizado é ggplot(). Para ggplot, precisamos os dados (dataframe), e depois cria o “mapeamento” das variáveis, normalmente usando aes (de aesthetics). Ou seja, você especifica quais são as variáveis dos eixos x e y dentro de aes(). Através dele vamos definir qual é a variável preditora/explanatora (eixo x) e qual é a variável resposta (eixo y) em nosso conjunto de dados. Depois da função ggplot(), na sequencia no codigo nós especificamos qual tipo de grafico com um “geom”. Por exemplo, geom_point() para plotar pontos, geom_boxplot() para um boxplot, etc. Para a lista completa de geoms e todas as outras opções do pacote, visite a página do projeto ggplot2 https://ggplot2.tidyverse.org/index.html . Aqui vamos fazer um gráfico com valores de extensão no eixo x e proporção da floresta central no eixo y. Assim sendo, com o codigo a segir, vamos informar (i) os dados, selecionando classe de floresta atraves de um filtro e acresentando uma coluna nova (“ext_m”) com a extensão em metros, (ii) as colunas para os eixos x e y, (iii) tipo de grafico (grafico de pontos - geom_point() e grafico de linha - geom_line()), (iv) nomes para os eixos. No exemplo, usamos %&gt;%, que estabelece a ligação entre os passos do processo, ligando os dados (amostras_metrica) e o grafico ggplot. Note que no codigo a seguir, adicionamos um geom com um “+”. No ggplot2, nós criamos gráficos em camadas, e adicionamos camada a camada com um “+”. Assim, é posivel ajustar qualquer elemento do grafico. # arrumar os dados amostras_metrica %&gt;% filter(class==1) %&gt;% mutate(ext_m = 2*raio) %&gt;% # fazer o grafico ggplot(aes(x=ext_m, y=value)) + geom_point() + geom_line() + labs(x = &quot;Extensão (metros)&quot;, y = &quot;Área central de floresta (porcentagem da paisagem)&quot;) Depois de executar (“run”) o código acima, você deverá ver o grafico a seguir. 2.4.2.2 Pergunta 3 Em vez de extensão, você preciso incluir o tamanho (área do circulo) correspondente a cada raio. Incluir uma cópia do código ajustado para produzir uma figura com tamanho (área em quilômetros quadrados) no eixo x. 2.4.3 Faça um gráfico elegante Podemos ajustar qualquer elemento do grafico com ggplot2. Agora, vamos mudar as unidades de metros para quilometros, aumentar o tamanho dos pontos, incluir uma linha reta para ilustrar a tendência geral, colocar o titulo longo do eixo y em duas linhas, e aumentar o tamanho da fonte para o texto ficar mais claro. # arrumar os dados amostras_metrica %&gt;% filter(class==1) %&gt;% mutate(ext_m = 2*raio, ext_km = (2*raio)/1000) %&gt;% # fazer o grafico ggplot(aes(x=ext_km, y=value)) + geom_point(size = 4) + geom_line() + stat_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;green&quot;, linetype = &quot;dashed&quot;) + labs(x = &quot;Extensão (quilômetros)&quot;, y = &quot;Área central de floresta\\n(porcentagem da paisagem)&quot;) + theme(text = element_text(size = 18)) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Figura 2.4: Comparação da área central de floresta em diferentes extensões. 2.4.3.1 Pergunta 4 Em menos de 200 palavras apresente a sua interpretação do gráfico em figura 5.2. 2.4.4 Modelos linear e não linear Um dos desafios mais frequentes é como melhor representar os dados observados para gerar evidências científicas robustas e informações confiáveis. Nós vimos que as mudancas na métrica porcentagem de área central de floresta não segue uma linha reta em relação de escala (extensão). Para ir além de uma descrição simplista dos padrões observados, na ecologia da paisagem uma variedade de modelos estatísticos são usados.Não vamos rodar modelos (ainda), mas é importante entender algumas das opções disponíveis ao interpretar os gráficos. Por exemplo, modelos de regressão são amplamente usados em diversas aplicações para descrever a relação entre uma variável resposta Y e uma variável explicativa x. Os modelos lineares são uma generalização dos testes de hipótese clássicos mais simples (Modelos linear e Modelos lineares). Uma regressão linear, só pode ser aplicada para dados em que tanto a variável preditora quanto a resposta são contínuas, enquanto uma análise de variância é utilizada quando a variável preditora/explicativa é categórica. Os modelos lineares generalizados não têm essa limitação, podemos usar variáveis contínuas ou categóricas indistintamente (Modelos Lineares Generalizados). Mas, no caso de padroes ecologicas, sera que um modelo linear é o melhor modelo para representar a relação que explica “y” em função de “x”? Um número crescente de pesquisadores compartilham o sentimento de que as relações entre variáveis biológicas/ecologicas são melhores descritas por funções não lineares. Processos ecologicas (como por exemplo crescimento, mortalidade, dispersão, e competição) raramente são relacionadas linearmente às variáveis explicativas. A principal vantagem do modelo não linear sobre o linear é que 1) sua escolha está associada à conhecimento prévio sobre a relação a ser modelada e 2) geralmente apresenta interpretação prática para os parâmetros. Em modelos não-linear dados observados de uma variável resposta são descritos por uma função de uma ou mais variáveis explicativas que é não linear seus parâmetros. Assim como nos modelos lineares o objetivo é identificar e estabelecer a relação entre variáveis explicativas e resposta. Entretanto, enquanto os modelos lineares definem, em geral, relações empíricas/teoricas, os modelos não-lineares são, em grande parte das vezes, motivados pelo conhecimento do tipo de relação entre as variáveis. Desta forma, as aplicações surgem nas diversas áreas onde relações físicas, biológicas, cinéticas, químicas, fisiológicas, dentre outras, são estabelecidas por funções não lineares que devem ter coeficientes (parâmetros) identificados (estimados) a partir de dados observados, dados experimentais e/ou dados simulados. Como as mudanças na estrutura da paisagem caracterizam-se por serem não-lineares, para desenvolver análises estatísticas robustos pode (i) aplicar uma transformação (por exemplo, “log”) ou (ii) adotar modelos não-lineares. Figura 2.5: Comparação de padrões lineares e não-lineares. 2.4.4.1 Pergunta 5 Comparar os resultados apresentados nas figuras com modelos lineares e não-lineares. Como podemos estabelecer qual seria o melhor modelo? Qual modelo seria mais adequado para identificar limiares no padrão de área central de floresta? 2.5 Ponto único, distâncias variados, métricas variadas No exemplo anterior comparamos uma métrica da paisagem em torno de um único ponto de amostragem. Mas sabemos que uma combinação de várias métricas de paisagem diferentes é necessária para entender os padrões na paisagem. Aqui mostraremos como incluir cálculos de diferentes métricas de paisagem ao mesmo tempo. Figura 2.6: Ilustração da determinação de métricas da paisagem diferentes ao redor de um ponto. Exemplo com a estrutura da paisagem representado com trés caracteristicas (A) Área central, (B) Borda e (C) Vizinho mais próximo. O habitat de interesse (classe) é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e as métricas calculadas. E em seguida o processo é repetido em diferentes extensões. Não deve calcular todas as métricas disponíveis, mas sim, escolher aquelas que podem ser realmente adequadas para sua pergunta de pesquisa. Calculando todas as métricas se chama um “tiro no escuro”, algo cujo resultado se desconhece ou é imprevisível. Isso não é recomendado. Para fazer uma escolha melhor (mais robusta), seguindo princípios básicos da ciência, precisamos ler os estudos anteriores (artigos) para obter as métricas mais relevantes para nosso objetivo, pergunta e/ou a hipótese a ser testada. Aqui, como exemplo illustrativa vamos calcular alguns das métricas mais comums. Mas, isso não representa necessariamente as métricas mais adequados ou recommendadas. Métricas de área e borda (area and edge metrics). Quantificam a composição da paisagem: pland = percentage of landscape. Percentagem da paisagem. Porcentagem de cobertura da classe na paisagem. ed = edge density . Densidade de borda que é igual à soma dos comprimentos (m) de todos os segmentos de borda que envolvem o fragmento, dividida pela área total da paisagem (m²), sendo posteriormente convertido em hectares. cpland = core area percentage of landscape. Percentual de área central (“core”) na paisagem. Percentual de áreas centrais (excluídas as bordas de 30 m) em relação à área total da paisagem. O termo “Core area” foi traduzido como área central ou área núcleo. Aqui vamos adotar área central. Métricas de agregação. Quantificam a configuração da paisagem: enn = euclidian nearest neighbour distance. Distância euclidiana do vizinho mais próximo. enn_cv = Coefficient of variation of euclidean nearest-neighbor distance. Coeficiente de variação da distância euclidiana do vizinho mais próximo. A métrica resume cada classe como o Coeficiente de variação das distâncias euclidianas do vizinho mais próximo entre as manchas pertencentes à classe. O valor de enn_cv = 0 se a distância euclidiana do vizinho mais próximo for idêntica para todas as manchas. Aumenta, sem limite, à medida que a variação do ENN aumenta. enn_sd = Standard deviation of euclidean nearest-neighbor distance. Desvio padrão da distância euclidiana do vizinho mais próximo. pd = Patch density. Densidade das manchas. cohesion = Cohesion index. Índice de coesão das manchas. Para incluir cálculos de diferentes métricas de paisagem ao mesmo tempo, precisamos acrescentar somente uma nova linha de codigo. Uma nova linha, que cria um objeto com os nomes das funções para as métricas que queremos calcular….. Também precisamos usar a opção “what” na função para aceitar os nomes das funções. # Objeto com os nomes das funções para calcular as métricas desejadas. minhas_metricas &lt;- c(&quot;lsm_c_pland&quot;, &quot;lsm_c_ed&quot;, &quot;lsm_c_cpland&quot;, &quot;lsm_c_enn_mn&quot;, &quot;lsm_c_enn_sd&quot;, &quot;lsm_c_enn_cv&quot;, &quot;lsm_c_pd&quot;,&quot;lsm_c_cohesion&quot;) # 8 Métricas calculadas para cada extensão # raio 250 metros sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 250, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 250) -&gt; metricas_amostra_250 # raio 500 metros sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 500, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 500) -&gt; metricas_amostra_500 # raio 1 km (1000 metros) sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 1000, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 1000) -&gt; metricas_amostra_1000 # raio 2 km (2000 metros) sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 2000, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 2000) -&gt; metricas_amostra_2000 # raio 4 km (4000 metros) sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 4000, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 4000) -&gt; metricas_amostra_4000 # raio 8 km (8000 metros) sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 8000, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 8000) -&gt; metricas_amostra_8000 # raio 16 km (16000 metros) sample_lsm(floresta_2020, y = rsm_31976[1, ], size = 16000, shape = &quot;circle&quot;, what = minhas_metricas) %&gt;% mutate(raio = 16000) -&gt; metricas_amostra_16000 E agora, o código a seguir juntará os resultados das diferentes extensões. bind_rows(metricas_amostra_250, metricas_amostra_500, metricas_amostra_1000, metricas_amostra_2000, metricas_amostra_4000, metricas_amostra_8000, metricas_amostra_16000) -&gt; amostras_metricas Depois que executar (“run”), podemos olhar os dados com o codigo a seguir. amostras_metricas Os dados deve ter os valores (coluna value) das métricas (coluna metric) de cada classe (coluna class) para cada distância (coluna raio): layer level class id metric value plot_id percentage_inside raio 1 class 0 NA cohesion 100.00 1 99.3 250 1 class 0 NA cpland 79.36 1 99.3 250 1 class 0 NA ed 0.00 1 99.3 250 1 class NA NA enn_cv NA 1 99.3 250 1 class NA NA enn_mn NA 1 99.3 250 1 class NA NA enn_sd NA 1 99.3 250 1 class 0 NA pd 5.13 1 99.3 250 1 class 0 NA pland 100.00 1 99.3 250 1 class 0 NA cohesion 99.96 1 100.1 500 1 class 1 NA cohesion 73.61 1 100.1 500 Agorta, vamos fazer um grafico com os dados amostras_metricas, usando o pacote ggplot2. Para ajudar na visualização incluímos quais métricas são para composição e configuração e nomes que são mais fáceis de entender. metricas_composicao &lt;- c(&quot;pland&quot;, &quot;ed&quot;, &quot;cpland&quot;) # arrumar dados amostras_metricas %&gt;% filter(class==1) %&gt;% mutate(ext_km = (2*raio)/1000, met_cat = if_else(metric %in% metricas_composicao, &quot;composição&quot;, &quot;configuração&quot;)) %&gt;% # fazer grafico ggplot(aes(x=ext_km, y=value)) + geom_point() + geom_line() + facet_wrap(met_cat~metric, scales = &quot;free_y&quot;) + labs(title = &quot;Comparação multiescala de várias métricas&quot;, x = &quot;extensão (quilômetros)&quot;, y = &quot;metric value&quot;) 2.5.0.1 Pergunta 6 Com base nos resultados apresentados (figura e tabela) caracterisar as mudançãs na paisagem em função de extensões diferentes. Olhando os graficos prever como seria o padrão para extensões maiores (lembrando que valores são doubrados - por exemplo raio de 250 metros gerar uma extensão de 500 metros). Seria relevante repetir incluindo calculos para extensões maiores (por exemplo 64 km e 128 km)? Justifique sua caracterização e previsões de forma clara e concisa, apoie sua escolha com exemplos da literatura científica. 2.5.0.2 Pergunta 7 Usando como base o conteudo das aulas, leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises), e/ou exemplos apresentados aqui no tutorial, selecione pelo menos seis métricas de nível classe para caracterizar a paisagem de estudo e objectivos da sua projeto. Justifique sua seleção de forma clara e concisa, apoie sua escolha com exemplos da literatura científica. "],["codigo-no-livro.html", "Capítulo 3 Codigo no livro 3.1 Organização do codigo no livro", " Capítulo 3 Codigo no livro Objetivo não é de apresentar detalhes sobre os cálculos/métodos estatísticas ou os funções no R. Existem diversos exemplos disponíveis “Ciência de Dados com R–Introdução……”: e com google “r cran introdução tutorial”……. Alem disso, existem grupos de ajuda, como por exemplo: R Brasil e Stack Overflow em Português O objetivo é de apresentar um livro mostrado os capacidades e opções para desenvolver e integrar pesquisas na ecologia da paisagem no ambiente estatística de R Obviamente, todas as tarefas de geoprocessamento podem ser desenvolvidas anteriormente em um SIG (QGIS). Então porque use R? R tem a capacidade (baseada em codigo) para alternar entre tarefas de processamento, modelagem e visualização de dados geográficos e não geográficos. Alem disso, como é possível importar, modificar, analisar e visualizar dados espaciais no mesmo ambiente com script/codigo, o R permite fluxos de trabalho transparentes e reproduzíveis (A Ciência Aberta). Aliás, atualmente a grande maioria dos artigos científicos publicados na revista Landscape Ecology incluir análises usando R. 3.1 Organização do codigo no livro O capitulo está organizado em etapas de processamento, com blocos de código em caixas cinzas: codigo de R para executar Para segue os passos, os blocos de código precisam ser executados em sequência. Se você pular uma etapa, ou rodar fora de sequência o próximo bloco de código provavelmente não funcionará. As linhas de codigo de R dentro de cada caixa tambem preciso ser executados em sequência. O simbolo # é usado para incluir comentarios sobre os passos no codgio (ou seja, linhas começando com # não é codigo de executar). # Passo 1 codigo de R passo 1 # texto e numeros tem cores diferentes # Passo 2 codigo de R passo 2 # Passo 3 codigo de R passo 3 Alem disso, os simbolos #&gt; e/ou [1] no início de uma linha indica o resultado que você verá no console de R. # Passo 1 1+1 [1] 2 # Passo 2 x &lt;- 1 + 1 # Passo 3 x [1] 2 # Passo 4 x + 1 [1] 3 "],["primeiros-passos-com-uma-raster.html", "Capítulo 4 Primeiros passos com uma raster", " Capítulo 4 Primeiros passos com uma raster Uma raster é um matriz de valores com coordenadas geográficos. Cada pixel de uma raster representa uma região geográfica, e o valor do pixel representa uma característica dessa região (mais sobre dados raster). Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, terra, sf, mapview, tmap. Carregar pacotes: library(tidyverse) library(terra) library(sf) library(mapview) library(tmap) Inicialmente iremos gerar uma raster representando uma paisagem bem simples, de 6 por 6 pixels. Você já deve saber que pixel é a unidade básica de uma imagem (lembra da camera do seu celular, 10Mb ou algo assim?!). Vocês devem ter visto sobre pixels e resolução no mesmo em aulas de geoprocessamento. Aqui podemos tratar o pixel como a resolução. Vamos dizer que temos um pixel de 10 metros (res=10 no bloco de código), ou seja, uma quadrado de 10 por 10m, sendo essa, a menor unidade mapeável. Assim sendo, a resolução tambem tem ligação com escala cartográfica! Vamos gerar e plotar uma paisagem simples em 4 passos. Primeiramente, a função rast cria um objeto do tipo raster. E depois a função values atribui valores, e na sequencia vamos visualisar os valores com plot e text . #Função &quot;rast&quot; gera a paisagem virtual (paisagem simulado) pai_sim &lt;- rast(ncols=6, nrows=6, xmin=1, xmax=60, ymin=1, ymax=60, res=10) #E essa atribui valores (&quot;values&quot;) para os pixels criados acima values(pai_sim) &lt;- 1 plot(pai_sim) #Essa plota text(pai_sim) #Essa coloca os valores dos pixels Figura 4.1: Paisagem simples de 36 pixels. 4.0.1 Obter e carregar dados (raster) Mais uma vez vamos aproveitar os dados de MapBiomas. Agora baixar arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 3.3 MB). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif . Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “utm_cover_AP_rio_2020.tif”: meuSIGr &lt;- file.choose() O código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”. mapbiomas_2020 &lt;- rast(meuSIGr) 4.0.2 Reclassificação Para simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente). # criar uma nova camada de floresta floresta_2020 &lt;- mapbiomas_2020 # Com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar categorias florestais agrupados com valor de 1 floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 Vizualizar para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, text.color = &quot;white&quot;, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;),legend.bg.color = &quot;white&quot;) Figura 4.2: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. "],["primeiros-passos-com-vector.html", "Capítulo 5 Primeiros passos com vector 5.1 Obter e carregar dados (vectores) 5.2 Visualizar os arquivos (camadas vector)", " Capítulo 5 Primeiros passos com vector Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, sf, mapview, tmap. Carregar pacotes: library(tidyverse) library(sf) library(mapview) library(tmap) 5.1 Obter e carregar dados (vectores) Precisamos carregar os dados para rios e pontos de amostragem. Baixar arquivo (vector) com os dados (formato “GPKG”, tamanho 54.9 MB). Mais sobre dados vetoriais. O formato aberto GeoPackage é um contêiner que permite armazenar dados SIG (feições/camadas) em um único arquivo. Por exemplo, um arquivo GeoPackage pode conter vários dados (dados vetoriais e raster) em diferentes sistemas de coordenadas. Todos esses recursos permitem que você compartilhe dados facilmente e evite a duplicação de arquivos. Baixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.gpkg . Lembrando-se de salvar o arquivo (“rivers.gpkg”) em um local conhecido no seu computador. O formato “GPKG” e diferente de “tif” (raster), o processo de importação é, portanto, diferente. Primeira, avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “rivers.GPKG”: meuSIG &lt;- file.choose() Agora vamos olhar o que tem no arquivo. Depois que voces rodar o codigo st_layers(meuSIG), o resultado mostra que o arquivo rivers.GPKG inclui camadas diferentes com pontos (“Point”), linhas (“Line String”) e polígonos (“Polygon”). Alem disso, a coluna “crs_name” mostrar que a sistema de coordenadas é geográfica (WGS84, (EPSG: 4326)\\[https://epsg.io/4326\\], e é diferente do arquivo raster: sf::st_layers(meuSIG) ## Driver: GPKG ## Available layers: ## layer_name geometry_type features fields crs_name ## 1 centerline Line String 52 15 WGS 84 ## 2 forestloss Point 276086 12 WGS 84 ## 3 canalpoly Polygon 3 6 WGS 84 ## 4 extentpoly50km Polygon 1 0 WGS 84 ## 5 midpoints Point 52 17 WGS 84 ## 6 midpoints_hansen Point 52 37 WGS 84 ## 7 cachoeira_caldeirao Point 1 2 WGS 84 ## 8 porto_grande Point 1 1 WGS 84 ## 9 icmbio_base Point 1 1 WGS 84 ## 10 direct_affect Polygon 1 2 WGS 84 ## 11 midpoints_hansen_distances Point 52 43 WGS 84 ## 12 midpoints_hansen_ffr Point 52 82 WGS 84 ## 13 midpoints_hansen_ffril Point 52 91 WGS 84 ## 14 direct_affect_line Line String 1 2 WGS 84 Nós só precisamos de duas dessas camadas. O código abaixo vai carregar as camadas que precisamos e criar os objetos “rsm” e “rsl”. Assim, agora temos dados com: pontos cada 5 km ao longo os rios (“rsm”) e a linha central de rios (“rsl”). # pontos cada 5 km rsm &lt;- sf::st_read(meuSIG, layer = &quot;midpoints&quot;) ## Reading layer `midpoints&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 17 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -52.01259 ymin: 0.7175827 xmax: -51.29688 ymax: 1.330365 ## Geodetic CRS: WGS 84 # linha central de rios rsl &lt;- sf::st_read(meuSIG, layer = &quot;centerline&quot;) ## Reading layer `centerline&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 15 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -52.01443 ymin: 0.7094595 xmax: -51.2924 ymax: 1.352094 ## Geodetic CRS: WGS 84 5.2 Visualizar os arquivos (camadas vector) Visualizar para verificar. Mapa com linha central e pontos de rios em trechos de 5km. ggplot(rsl) + geom_sf(aes(color=rio)) + geom_sf(data = rsm, shape=21, aes(fill=zone)) Figura 5.1: Pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Mapa interativo (funcione somente com internet) Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc) # mapview(rsl, zcol = &quot;rio&quot;) "],["bibliografia.html", "Bibliografia", " Bibliografia "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
