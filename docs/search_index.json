[["index.html", "Ecologia de Paisagens com R Bem-vindos Agradecimentos", " Ecologia de Paisagens com R Darren Norris: darren.norris@unifap.br 16 dezembro, 2023 Bem-vindos Este é um trabalho em andamento do 1ª edição: “Ecologia de Paisagens com R”. Versoes: web: https://darrennorris.github.io/epr/ pdf: https://github.com/darrennorris/epr/blob/main/docs/epr.pdf Este é um material introdutório destinado principalmente a estudantes de graduação e cursos de pós-graduação em ecologia e áreas correlatas. O objetivo é de apresentar os capacidades e opções para desenvolver e integrar pesquisas na Ecologia da Paisagem no ambiente estatística de R. Esperamos que ele seja utilizado tanto por quem quer se aprofundar em análises comumente utilizadas em Ecologia da Paisagem, mesmo por quem tem poucas habilidades quantitativas. O conteudo e organização dos capítulos esta separado em partes. O primeiro parte é “Apresentação”. o objetivo dessa parte é inclui os aspectos mais gerais sobre os componentes e da estrutura do livro e seus objetivos. O segundo é “Escala e Padrões”. Aqui, os capitulos inclui um breve introdução usando R para explorar alguns componentes chaves da Ecologia da Paisagem. A terceira é “Exemplos de caso”. Aqui, os capítulos apresentam a aplicação de análises específicas e atualmente utilizadas em Ecologia da Paisagem. A quarta parte do livro é chamada de “R e RStudio”. Esta parte trata o funcionamento da linguagem R. Aqui, nós aprendemos desde como instalar o R e o RStudio até a manipulação e visualização de dados geoespaciais no R. A parte final é “Encerramento”. Aqui os capítulos apresentam a bibliografia, alguns apêndices (exemplos de código) e soluções dos exercícios dos capítulos anteriores. Agradecimentos Este livro não é apenas o resulto dos autores. Mas é o resultado de muitas pessoas na comunidade R e Ecologia da Paisagem no Brasil. Muito obrigado! "],["prefácio-à-primeira-edição.html", "Prefácio à primeira edição", " Prefácio à primeira edição Há quem diga que a velocidade com que a tecnologia e a ciência avançam tende a tornar livros e manuais sobre métodos rapidamente obsoletos. A evolução dos computadores pessoais e a ampliação do acesso a estes e à Internet têm transformado o jeito como aprendemos e ensinamos. As pessoas estão cada vez mais familiarizados com a tecnologia e esperam que o ensino seja dinâmico e interativo. Portanto, um livro aberto e disponível livremente, que as pessoas possam compartilhar e contribuir torna-se uma opção cada vez mais relevante. A intenção é para o livro seja utilizado como material de referência (fornecendo informações atualizadas); Como ferramenta de aprendizagem (apresentando diferentes ideias e abordagens) e como projeto de colaboração (permitindo que pessoas trabalhem juntos para criar um recurso educacional valioso). "],["introdução.html", "Introdução O que você vai aprender Como este livro está organizado O que você não vai aprender Prerequisites 0.1 Codigo no livro", " Introdução Ecologia da Paisagem é uma disciplina empolgante que permite transformar dados brutos em compreensão, insight e conhecimento. O que você vai aprender Ecologia da Paisagem é um campo vasto e não há como dominar tudo lendo um único livro. Este livro visa fornecer uma base sólida nas ferramentas mais importantes e conhecimento suficiente para encontrar os recursos para aprender mais quando necessário. Um modelo das etapas de um projeto típico de Ecologia da Paisagem se parece com….. Six key steps for functional landscape analyses of habitat change https://doi.org/10.1007/s10980-020-01048-y - Acknowledge ecological theory and conceptual paradigms - Evaluate the fit of available data - Assess the three facets of the scale concept - Recognize different sampling designs - Use proper conceptual models - Measure meaningful raster characteristics Como este livro está organizado A descrição anterior das ferramentas da Ecologia da Paisagem é organizada aproximadamente de acordo com a ordem em que você as usa em uma análise (embora, é claro, você as itere várias vezes). Em nossa experiência, no entanto, aprender a importar e organizar os dados primeiro não é o ideal, porque 80% do tempo é rotineiro e chato e, nos outros 20% do tempo, é estranho e frustrante. Esse é um péssimo lugar para começar a aprender um novo assunto! Em vez disso, começaremos com a visualização e transformação dos dados que já foram importados e organizados. Dessa forma, quando você ingerir e organizar seus próprios dados, sua motivação permanecerá alta porque você sabe que a dor vale o esforço. Dentro de cada capítulo, tentamos aderir a um padrão consistente: comece com alguns exemplos motivadores para que você possa ver o quadro geral e depois mergulhe nos detalhes. Cada seção do livro é combinada com exercícios para ajudá-lo a praticar o que aprendeu. Embora possa ser tentador pular os exercícios, não há melhor maneira de aprender do que praticar em problemas reais. O que você não vai aprender Base teorica pra tras os conceitos e calculos. O foco é sobre a aplicação, e isso não preciso avanços teoricas. Incluimos referencias para que é possivel obter maior detalhes sobre os conceitos e teorias ecologicos e caluclos usados na Ecologia da Paisagem. Prerequisites Fizemos algumas suposições sobre o que você já sabe para aproveitar ao máximo este livro. Você deve ser geralmente alfabetizado numericamente, e com conhecimento previsa de ecologia, geoprocessamento e uso de sistemas de informação geografica. Você precisa de quatro coisas para executar o código deste livro: R, RStudio, uma coleção de pacotes R chamada tidyverse e um punhado de outros pacotes. Os pacotes são as unidades fundamentais do código R reproduzível. Eles incluem funções reutilizáveis, documentação que descreve como usá-los e dados de amostra. R Para fazer o download do R, acesse CRAN, a comprehensive R archive nnetwork, https://cloud.r-project.org. Uma nova versão principal do R é lançada uma vez por ano e há 2 a 3 versões secundárias a cada ano. É uma boa ideia atualizar regularmente. A atualização pode ser um pouco complicada, especialmente para as versões principais que exigem a reinstalação de todos os seus pacotes, mas adiar só piora as coisas. Recomendamos R 4.2.0 ou posterior para este livro. RStudio RStudio é um ambiente de desenvolvimento integrado, ou IDE, para programação R, que você pode baixar em https://posit.co/download/rstudio-desktop/. O RStudio é atualizado algumas vezes por ano e avisa automaticamente quando uma nova versão é lançada, para que não haja necessidade de verificar novamente. É uma boa ideia atualizar regularmente para aproveitar os melhores e mais recentes recursos. Para este livro, certifique-se de ter pelo menos o RStudio 2022.02.0. O universo arrumado - tidyverse Você também precisará instalar alguns pacotes do R. Um pacote do R é uma coleção de funções, dados e documentação que estende os recursos do R base. O uso de pacotes é a chave para o uso bem-sucedido do R. A maioria dos pacotes que você aprenderá neste livro faz parte do chamado tidyverse. Todos os pacotes no tidyverse compartilham uma filosofia comum de programação de dados e R e são projetados para trabalhar juntos. Você pode instalar o tidyverse completo com uma única linha de código: install.packages(&quot;tidyverse&quot;) No seu computador, digite essa linha de código no console e pressione enter para executá-lo. R irá baixar os pacotes do CRAN e instalá-los em seu computador. Você não poderá usar as funções, objetos ou arquivos de ajuda em um pacote até carregá-lo com library(). Depois de instalar um pacote, você pode carregá-lo usando a função library(): library(tidyverse) Isso diz a você que o tidyverse carrega nove pacotes: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, alignr. Eles são considerados o núcleo do tidyverse porque você os usará em quase todas as análises. Os pacotes no tidyverse mudam com bastante frequência. Você pode ver se há atualizações disponíveis executando tidyverse_update(). Outros pacotes Existem muitos outros pacotes excelentes que não fazem parte do tidyverse porque resolvem problemas em um domínio diferente ou são projetados com um conjunto diferente de princípios subjacentes. Isso não os torna melhores ou piores, apenas diferentes. Em outras palavras, o complemento do tidyverse não é o universo bagunçado, mas muitos outros universos de pacotes inter-relacionados. Ao lidar com mais projetos de Ecologia da Paisagem com R, você aprenderá novos pacotes e novas formas de pensar sobre os dados. Usaremos outras pacotes de fora do tidyverse neste livro. Por exemplo, usaremos os seguintes pacotes porque eles fornecem conjuntos de funcões e dados interessantes para trabalharmos no processo de aprendizado de R: install.packages(c(&quot;sp&quot;, &quot;sf&quot;,&quot;raster&quot;, &quot;mapview&quot;,&quot;tmap&quot;, &quot;terra&quot;, &quot;kableExtra&quot;, &quot;landscapemetrics&quot;)) 0.1 Codigo no livro Objetivo não é de apresentar detalhes sobre os cálculos/métodos estatísticas ou os funções no R. Existem diversos exemplos disponíveis “Ciência de Dados com R–Introdução……”: e com google “r cran introdução tutorial”……. Alem disso, existem grupos de ajuda, como por exemplo: R Brasil e Stack Overflow em Português O objetivo é de apresentar um livro mostrado os capacidades e opções para desenvolver e integrar pesquisas na ecologia da paisagem no ambiente estatística de R Obviamente, todas as tarefas de geoprocessamento podem ser desenvolvidas anteriormente em um SIG (QGIS). Então porque use R? R tem a capacidade (baseada em codigo) para alternar entre tarefas de processamento, modelagem e visualização de dados geográficos e não geográficos. Alem disso, como é possível importar, modificar, analisar e visualizar dados espaciais no mesmo ambiente com script/codigo, o R permite fluxos de trabalho transparentes e reproduzíveis (A Ciência Aberta). Aliás, atualmente a grande maioria dos artigos científicos publicados na revista Landscape Ecology incluir análises usando R. 0.1.1 Organização do codigo no livro O capitulo está organizado em etapas de processamento, com blocos de código em caixas cinzas: codigo de R para executar Para segue os passos, os blocos de código precisam ser executados em sequência. Se você pular uma etapa, ou rodar fora de sequência o próximo bloco de código provavelmente não funcionará. As linhas de codigo de R dentro de cada caixa tambem preciso ser executados em sequência. O simbolo # é usado para incluir comentarios sobre os passos no codgio (ou seja, linhas começando com # não é codigo de executar). # Passo 1 codigo de R passo 1 # texto e numeros tem cores diferentes # Passo 2 codigo de R passo 2 # Passo 3 codigo de R passo 3 Alem disso, os simbolos #&gt; e/ou [1] no início de uma linha indica o resultado que você verá no console de R. # Passo 1 1+1 [1] 2 # Passo 2 x &lt;- 1 + 1 # Passo 3 x [1] 2 # Passo 4 x + 1 [1] 3 "],["escala.html", "Capítulo 1 Escala 1.1 Apresentação 1.2 Escala: breve definação 1.3 Pacotes e dados 1.4 Alterando a resolução 1.5 Escala espacial e desenho amostral 1.6 Comparação multiescala 1.7 Próximos passos: repetindo para muitas amostras.", " Capítulo 1 Escala 1.1 Apresentação Nesta capitulo vamos entender a importância de escala na ecologia da paisagem através cálculos com a proporção de floresta. Durante o capitulo você aprenderá a Alterar escala (resolução e extensão espacial), Calcular a área de uma classe de habitat, Desenvolve uma comparação multiescala. É muito importante ficar claro para você o que é escala (e o que não é!), e qual a importância desse conceito na elaboração do desenho amostral, na coleta de dados, nas análises e na tomada de decisão. Nesse tutorial usaremos conteudo baseado no Capítulo 2 do livro Spatial Ecology and Conservation Modeling (Fletcher and Fortin 2018) e “Tutorial Escala” do Dr. Alexandre Martensen. 1.2 Escala: breve definação Todos os processos e padrões ecológicos têm uma dimensão temporal e espacial. Assim sendo, o conceito de escala não somente representar essas dimensões, mas também, ajudar nos apresentá-los de uma forma que facilite o entendimento sobre os processos e padrões sendo estudados. Na ecologia o termo escala refere-se à dimensão ou domínio espaço-temporal de um processo ou padrão. Na ecologia da paisagem, a escala é frequentemente descrita por sua componentes: resolução e extensão. Resolução: menor unidade espacial de medida para um padrão ou processo. Extensão: descreve o comprimento ou tamanho de área sob investigação. Resolução e extensão tendem a covariar – estudos com maior extensão tendem a ter resolução maiores também. Parte dessa covariância é prática: é difícil trabalhar em grandes extensões com dados coletados em tamanhos de resolução finos. No entanto, parte dessa covariância também é conceitual: muitas vezes em grandes extensões, podemos esperar que processos operando em resolução muito finos forneçam somente “ruído” e não dados/informações relevantes sobre os sistemas. Como os desafios computacionais diminuíram e a disponibilidade de dados de alta resolução aumentou, a covariância entre resolução e extensão nas investigações diminuiu. Lembrando, na primeira aula, vimos que a escala espacial pode ser interpretada com base em três dimensoes: no fenômeno de interesse; na amostragem que ocorre; e/ou na análise Para que a Ecologia da Paisagem gere evidências científicas robustas e úteis, a escala nas três dimensões deve ser consistente e apropriada para o estudo. Aqui nos concentramos na dimensão “análise”, e aprendemos como a escala espacial pode ser alterada e representada em modelos ecológicos. 1.3 Pacotes e dados Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Neste caso precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, sf, terra, mapview, tmap. 1.3.1 Pacotes No R, carregar os pacotes necessarios com o codigo: library(tidyverse) library(sf) library(terra) library(mapview) library(tmap) library(eprdados) Caso os pacotes não tenham sido instalados, o R vai avisar atraves um mensagem tipo: Error in library(nomepacote) there is no package called nomepacote. Neste caso, para instalá-los consulte o capitulos aqui Capitulo 4 instalação de pacotes e aqui Capitulo 4 pacotes . 1.3.2 Dados Vamos olhar um exemplo do mundo real. Uma pequena amostra do Rio Araguari, perto de Porto Grande. O ponto central é de longitude: -51.406312 latitude: 0.726236. Para visualizar o ponto no Google Earth: https://earthengine.google.com/timelapse#v=0.72154,-51.41543,11.8,latLng&amp;t=2.24&amp;ps=25&amp;bt=19840101&amp;et=20201231&amp;startDwell=0&amp;endDwell=0 . Vammos trabalhar com os dados de MapBiomas, que produz mapeamento anual da cobertura e uso da terra no Brasil desde 1985. Os dados de MapBiomas vem no formato de raster, que tem uma classificação da terra feito a partir da classificação pixel a pixel de imagens das satélites Landsat. Todo processo é feito com algoritmos de aprendizagem de máquina (machine learning) através da plataforma Google Earth Engine, que oferece imensa capacidade de processamento na nuvem. Mais detalhes sobre a metodologia aqui: Metodologia MapBiomas. Para carregar um arquivo raster trabalhamos com o pacote terra. O pacote tem varios funçoes para a análise e modelagem de dados geográficos. Nós podemos ler os dados de cobertura da terra no arquivo “.tif” com a função rast. # arquivo no pacote &quot;eprdados&quot; arquivo &lt;- system.file(&quot;raster/amostra_mapbiomas_2020.tif&quot;, package = &quot;eprdados&quot;) # carregar ramostra &lt;- rast(arquivo) Plotar para verificar. plot(ramostra) Figura 1.1: Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. Podemos também verificar informações sobre o raster (metadados) - simplesmente rodar o nome do objeto: ramostra ## class : SpatRaster ## dimensions : 8, 9, 1 (nrow, ncol, nlyr) ## resolution : 29.89281, 29.89281 (x, y) ## extent : 454659.8, 454928.9, 80160.06, 80399.2 (xmin, xmax, ymin, ymax) ## coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) ## source : amostra_mapbiomas_2020.tif ## name : mapbiomas_2020 ## min value : 3 ## max value : 33 Isso nos mostra informações sobre escala espacial (resolução e extensão) e a sistema de coordenadas (SIRGAS 2000 / UTM zone 22N , EPSG:31976). Além disso é possível obter informações específicas através de funções específicas. # Obter informações sobre escala espacial # resolução, comprimento e largura do pixel em metros res(ramostra) # numero de colunas ncol(ramostra) # numero de linhas nrow(ramostra) 1.3.2.1 Pergunta 1 Sobre o objeto ramostra. Com base nos resultados obtidos, qual o área do pixel em metros quadrados? Qual o área total da paisagem em hectares e quilometros quadrados? Olhando a mapa (Figura 1.1), existem três classes com valores de 3, 12 e 33. O objetivo principal não é de fazer mapas, mas, a visualização dos dados é um passo importante para verificar e entender os padrões. Portanto, segue exemplo mostrando uma forma de visualizar o arquivo de raster como mapa. Para entender o que os valores (3, 12, 33) representam no mundo real precisamos de uma referência (legenda). Para a MapBiomas Coleção 6, arquivo: Cod_Class_legenda_Col6_MapBiomas_BR.pdf. Existe também arquivos para fazer as mapas com cores corretas em QGIS ou ArcGIS. Olhando a legenda (Cod_Class_legenda_Col6_MapBiomas_BR.pdf), sabemos que “3”, “12” e “33” representem cobertura de “Formação Florestal”, “Formação Campestre”, e “Rio, Lago e Oceano”. Então podemos fazer um mapa mostrando tais informações. Daqui pra frente vamos aproveitar uma forma mais elegante de apresentar mapas e gráficos. Isso seria atraves funçoes em 2 pacotes: tmap é utilizado para gerar mapas temáticos ggplot2, que faz parte do “tidyverse”, e é utilizado para produção de gráficos, e pode representar dados geoespacias. Exemplos : Pacotes ggplot2 e tmap Mais exemplos sobre o uso de ggplot2 no R cookbook : http://www.cookbook-r.com/Graphs/ . E com mais exemplos de mapas e dados espaciais no R: sf e ggplot2 : https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html Capitulo 9 no livro Geocomputation with R : https://geocompr.robinlovelace.net/adv-map.html Primeiramente precisamos incluir as informações relevantes da legenda. Ou seja, incluir os nomes para cada valor de classe. # legenda e cores na sequencia correta classe_valor &lt;- c(3, 12, 33) classe_legenda &lt;- c(&quot;Formação Florestal&quot;, &quot;Formação Campestre&quot;, &quot;Rio, Lago e Oceano&quot;) classe_cores &lt;- c(&quot;#006400&quot;, &quot;#B8AF4F&quot;, &quot;#0000FF&quot;) Agora podemos fazer o mapa com as classes e os cores seguindo o padrão recomendado pela MapBiomas para Coleção 6. tm_shape(ramostra) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;3&quot; = &quot;#006400&quot;, &quot;12&quot; =&quot;#B8AF4F&quot;, &quot;33&quot;= &quot;#0000FF&quot;), legend.show = FALSE) + tm_grid(labels.format = list(big.mark = &quot;&quot;)) + tm_add_legend(type = &quot;fill&quot;, labels = classe_legenda, col = classe_cores, title = &quot;Classe&quot;) + tm_compass(position = c(&quot;right&quot;, &quot;bottom&quot;)) + tm_scale_bar(breaks = c(0, 0.05, 0.1), text.size = 1, text.color = &quot;white&quot;, position=c(&quot;right&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;),legend.bg.color = &quot;white&quot;) Figura 1.2: Paisagem com valores e classes de cobertura da terra. Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. 1.4 Alterando a resolução Alterando a resolução serve como exemplo mostrando como os passos/etapas/cálculos mude dependendo o tipo de dados. Ou seja, é preciso adotar metodologias diferentes para dados categóricos (por exemplo classificação de cobertura da terra) e dados contínuos (por exemplo distância até rio). Alterando a resolução às vezes seria necessário, por exemplo, quando preciso padronizar dados/imagens oriundos de fontes diferentes com resoluções diferentes e/ou para reduzir a complexidade da modelagem. Lembrando - em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Agora iremos degradar a resolução desses dados, ou seja, iremos alterar o tamanho dos pixels. Como exemplo, iremos juntar (agregar) 3 pixels em um único pixel. Como você acha que podemos fazer isso? Quais valores esse pixel que vai substituir os 3 originais deve ter? Existem diversas maneiras de se fazer isso, como por exemplo através a média ou valor modal (valor mais comum). O valor mais comum da área, é particularmente adequado quando temos um mapa categórico, como por exemplo a classificação do MapBiomas. Segue exemplo de codigo para agregar com a média e o valor mais frequente (modal). # Média ramostra_media &lt;- aggregate(ramostra, fact=3, fun=&quot;mean&quot;) ramostra_media &lt;- resample(ramostra, ramostra_media) # Modal ramostra_modal &lt;- aggregate(ramostra, fact=3, fun=&quot;modal&quot;) ramostra_modal &lt;- resample(ramostra, ramostra_modal, method=&quot;near&quot;) 1.4.0.1 Pergunta 2 Utilizando as funções disponíveis no pacote tmap, crie mapas temáticos dos objetos ramostra_media e ramostra_modal. Inclua cópias do seu código e mapas na sua resposta. Você pode usar o printscreen para mostrar o RStudio com seu código e mapas. Visualizar os resultados apresentados em Figura 1.4. Os valores calculados pela média não fazem sentido para uma classificação categórica. Os valores calculados pela modal são consistentes com o original e fazem sentido. Em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Aqui por exemplo, mudamos a proporção de cobertura florestal em nossa pequeno paisagem quando juntamos 3 pixels em um único: a proporção de floresta moudou de 4% (3/72) para 11% (1/9). Ou seja, com cada passo mudamos a representção do mundo. Figura 1.3: Mudanças causadas pela agregação. 1.4.0.2 Pergunta 3 Confira o codigo e os resultados obtidos anteriormente, quando mudamos a resolução da ratser ramostra (por exemplo figura 1.4). Explique o que aconteceu. Como e porque moudou os valores em cada caso (média e modal)? 1.5 Escala espacial e desenho amostral Figura 1.4: A cobertura florestal ao redor de um ponto de amostragem pode variar em escalas diferentes. Para entender essas variações, podemos criar buffers circulares de diferentes extensões ao redor dos pontos de amostragem. Esses buffers representam áreas de diferentes tamanhos ao redor de cada ponto. Quantificando a quantidade de floresta que ocorre em cada buffer, podemos obter uma visão geral da escala em que a cobertura florestal muda ao redor dos pontos de amostragem. Por exemplo, podemos descobrir que a cobertura florestal é mais alta dentro de um buffer de 5 km do que em um buffer de 10 km. Dado o papel que a escala pode desempenhar em nossa compreensão dos padrões e processos ecológicos, como escala deve ser considerada no desenho do estudo? Claramente, a resposta a esta pergunta irá variar dependendo dos fenômenos de interesse, mas ecologistas e estatísticos têm forneceu algumas orientações importantes. As questões-chave incluem o tamanho da unidade de amostragem (resoloção), o tipo de unidade de amostra e localizações da unidade de amostra, incluindo o espacamento entre as amostras (distância entre as amostras) e o tamanho da área de estudo. Com a disponibilidade de imagens de satélite é possível responder questões importantes relacionadas ao desenho do estudo antes de qualquer trabalho de campo. Uma tecnica de geoprocessamento (bordas - Buffers) é um dos mais frequentemente adotados para quantificar escala espacial na ecologia da paisagem. O objetivo é criar buffers circulares de diferentes extensões ao redor dos sitios de amostragem (pontos, pixels, manchas, transetos lineares etc). Aqui, vamos entender a escala em que a cobertura de floresta muda ao redor dos rios. Para isso, quantificamos a quantidade de floresta que ocorre em várias distâncias em pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Para ilustrar esta abordagem geral, usamos o banco de dados MapBiomas Coleção 6 de 2020, e vincule esses dados de cobertura da terra aos pontos de amostragem em rios. 1.5.1 Obter e carregar dados (vectores) Antes de quantificar a quantidade de floresta, precisamos carregar os dados de rios e pontos de amostragem. O formato de vector é diferente de “tif” (raster), portanto o processo de importação é diferente. Aqui, nós só precisamos de duas dessas camadas, ambos do pacote ‘eprdados’: “rio_linhacentral” e “rio_pontos”. A primeira camada de dados contém o eixo central de 260 km de rios a montante da Barragem Cachoeira Caldeirão. Os dados foram obtidos a partir de registros de trajetória GPS durante levantamentos de barco. Os rios foram divididos em 52 seções, cada uma com aproximadamente 5 km de extensão. A segunda camada de dados, “rio_pontos”, contém 52 pontos espaçados regularmente ao longo dos rios. Cada ponto está localizado a aproximadamente 5 km de distância do ponto anterior. 1.5.2 Visualizar os arquivos (camadas vector) Visualizar para verificar. Mapa com ambos a linha central e pontos de rios em trechos de 5km. ggplot(rio_linhacentral) + geom_sf(aes(color=rio)) + geom_sf(data = rio_pontos, shape=21, aes(fill=zone)) Figura 1.5: Pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Mapa interativo (funcione somente com internet) Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc) # mapview(rio_linhacentral, zcol = &quot;rio&quot;) 1.5.3 Obter e carregar dados (raster) Mais uma vez vamos aproveitar os dados de MapBiomas. Agora um arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 1.3 MB).O código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”: meuSIGr &lt;- system.file(&quot;raster/utm_cover_AP_rio_2020.tif&quot;, package = &quot;eprdados&quot;) # carregar mapbiomas_2020 &lt;- rast(meuSIGr) 1.5.4 Visualizar os arquivos (camadas raster e vector) Visualizar para verificar. É possível de visualizar varios camadas de raster e vetor juntos com funcões no pacote tmap (https://r-tmap.github.io/tmap-book/index.html). # Passo necessario para agilizar o processamento mapbiomas_2020_modal &lt;- aggregate(mapbiomas_2020, fact = 10, fun = &quot;modal&quot;) # Plot tm_shape(mapbiomas_2020_modal) + tm_raster(title = &quot;Classe&quot;, style = &quot;cat&quot;, palette = &quot;Set3&quot;) + tm_shape(rio_linhacentral) + tm_lines(col=&quot;blue&quot;) + tm_shape(rio_pontos) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_compass(position=c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;), legend.bg.color=&quot;white&quot;) Figura 1.6: Cobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. 1.5.5 Reclassificação Para simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente). # criar uma nova camada de floresta floresta_2020 &lt;- mapbiomas_2020 # Com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar categorias florestais agrupados com valor de 1 floresta_2020[mapbiomas_2020 == 3 | mapbiomas_2020 == 4] &lt;- 1 Vizualizar para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal &lt;- aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_shape(rio_linhacentral) + tm_lines(col=&quot;blue&quot;) + tm_shape(rio_pontos) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, text.color = &quot;white&quot;, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;),legend.bg.color = &quot;white&quot;) Figura 1.7: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. 1.6 Comparação multiescala Em seguida, com as coordenadas dos pontos de amostragem, podemos calcular a quantidade de floresta que circunda cada local de amostragem em diferentes extensões. Primeiramente, vamos fazer so para um ponto, assim para entender o processo e os passos melhor. rio_pontos_31976 &lt;- st_transform(rio_pontos, 31976) # Buffer rio_pontos_31976_b1000 &lt;- st_buffer(rio_pontos_31976[1, ], dist = 1000) # Recorte com buffer de 1000 metros (mudando a extensão). buffer.forest1.1km &lt;- crop(floresta_2020, snap=&quot;out&quot;, rio_pontos_31976_b1000) # Máscara para que os pixels fora do polígono sejam nulos. buffer.forest1.1km &lt;- mask(buffer.forest1.1km, rio_pontos_31976_b1000, touches=TRUE) names(buffer.forest1.1km) &lt;- &quot;forest_2020_1km&quot; Vizualizar para verificar. # Plot tm_shape(buffer.forest1.1km) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_shape(rio_pontos_31976[1, ]) + tm_symbols(shape =21, col = &quot;yellow&quot;, border.col = &quot;black&quot;, border.lwd = 0.2, size=0.5) + tm_shape(rio_pontos_31976_b1000) + tm_borders(col = &quot;black&quot;, lwd = 4, lty = &quot;dashed&quot;) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_compass(position=c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 0.5, 1), text.size = 1, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;), legend.bg.color = &quot;white&quot;) Figura 1.8: Ilustração da determinação da quantidade de habitat ao redor de um ponto. Para um determinada extensão, o habitat de interesse é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e o número de células (pixels) que contém o habitat é somado e multiplicado pela área de cada pixel. 1.6.1 Pergunta 4 Qual é a extensão em número de pixels desse recorte (buffer.forest1.1km)? Temos valores de 0 (não-floresta) e 1 (floresta). Então, para saber a aréa de floresta podemos somar o número de células (pixels) que contém o habitat e multiplica pela área de cada pixel conforme o codigo: # 1) Somatório. # No caso igual o numero de pixels de floresta. # Para todo a paisagem, somatorio &quot;global&quot;. # Não deve incluir pixels nulos, então use &quot;na.rm = TRUE&quot;. soma_floresta &lt;- global(buffer.forest1.1km, &quot;sum&quot;, na.rm = TRUE) soma_floresta ## sum ## forest_2020_1km 939 # 2) Área de cada pixel. # Sabemos o sistema de coordenadas (EPSG = 31976). # EPSG 31976 é uma sistema projetado com unidade em metros. buffer.forest1.1km ## class : SpatRaster ## dimensions : 68, 68, 1 (nrow, ncol, nlyr) ## resolution : 29.89281, 29.89281 (x, y) ## extent : 465959.3, 467992, 90921.47, 92954.18 (xmin, xmax, ymin, ymax) ## coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) ## source(s) : memory ## varname : utm_cover_AP_rio_2020 ## name : forest_2020_1km ## min value : 0 ## max value : 1 # Portanto, o tamanho de cada pixel é igual. area_pixel_m2 &lt;- 29.89281 * 29.89281 area_pixel_m2 ## [1] 893.5801 # 3) Calculos de aréa. # Aréa de floresta m2 area_floresta_m2 &lt;- soma_floresta * area_pixel_m2 area_floresta_m2 ## sum ## forest_2020_1km 839071.7 # Aréa de floresta hectares area_floresta_ha &lt;- area_floresta_m2 / 10000 area_floresta_ha ## sum ## forest_2020_1km 83.90717 Para uma comparação multiescala, vamos repetir o mesmo processo, mas agora com distancias de 250, 500, 1000, 2000 e 4000 metros, doubrando a escala (extensão) em cada passo. Figura 1.9: Cobertura florestal em extensões diferentes ao redor de um local de amostragem. Aspectos quantitativos das paisagens mudam fundamentalmente com a escala. Por exemplo, nesse caso, parece que a proporção de floresta aumenta à medida que a extensão aumenta de 500 para 4000 metros. Esta percepção visual é confirmada pelos valores calculados, onde as áreas são: raio 250 m = 0 hectares de floresta raio 500 m = 6,3 hectares de floresta raio 1000 m = 84,3 hectares de floresta raio 2000 m = 502.6 hectares de floresta raio 4000 m = 3351.0 hectares de floresta 1.6.2 Pergunta 5 Usando os valores listadas acima de raio e área de floresta para os diferentes buffers circulares, calcule a proporção de floresta em cada uma das diferentes extensões de buffer. Apresente 1) os resultados incluindo cálculos. 2) um gráfico com valores de extensão no eixo x e proporção da floresta no eixo y. 3) Em menos de 200 palavras apresente a sua interpretação do gráfico. 1.6.3 Pergunta 6 A modelagem multiescala quantifica as condições do ambiente em múltiplas escalas alterando o resolução ou a extensão da análise e, em seguida, avaliando qual das escalas consideradas explica melhor um padrão ou processo. Escolha 1 espécie aquático e 1 espécie terrestre que ocorram na região a montante das hidrelétricas no Rio Araguari. Com base nas diferenças entre extensões (indicados no exemplo anterior) e as características funcionais das espécies (por exemplo área de vida), escolher as extensões mais adequadas para um estudo multiescala de cada espécie. 1.7 Próximos passos: repetindo para muitas amostras. Neste exemplo comparamos a área de floresta em torno de um único ponto de amostragem. Para calcular o mesmo para todos os 52 pontos, seriam necessárias varias repetições (52 pontos x 5 extensões = 260 repetições). Poderíamos escrever código para executar esse processo automaticamente. Felizmente, alguém já escreveu funções para fazer isso e muito mais. O próximo tutorial sobre métricas de paisagem mostrará exemplos usando o pacote “landscapemetrics” (https://r-spatialecology.github.io/landscapemetrics/). "],["métricas-da-paisagem.html", "Capítulo 2 Métricas da paisagem 2.1 Apresentação 2.2 Métricas da paisagem e pacote “landscapemetrics” 2.3 Dados 2.4 Calculo de métricas", " Capítulo 2 Métricas da paisagem 2.1 Apresentação As métricas da paisagem nos ajudam a entender as mudanças na paisagem de diferentes perspectivas (visual, ecológica, cultural). Asssim sendo, análises com métricas de paisagem é um atividade fundamental na ecologia da paisagem. Nesta capitulo aprenderemos sobre como analisar a cobertura da terra com métricas de paisagem em R. As tecnicas será ilustrada através cálculos usando a cobertura florestal ao redor do Rio Araguari. Ao longo do caminho, revisaremos modelos lineares e não lineares, aprenderemos sobre manipulação de dados em R e aprenderemos como criar gráficos com o pacote ggplot2. No capitulo você aprenderá a: Importar e plotar dados raster em R e mapear locais de amostragem com os pacotes terra, sf e tmap. Calcular métricas de paisagem com o pacote landscapemetrics. Calcular métricas de paisagem em locais de amostragem e dentro de um buffer ao redor deles (comparação multiescala). Construir gráficos com o pacote ggplot2. Comparação de padrões lineares e não-lineares. 2.2 Métricas da paisagem e pacote “landscapemetrics” As métricas de paisagem são a forma que os ecólogos de paisagem usam para descrever os padrões espaciais de paisagens para depois avaliar a influência destes padrões espaciais nos padrões e processos ecológicos. A paisagem objeto de análise é definida pelo usuário e pode representar qualquer fenômeno espacial. As métricas simplesmente quantifica a heterogeneidade espacial da paisagem representada no mapa categórico; cabe ao usuário estabelecer uma base sólida para definir e dimensionar a paisagem em termos de conteúdo temático e resolução e extensão espacial. É importante ressaltar que o resultado das métricas só é relevante se a paisagem definida for adequado em relação ao fenômeno em consideração. landscapemetrics tem funções para calcular métricas de paisagem em paisagems categóricos (onde tem uma classificação de cobertura de terra/habitat - modelo mancha-corredor-matriz), em um fluxo de trabalho organizado. O pacote pode ser usado como um substituto do FRAGSTATS (McGarigal et al. 1995, https://doi.org/10.2737/PNW-GTR-351), pois oferece um fluxo de trabalho reproduzível para análise de paisagem em um único ambiente. Pode tambem obter FRAGSTATS aqui: https://fragstats.org/ . landscapemetrics também permite cálculos de quatro métricas teóricas de complexidade da paisagem: entropia marginal, entropia condicional, entropia conjunta e informação mútua (Nowosad e Stepinski 2019 https://doi.org/10.1007/s10980-019-00830-x). 2.2.1 Pacotes Além do “landscapemetrics”, precisamos carregar alguns pacotes a mais para facilitar a organização e apresentação de dados espaciais (vector e raster) e os resultados. Carregar pacotes (que deve esta instalado antes): library(tidyverse) library(sf) library(raster) library(terra) library(tmap) library(gridExtra) library(kableExtra) library(mgcv) library(eprdados) 2.2.1.1 landscapemetrics Agora, vamos para o pacote principal landscapemetrics. Digite o código abaixo e veja o resultado. Leia com atenção e preste particular atenção na organização da página de ajuda. library(landscapemetrics) # Olhar a pagina de ajuda ?landscapemetrics No final da página você vai encontrar a palavra “Index”. Clique nela e você verá todas as funções do pacote. Desca até as lsm_. . . e clique em algumas delas ali. Explorar! Para listar todas as métricas disponíveis, você pode usar a função list_lsm() . A função também permite mostrar métricas filtradas por nível, tipo ou nome da métrica. Para obter mais informações sobre as métricas, consulte os arquivos de ajuda correspondentes ou https://r-spatialecology.github.io/landscapemetrics. Digite o código abaixo e veja o resultados, mostrando exemplos das métricas diferentes disponíveis no pacote. # métricas de agregação, nível de fragmento landscapemetrics::list_lsm(level = &quot;patch&quot;, type = &quot;aggregation metric&quot;) # métricas de agregação, nível de classe landscapemetrics::list_lsm(level = &quot;class&quot;, type = &quot;aggregation metric&quot;) # landscapemetrics::list_lsm(metric = &quot;area&quot;) # ajudar com opções da função ?landscapemetrics::list_lsm Nesse pacote o formato geral para uma função é em trés partes “lsm_nível_métrica”. A primeira parte é sempre lsm_ (“landscapemetric”), seguinda do “nível_” e por fim a “métrica”: Ou seja, todas as funções que calculam métricas começam com lsm_ ……. Daí você deve incluir o nível da análise: “p”, “c” ou “l”. Sendo, “p” para patch (ou seja, para a mancha/fragmento), “c” para classe e “l” para landscape ou seja, métricas para a paisagem como um todo. E daí existem inúmeras métricas. Como por exemplo a cpland, que é o percentual de área central - “core area” na paisagem, como vimos na aula teórica. Assim sendo, a função lsm_c_cpland vai calacular a métrica porcentagem da área central em cada classe. Lembrando existem metricas que podem se calculados nos trés niveis, e metricas que so pode se calculados somente para um nivel espcifco. Ja sabendo o nome da função, podemos buscar ajudar para entender mais detalhes. Digite o código abaixo e veja o resultado, mostrando um exemplo para uma métrica. # ajudar com opções para uma função especifica ?landscapemetrics::lsm_c_cpland 2.2.1.2 Pergunta 1 Descreva brevemente 2 métricas de cada nível (patch, class, landscape) usando ajudar (usando ? e/ou list_lsm) e/ou a leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises). Incluindo na descrição - o nome, porque serve, unidades de medida, e relevância ecológica. 2.3 Dados Vamos continuar as analises que começo no capítulo “Escala”, trabalhando com os mesmos bancos de dados. Então, primeiramente carregar os dados de cobertura da terra com a função rast. E, em seguida implementar uma reclassificação para gerar uma camada binaria de floresta (valor de “1”) e não-floresta (valor de “0”). # Carregar mapbiomas_2020 &lt;- rast(utm_cover_AP_rio_2020) # Reclassificação - # Criar uma nova camada de floresta (novo objeto de raster copiando mapbiomas_2020, # assim para ter os mesmos coordenados, resolução e extensão) floresta_2020 &lt;- mapbiomas_2020 # Todos os pixels com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar com valor de 1 quando pixels originais são de floresta (classe 3 e 4) floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 Plotar para verificar, incluindo nomes e os cores para classes de floresta (valor = 1) e não-floresta (valor = 0). # Passo necessario para agilizar o processamento floresta_2020_modal &lt;- aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_layout(legend.bg.color = &quot;white&quot;) Se esta todo certo, voces devem ter uma imagem assim: Figura 2.1: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. 2.3.1 Exibir dados raster e sobreposição com locais de amostragem Agora temos a paisagem, precisamos tambem os pontos de amostra. Por isso, precisamos carregar os dados de rios e pontos de amostragem que usamos no tutorial Escala. Vamos carregar as camadas, e no mesmo tempo implementar uma reprojeção, assim para que as sistemas de coordenados ficam iguais para todas as camadas - tanto de vector quanto raster. No codigo abaixo, usamos |&gt;, que estabelece a ligação entre os passos do processo. Ou seja, |&gt; passa o objeto anterior automaticamente para a próxima função como primeiro argumento. Primeiro, carregamos os dados. Em seguida, usamos a função st_transform para converter as coordenadas para o mesmo sistema de referência do arquivo raster. As duas etapas ficam ligados através a função |&gt;. # pontos cada 5 km rio_pontos_31976 &lt;- rio_pontos |&gt; st_transform(31976) # linha central de rios rio_linhacentral_31976 &lt;- rio_linhacentral |&gt; st_transform(31976) Visualizer para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal &lt;- aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Mapa tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_shape(rio_linhacentral_31976) + tm_lines(col=&quot;blue&quot;) + tm_shape(rio_pontos_31976) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_layout(legend.bg.color=&quot;white&quot;) Depois de executar (“run”) o código acima, você deverá ver a figura a seguir. Figura 2.2: Cobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio (linha azul). 2.4 Calculo de métricas Agora com todos as camadas organizados e verifcados podemos calcular as métricas de paisagem. Para ilustrar como rodar as funções e cálculos com landscapemetrics, vamos calcular o percentual de área central na paisagem ( cpland). Vamos estudar uma classe (floresta), portanto vamos incluir as métricas para nível de classe. No geral, as métricas de paisagem em nível de classe são mais eficazes na definição de processos ecológicos (Tischendorf, L. Can landscape indices predict ecological processes consistently?. Landscape Ecology 16, 235–254 (2001). https://doi.org/10.1023/A:1011112719782.). Para calcular as métricas de paisagem dentro de um certo buffer em torno de pontos de amostra, existe a função sample_lsm(). Através da função sample_lsm() podemos calcular mais de 50 métricas da paisagem, dentro de buffers (raios/distancias) diferentes. 2.4.1 Ponto único, raio único, métrica única Métricas de área central (“core area”) são consideradas medidas da qualidade de hábitat, uma vez que indica quanto existe realmente de área efetiva de um fragmento/classe, após descontar-se o efeito de borda. Vamos calcular a percentual de área central (“core area”) no entorno de um ponto de amostragem. Isso seria, a percentual de áreas centrais (excluídas as bordas de 30 m) de cada classe em relação à área total da paisagem. Para a função sample_lsm() funcionar, precisamos informar (i) a paisagem (arquivo de raster), (ii) ponto (arquivo vector), (iii) raio do buffer desejada, (iv) forma do buffer (círculo ou quadrado) e por final (v) a métrica desejada. Cada opção tem especificações particulares, assim para que a função pode receber dados em formatos diferentes e produzir resultados conforme as necessidades de diversos casos. Para este primeiro exemplo trabalharemos com apenas um ponto. Fazemos isso selecionando a primeira linha (primeiro ponto) do objeto com os 52 pontos de amostragem (“rio_pontos_31976”) usando colchetes: [1, ] . # com a paisagem &quot;floresta_2020&quot;, # fazer uma amostragem de um ponto &quot;rio_pontos_31976[1, ]&quot; # dentro de uma buffer com raio de 1000 metros e forma circular # e calcular a métrica &quot;cpland&quot; minha_amostra_1000 &lt;- sample_lsm(landscape = floresta_2020, y = rio_pontos_31976[1, ], size = 1000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;, edge_depth = 1) Depois que executar (“run”), podemos olhar os dados com o codigo a seguir. Rodando o nome do obejto, como no proximo bloco de codigo podemos verifcar os resultados. minha_amostra_1000 Os dados deve ter os valores (coluna “value”) da métrica (coluna “metric”) de cada classe (coluna “class”) conforme a proxima tabela: layer level class id metric value plot_id percentage_inside 1 class 0 NA cpland 66.95102 1 103.4332 1 class 1 NA cpland 19.59274 1 103.4332 2.4.1.1 Pergunta 2 O modelo mancha-corredor-matriz é frequentemente adotado na ecologia da paisagem. Com base nas aulas teóricas e usando os valores no objeto minha_amostra_1000 apresentados na tabela acima, identificar qual classe representar a matriz na paisagem. Há alguma informação faltando que limita a sua capacidade de identificar qual classe representar a matriz? Se sim, o que precisa ser adicionado? Justifique as suas respostas de forma clara e concisa. 2.4.2 Ponto único, distâncias variados, métrica única Figura 2.3: Cobertura florestal em extensões diferentes ao redor de um ponto de amostragem. Para uma comparação multiescala, vamos calcular a mesma métrica, no mesmo ponto, mas agora com extensões diferentes. Continuando o exemplo no tutorial anteriio (Escala), vamos repetir o mesmo processo, mas agora com raios de 250, 500, 1000, 2000, 4000, 8000 e 16000 metros, doubrando a escala (extensão) em cada passo. Para obter resultados com extensões diferentes, precisamos primeiramente repetir o código, ajustando para cada extensão, e depois juntar os resultados. O código a seguir calculará a mesma métrica para as diferentes distâncias. No exemplo, usamos |&gt;, que estabelece a ligação entre os passos do processo. Neste caso, para incluir uma coluna nova (“raio”) para manter o valor das diferentes distâncias. # raio 250 metros sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 250, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 250) -&gt; minha_amostra_250 # raio 500 metros sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 500, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 500) -&gt; minha_amostra_500 # raio 1 km (1000 metros) sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 1000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 1000) -&gt; minha_amostra_1000 # raio 2 km sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 2000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 2000) -&gt; minha_amostra_2000 # raio 4 km sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 4000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 4000) -&gt; minha_amostra_4000 # raio 8 km sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 8000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 8000) -&gt; minha_amostra_8000 # raio 16 km sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 16000, shape = &quot;circle&quot;, metric = &quot;cpland&quot;) |&gt; mutate(raio = 16000) -&gt; minha_amostra_16000 E agora, o código a seguir juntará os resultados das diferentes extensões. bind_rows(minha_amostra_250, minha_amostra_500, minha_amostra_1000, minha_amostra_2000, minha_amostra_4000, minha_amostra_8000, minha_amostra_16000) -&gt; amostras_metrica Depois que executar (“run”), podemos olhar os dados “amostras_metrica” com o codigo a seguir. amostras_metrica Os dados deve ter os valores (coluna value) da métrica (coluna metric) de cada classe (coluna class) para cada distância (coluna raio): layer level class id metric value plot_id percentage_inside raio 1 class 0 NA cpland 80.3 1 113 250 1 class 0 NA cpland 86.4 1 106 500 1 class 1 NA cpland 0.7 1 106 500 1 class 0 NA cpland 67.0 1 103 1000 1 class 1 NA cpland 19.6 1 103 1000 1 class 0 NA cpland 59.1 1 102 2000 1 class 1 NA cpland 27.9 1 102 2000 1 class 0 NA cpland 41.9 1 101 4000 1 class 1 NA cpland 44.2 1 101 4000 1 class 0 NA cpland 39.6 1 100 8000 1 class 1 NA cpland 48.5 1 100 8000 1 class 0 NA cpland 39.2 1 100 16000 1 class 1 NA cpland 50.7 1 100 16000 2.4.2.1 Faça um gráfico Uma imagem vale mais que mil palavras. Portanto, gráficos/figuras/imagens são uma das mais importantes formas de comunicar a ciência. Os dados apresentados em uma tabela podem ser difíceis de entender. Portanto, a primeira pergunta que você deve se fazer é se você pode transformar aquela tabela (chata e feia) em algum tipo de gráfico. Lembrando, sempre pode incluir a tabela como anexo. Aqui, vamos fazer um grafico com os dados amostras_metrica, usando o pacote ggplot2. O ggplot2 faz parte do conjunto de pacotes tidyverse, e é um pacote de visualização de dados. “gg” se refere a uma gramática de gráficos. A ideia principal é criar um gráfico como se fosse uma frase, onde cada elemento do gráfico seria uma palavra, organizados em uma sequencia logica para construir uma frase completo (gráfico final). Você fornece os dados, informa ao ggplot2 como mapear variáveis para estética, quais tipos/formatos gráficas usar e ele cuida dos detalhes. Isto nos permite construir gráficos tão complexos quanto quisermos. Os gráficos criados com ggplot2 são, em geral, mais elegantes do que os gráficos tradicionais do R. Para mais exemplos e tutoriais com mais detalhes veja os capitulos sobre ggplot2 nos livros: Ciência de Dados com R Análises Ecológicas no R No livro em ingles R Graphics Cookbook . E sempre pode buscar exemplos no Google, por exemplo digitando: ggplot2 grafico de barra no Google, tem mais de 50 mil resultados com paginas de imagens, codigo pronto e exemplos no YouTube. O ggplot2 exige que os dados a serem plotados estejam em um “dataframe” (tabela de dados). Ou seja, sempre teremos que transformar os dados para dataframe ou construir um dataframe com os dados que possuímos. Dataframe é um formato comum e fácil de trabalhar. Por exemplo, se você importar uma planilha de dados, o resultado seria como dataframe (para mais detalhes veja Estrutura e manipulação de objetos e lendo dados ). Além disso, o resultado dos funções de landscapemetrics é sempre um dataframe, ou seja os resultados da função sample_lsm() são prontos para um grafico. O principal função a ser utilizado é ggplot(). Para ggplot, precisamos os dados (dataframe), e depois cria o “mapeamento” das variáveis, normalmente usando aes (de aesthetics). Ou seja, você especifica quais são as variáveis dos eixos x e y dentro de aes(). Através dele vamos definir qual é a variável preditora/explanatora (eixo x) e qual é a variável resposta (eixo y) em nosso conjunto de dados. Depois da função ggplot(), na sequencia no codigo nós especificamos qual tipo de grafico com um “geom”. Por exemplo, geom_point() para plotar pontos, geom_boxplot() para um boxplot, etc. Para a lista completa de geoms e todas as outras opções do pacote, visite a página do projeto ggplot2 https://ggplot2.tidyverse.org/index.html . Aqui vamos fazer um gráfico com valores de extensão no eixo x e proporção da floresta central no eixo y. Assim sendo, com o codigo a segir, vamos informar (i) os dados, selecionando classe de floresta atraves de um filtro e acresentando uma coluna nova (“ext_m”) com a extensão em metros, (ii) as colunas para os eixos x e y, (iii) tipo de grafico (grafico de pontos - geom_point() e grafico de linha - geom_line()), (iv) nomes para os eixos. No exemplo, usamos |&gt;, que estabelece a ligação entre os passos do processo, ligando os dados (amostras_metrica) e o grafico ggplot. Note que no codigo a seguir, adicionamos um geom com um “+”. No ggplot2, nós criamos gráficos em camadas, e adicionamos camada a camada com um “+”. Assim, é posivel ajustar qualquer elemento do grafico. # arrumar os dados amostras_metrica |&gt; filter(class==1) |&gt; mutate(ext_m = 2*raio) |&gt; # fazer o grafico ggplot(aes(x=ext_m, y=value)) + geom_point() + geom_line() + labs(x = &quot;Extensão (metros)&quot;, y = &quot;Área central de floresta (porcentagem da paisagem)&quot;) Depois de executar (“run”) o código acima, você deverá ver o grafico a seguir. 2.4.2.2 Pergunta 3 Em vez de extensão, você preciso incluir o tamanho (área do circulo) correspondente a cada raio. Incluir uma cópia do código ajustado para produzir uma figura com tamanho (área em quilômetros quadrados) no eixo x. 2.4.2.3 Faça um gráfico elegante Podemos ajustar qualquer elemento do grafico com ggplot2. Agora, vamos mudar as unidades de metros para quilometros, aumentar o tamanho dos pontos, incluir uma linha reta para ilustrar a tendência geral, colocar o titulo longo do eixo y em duas linhas, e aumentar o tamanho da fonte para o texto ficar mais claro. # arrumar os dados amostras_metrica |&gt; filter(class==1) |&gt; mutate(ext_m = 2*raio, ext_km = (2*raio)/1000) |&gt; # fazer o grafico ggplot(aes(x=ext_km, y=value)) + geom_point(size = 4) + geom_line() + stat_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;green&quot;, linetype = &quot;dashed&quot;) + labs(x = &quot;Extensão (quilômetros)&quot;, y = &quot;Área central de floresta\\n(porcentagem da paisagem)&quot;) + theme(text = element_text(size = 18)) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Figura 2.4: Comparação da área central de floresta em diferentes extensões. 2.4.2.4 Pergunta 4 Em menos de 200 palavras apresente a sua interpretação do gráfico em figura 5.2. 2.4.2.5 Modelos linear e não linear Um dos desafios mais frequentes é como melhor representar os dados observados para gerar evidências científicas robustas e informações confiáveis. Nós vimos que as mudancas na métrica porcentagem de área central de floresta não segue uma linha reta em relação de escala (extensão). Para ir além de uma descrição simplista dos padrões observados, na ecologia da paisagem uma variedade de modelos estatísticos são usados.Não vamos rodar modelos (ainda), mas é importante entender algumas das opções disponíveis ao interpretar os gráficos. Por exemplo, modelos de regressão são amplamente usados em diversas aplicações para descrever a relação entre uma variável resposta Y e uma variável explicativa x. Os modelos lineares são uma generalização dos testes de hipótese clássicos mais simples (Modelos linear e Modelos lineares). Uma regressão linear, só pode ser aplicada para dados em que tanto a variável preditora quanto a resposta são contínuas, enquanto uma análise de variância é utilizada quando a variável preditora/explicativa é categórica. Os modelos lineares generalizados não têm essa limitação, podemos usar variáveis contínuas ou categóricas indistintamente (Modelos Lineares Generalizados). Mas, no caso de padroes ecologicas, sera que um modelo linear é o melhor modelo para representar a relação que explica “y” em função de “x”? Um número crescente de pesquisadores compartilham o sentimento de que as relações entre variáveis biológicas/ecologicas são melhores descritas por funções não lineares. Processos ecologicas (como por exemplo crescimento, mortalidade, dispersão, e competição) raramente são relacionadas linearmente às variáveis explicativas. A principal vantagem do modelo não linear sobre o linear é que 1) sua escolha está associada à conhecimento prévio sobre a relação a ser modelada e 2) geralmente apresenta interpretação prática para os parâmetros. Em modelos não-linear dados observados de uma variável resposta são descritos por uma função de uma ou mais variáveis explicativas que é não linear seus parâmetros. Assim como nos modelos lineares o objetivo é identificar e estabelecer a relação entre variáveis explicativas e resposta. Entretanto, enquanto os modelos lineares definem, em geral, relações empíricas/teoricas, os modelos não-lineares são, em grande parte das vezes, motivados pelo conhecimento do tipo de relação entre as variáveis. Desta forma, as aplicações surgem nas diversas áreas onde relações físicas, biológicas, cinéticas, químicas, fisiológicas, dentre outras, são estabelecidas por funções não lineares que devem ter coeficientes (parâmetros) identificados (estimados) a partir de dados observados, dados experimentais e/ou dados simulados. Como as mudanças na estrutura da paisagem caracterizam-se por serem não-lineares, para desenvolver análises estatísticas robustos pode (i) aplicar uma transformação (por exemplo, “log”) ou (ii) adotar modelos não-lineares. Figura 2.5: Comparação de padrões lineares e não-lineares. 2.4.2.6 Pergunta 5 Comparar os resultados apresentados nas figuras com modelos lineares e não-lineares. Como podemos estabelecer qual seria o melhor modelo? Qual modelo seria mais adequado para identificar limiares no padrão de área central de floresta? 2.4.3 Ponto único, distâncias variados, métricas variadas No exemplo anterior comparamos uma métrica da paisagem em torno de um único ponto de amostragem. Mas sabemos que uma combinação de várias métricas é necessária para entender os padrões na paisagem. Aqui mostraremos como incluir cálculos de diferentes métricas de paisagem ao mesmo tempo. Figura 2.6: Ilustração da determinação de métricas da paisagem diferentes ao redor de um ponto. Exemplo com a estrutura da paisagem representado com trés caracteristicas (A) Área central, (B) Borda e (C) Vizinho mais próximo. O habitat de interesse (classe) é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e as métricas calculadas. E em seguida o processo é repetido em diferentes extensões. Não deve calcular todas as métricas disponíveis, mas sim, escolher aquelas que podem ser realmente adequadas para sua pergunta de pesquisa. Calculando todas as métricas se chama um “tiro no escuro”, algo cujo resultado se desconhece ou é imprevisível. Isso não é recomendado. Para fazer uma escolha melhor (mais robusta), seguindo princípios básicos da ciência, precisamos ler os estudos anteriores (artigos) para obter as métricas mais relevantes para nosso objetivo, pergunta e/ou a hipótese a ser testada. Aqui, como exemplo illustrativa vamos calcular alguns das métricas mais comums. Mas, isso não representa necessariamente as métricas mais adequados ou recommendadas. Métricas de área e borda (area and edge metrics). Quantificam a composição da paisagem: pland = percentage of landscape. Percentagem da paisagem. Porcentagem de cobertura da classe na paisagem. ed = edge density . Densidade de borda que é igual à soma dos comprimentos (m) de todos os segmentos de borda que envolvem o fragmento, dividida pela área total da paisagem (m²), sendo posteriormente convertido em hectares. cpland = core area percentage of landscape. Percentual de área central (“core”) na paisagem. Percentual de áreas centrais (excluídas as bordas de 30 m) em relação à área total da paisagem. O termo “Core area” foi traduzido como área central ou área núcleo. Aqui vamos adotar área central. Métricas de agregação. Quantificam a configuração da paisagem: enn = euclidian nearest neighbour distance. Distância euclidiana do vizinho mais próximo. enn_cv = Coefficient of variation of euclidean nearest-neighbor distance. Coeficiente de variação da distância euclidiana do vizinho mais próximo. A métrica resume cada classe como o Coeficiente de variação das distâncias euclidianas do vizinho mais próximo entre as manchas pertencentes à classe. O valor de enn_cv = 0 se a distância euclidiana do vizinho mais próximo for idêntica para todas as manchas. Aumenta, sem limite, à medida que a variação do ENN aumenta. enn_sd = Standard deviation of euclidean nearest-neighbor distance. Desvio padrão da distância euclidiana do vizinho mais próximo. pd = Patch density. Densidade das manchas. cohesion = Cohesion index. Índice de coesão das manchas. Para incluir cálculos de diferentes métricas de paisagem ao mesmo tempo, precisamos acrescentar somente uma nova linha de codigo. Uma nova linha, que cria um objeto com os nomes das funções para as métricas que queremos calcular….. Também precisamos usar a opção “what” na função para aceitar os nomes das funções . # Objeto com os nomes das funções para calcular as métricas desejadas. # 6 métricas, # um (enn) com 3 estatisticas (mn = media, # sd = desvio padrão, # cv = coeficiente de variação) minhas_metricas &lt;- c(&quot;lsm_c_pland&quot;, &quot;lsm_c_ed&quot;, &quot;lsm_c_cpland&quot;, &quot;lsm_c_enn_mn&quot;, &quot;lsm_c_enn_sd&quot;, &quot;lsm_c_enn_cv&quot;, &quot;lsm_c_pd&quot;,&quot;lsm_c_cohesion&quot;) # 6 Métricas calculadas para cada extensão # raio 250 metros sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 250, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 250) -&gt; metricas_amostra_250 # raio 500 metros sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 500, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 500) -&gt; metricas_amostra_500 # raio 1 km (1000 metros) sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 1000, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 1000) -&gt; metricas_amostra_1000 # raio 2 km (2000 metros) sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 2000, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 2000) -&gt; metricas_amostra_2000 # raio 4 km (4000 metros) sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 4000, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 4000) -&gt; metricas_amostra_4000 # raio 8 km (8000 metros) sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 8000, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 8000) -&gt; metricas_amostra_8000 # raio 16 km (16000 metros) sample_lsm(floresta_2020, y = rio_pontos_31976[1, ], size = 16000, shape = &quot;circle&quot;, what = minhas_metricas) |&gt; mutate(raio = 16000) -&gt; metricas_amostra_16000 E agora, o código a seguir juntará os resultados das diferentes extensões. bind_rows(metricas_amostra_250, metricas_amostra_500, metricas_amostra_1000, metricas_amostra_2000, metricas_amostra_4000, metricas_amostra_8000, metricas_amostra_16000) -&gt; amostras_metricas Depois que executar (“run”), podemos olhar os dados com o codigo a seguir. amostras_metricas Os dados deve ter os valores (coluna “value”) das métricas (coluna metric) de cada classe (coluna “class”) para cada distância (coluna “raio”): layer level class id metric value plot_id percentage_inside raio 1 class 0 NA cohesion 100.00 1 113.4 250 1 class 0 NA cpland 80.32 1 113.4 250 1 class 0 NA ed 0.00 1 113.4 250 1 class NA NA enn_cv NA 1 113.4 250 1 class NA NA enn_mn NA 1 113.4 250 1 class NA NA enn_sd NA 1 113.4 250 1 class 0 NA pd 4.49 1 113.4 250 1 class 0 NA pland 100.00 1 113.4 250 1 class 0 NA cohesion 99.95 1 106.5 500 1 class 1 NA cohesion 76.69 1 106.5 500 Agora, vamos fazer um grafico com os dados amostras_metricas, usando o pacote ggplot2. Para ajudar na visualização incluímos quais métricas são para composição e configuração e nomes que são mais fáceis de entender. A função mutate é usado para incluir novas colunas. metricas_composicao &lt;- c(&quot;pland&quot;, &quot;ed&quot;, &quot;cpland&quot;) # arrumar dados amostras_metricas |&gt; filter(class==1) |&gt; mutate(ext_km = (2*raio)/1000, met_cat = if_else(metric %in% metricas_composicao, &quot;composição&quot;, &quot;configuração&quot;)) |&gt; # fazer grafico ggplot(aes(x=ext_km, y=value)) + geom_point() + geom_line() + facet_wrap(met_cat~metric, scales = &quot;free_y&quot;) + labs(title = &quot;Comparação multiescala de várias métricas&quot;, x = &quot;extensão (quilômetros)&quot;, y = &quot;metric value&quot;) 2.4.3.1 Pergunta 6 Com base nos resultados apresentados (figura e tabela) caracterisar as mudançãs na paisagem em função de extensões diferentes. Olhando os graficos prever como seria o padrão para extensões maiores (lembrando que valores são doubrados - por exemplo raio de 250 metros gerar uma extensão de 500 metros). Seria relevante repetir incluindo calculos para extensões maiores (por exemplo 64 km e 128 km)? Justifique sua caracterização e previsões de forma clara e concisa, apoie sua escolha com exemplos da literatura científica. 2.4.3.2 Pergunta 7 Usando como base o conteudo das aulas, leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises), e/ou exemplos apresentados aqui no tutorial, selecione pelo menos oito métricas de nível classe para caracterizar a paisagem de estudo e objectivos da sua projeto. Justifique sua seleção de forma clara e concisa, apoie sua escolha com exemplos da literatura científica. "],["garimpo-do-lourenço.html", "Capítulo 3 Garimpo do Lourenço 3.1 Apresentação 3.2 Pacotes necessarios: 3.3 Área de estudo 3.4 Dados 3.5 Calculo de métricas 3.6 Preparando os resultados 3.7 Uma tabela versatil 3.8 Reorganização 3.9 Uma figura elegante 3.10 Comparação entre anos 3.11 Conclusões e próximos passos", " Capítulo 3 Garimpo do Lourenço 3.1 Apresentação Mudanças na paisagem ao redor do Garimpo do Lourenço. Changes in the landscape surrounding the Lourenço gold mine. Código de R e dados para calcular métricas de paisagem associadas com a exploração de recursos minerários. O objetivo é calcular métricas de paisagem e descrever a composição e a configuração da paisagem no entorno do Garimpo do Lourenço. As métricas de paisagem são a forma que os ecólogos de paisagem usam para descrever os padrões espaciais de paisagens para depois avaliar a influência destes padrões espaciais nos padrões e processos ecológicos. Nesta exemplo (https://rpubs.com/darren75/lourenco) aprenderemos sobre como analisar a cobertura da terra com métricas de paisagem em R. Este exemplo tem como base teórica o modelo “mancha-corredor-matriz” - uma representação da paisagem em manchas de habitat (fragmentos). 3.2 Pacotes necessarios: library(tidyverse) library(readxl) library(terra) library(sf) library(landscapemetrics) library(mapview) library(knitr) library(gridExtra) 3.3 Área de estudo Para alcançar o objetivo de caracterizar a paisagem no entorno do Garimpo do Lourenço, precisamos estabelecer a extensão da área de estudo. Isso seria estabelicida com base nos objetivos e estudos anteriores. Sabemos que atividades asociados com a mineração pode aumentar a perda da floresta até 70 km além dos limites do processo de mineração: Sonter et. al. 2017. Mining drives extensive deforestation in the Brazilian Amazon https://www.nature.com/articles/s41467-017-00557-w Para visualizar um exemplo com a Extração de bauxita na Flona Saracá-Taquera: https://earthengine.google.com/timelapse/#v=-1.70085,-56.45017,8.939,latLng&amp;t=2.70 E aqui com o Garimpo do Lourenço: https://earthengine.google.com/timelapse#v=2.2994,-51.68423,11.382,latLng&amp;t=0.03 3.4 Dados 3.4.1 Ponto de referência (EPSG: 4326) Aqui vamos incluir um raio de 20 km além do ponto de acesso para o Garimpo do Lourenço em 1985. Isso representa uma área quadrada de 40 x 40 km (1600 km2). # Tabela de dados com coordenados de acesso em 1985. acesso &lt;- data.frame(nome = &quot;garimpo do Lourenço&quot;, coord_x = -51.630871, coord_y = 2.318514) # Converter para objeto espacial, com sistema de coordenados geográfica. sf_acesso &lt;- st_as_sf(acesso, coords = c(&quot;coord_x&quot;, &quot;coord_y&quot;), crs = 4326) Visualizar para verificar. # plot(sf_acesso) # teste basica mapview(sf_acesso) #verificar com mapa de base (OpenStreetMap) 3.4.2 Ponto de referência (EPSG: 31976) As análises da paisagem com o modelo “mancha-corredor-matriz” depende de uma classificação categórica. Portanto, deve optar para uma sistema de coordenados projetados, com pixels de área igual e com unidade em metros. Temos um raio de 20 km, que é um area geografica onde o retângulo envolvente é menor que um fuso UTM. Assim sendo, vamos adotar a sistema de coordenados projetados de datum SIRGAS 2000, especificamente EPSG:31976 (SIRGAS 2000/UTM zone 22N). Precisamos então reprojetar o objeto original (em coordenados geográficas) para a sistema de coordenados projetados. Em seguida, vamos produzir um polígono com raio de 20 km no entorno do ponto. # Reprojetar o ponto. sf_acesso_utm &lt;- st_transform(sf_acesso, crs = 31976) # Polígono com raio de 500 metros no entorno do ponto. sf_acesso_500m &lt;- st_buffer(sf_acesso_utm, dist=500) %&gt;% mutate(raio_km = 0.5) # Polígono com raio de 1 km no entorno do ponto. sf_acesso_1km &lt;- st_buffer(sf_acesso_utm, dist=1000) %&gt;% mutate(raio_km = 1) # Polígono com raio de 2 km no entorno do ponto. sf_acesso_2km &lt;- st_buffer(sf_acesso_utm, dist=2000) %&gt;% mutate(raio_km = 2) # Polígono com raio de 4 km no entorno do ponto. sf_acesso_4km &lt;- st_buffer(sf_acesso_utm, dist=4000) %&gt;% mutate(raio_km = 4) # Polígono com raio de 20 km no entorno do ponto. sf_acesso_20km &lt;- st_buffer(sf_acesso_utm, dist=20000) acesso_buffers &lt;- bind_rows(sf_acesso_500m, sf_acesso_1km, sf_acesso_2km, sf_acesso_4km) 3.4.3 Verificar com mapa de base (OpenStreetMap). # mapview(sf_acesso_20km) + mapview(sf_acesso_utm, color = &quot;black&quot;, col.regions = &quot;yellow&quot;) 3.4.4 Dados: MapBiomas cobertura da terra Agora vamos olhar cobertura e uso da terra no espaco que preciso (área de estudo). Para isso, vamos utilizar um arquivo de raster do projeto MapBiomas com cobertura de terra ao redor do Garimpo do Lourenço em 1985. Este arquivo no formato raster, tem apenas valores inteiros, em que cada célula/pixel representa uma área considerada homogênea, como uso do solo ou tipo de vegetação. Arquivo “.tif” disponível aqui: utm_cover_AP_lorenco_1985.tif Não vamos construir mapas, portanto os cores nas visualizações não corresponde ao mundo real (por exemplo, verde não é floresta). Para visualizar em QGIS preciso baixar um arquivo com a legenda e cores para Coleção¨6 (https://mapbiomas.org/codigos-de-legenda) e segue tutoriais: https://www.youtube.com/watch?v=WtyotodHK8E . Este vez, a entrada de dados espaciais seria atraves a importação de um raster (arquivo de .tif). Lembre-se, para facilitar, os arquivos deve ficar no mesmo diretório do seu código (verifique com getwd()). Como nós já sabemos a sistema de coordenados desejadas, o geoprocessamento da raster foi concluído antes de começar com as análises da paisagem. r1985 &lt;- rast(&quot;utm_cover_AP_lorenco_1985.tif&quot;) r1985 #class : SpatRaster #dimensions : 1341, 1341, 1 (nrow, ncol, nlyr) #resolution : 29.87713, 29.87713 (x, y) #extent : 409829.5, 449894.7, 236241.1, 276306.3 (xmin, xmax, ymin, ymax) #coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) #source : utm_cover_AP_lorenco_1985.tif #name : classification_1985 #min value : 3 #max value : 33 Ou use o função file.choose(), que faz a busca para arquivos. r1985 &lt;- rast(file.choose()) r1985 ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 6611649 353.2 10687490 570.8 10687490 570.8 ## Vcells 31540968 240.7 96871854 739.1 121089817 923.9 Agora que o arquivo foi importado, podemos visualizá- lo. # Visualizar para verificar # Gradiente de cores padrão não corresponde # ao mundo real (por exemplo verde não é floresta) plot(r1985, type=&quot;classes&quot;) plot(sf_acesso_20km, add = TRUE, lty =&quot;dashed&quot;, color = &quot;black&quot;) plot(sf_acesso_utm, add = TRUE, cex = 2, pch = 19, color = &quot;black&quot;) 3.5 Calculo de métricas Vamos olhar alguns exemplos de métricas para cada nível da análise: landscape (métricas para a paisagem como um todo). class (métricas por classe ou tipo de habiat). patch (para a mancha ou fragmento). Primeiro, pecisamos verificar se o raster está no formato correto. check_landscape(r1985) ## layer crs units class n_classes OK ## 1 1 projected m integer 7 ✔ # layer crs units class n_classes OK # 1 projected m integer 7 v Tudo certo (veja a coluna do “OK”)! 3.5.1 Métricas para a paisagem Vamos começar avaliando a área total da paisagem (área) de estudo. area.total &lt;- lsm_l_ta(r1985) area.total #160264 Hectares ## # A tibble: 1 × 6 ## layer level class id metric value ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 landscape NA NA ta 160264. Agora vamos ver a distância total de borda (te= “total edge”). ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 6613545 353.3 10687490 570.8 10687490 570.8 ## Vcells 31551215 240.8 96871854 739.1 121089817 923.9 te &lt;- lsm_l_te(r1985) te # 547140 metros ## # A tibble: 1 × 6 ## layer level class id metric value ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 landscape NA NA te 547140. Total de borda mede a configuração da paisagem porque uma paisagem altamente fragmentada terá muitas bordas. No entanto, a borda total é uma medida absoluta, dificultando comparações entre paisagens com áreas totais diferentes. Mas pode ser aplicado para comparar a configuração na mesma paisagem em anos diferentes. Agora vamos ver a densidade de Borda (“Edge Density”). Densidade de Borda mede a configuração da paisagem porque uma paisagem altamente fragmentada terá valores mais altas. “Densidade” é uma medida adequado para comparacoes de paisagens com áreas totais diferentes. ed &lt;- lsm_l_ed(r1985) ed #3.41 metros por hectare ## # A tibble: 1 × 6 ## layer level class id metric value ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 landscape NA NA ed 3.41 3.5.2 Métricas para as classes Area de cada classe em hectares. lsm_c_ca(r1985) ## # A tibble: 7 × 6 ## layer level class id metric value ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 class 3 NA ca 158582. ## 2 1 class 4 NA ca 1.70 ## 3 1 class 11 NA ca 1.79 ## 4 1 class 12 NA ca 548. ## 5 1 class 15 NA ca 563. ## 6 1 class 30 NA ca 526. ## 7 1 class 33 NA ca 41.4 Como tem varios classes é dificil de interpretar os resultados porque os numeros (3, 4, 11…..) não tem uma referncia do mundo real. Para entender os resultados, precisamos acrescentar nomes para os valores. Ou seja incluir uma coluna de legenda com os nomes para cada classe. Para isso precisamos outro arquivo com os nomes. Baixar a arquivo de legenda: mapbiomas_6_legend.xlsx. Agora carregar o arquivo com o codigo a seguir. class_nomes &lt;- read_excel(file.choose()) Agora rodar de novo, com os resultados juntos com a legenda de cada classe. Nos resultados acima, os valores na coluna “class” são as mesmas que tem na coluna “aid” no objeto “class_nomes”, onde também tem os nomes . Assim, podemos repetir, mas agora incluindo os nomes para cada valor de class, com base na ligação (join) entre as colunas. # Área de cada classe em hectares, incluindo os nomes para cada classe lsm_c_ca(r1985) %&gt;% left_join(class_nomes, by = c(&quot;class&quot; = &quot;aid&quot;)) # Numero de fragmentos (manchas) lsm_c_np(r1985) %&gt;% left_join(class_nomes, by = c(&quot;class&quot; = &quot;aid&quot;)) # Maior numero de manchas em classes de cobertura classificadas como # pasto (pasture) e formação campestre (grassland). # layer level class id metric value class_description group_description # 1 class 3 NA np 28 Forest Formation Natural forest # 1 class 4 NA np 2 Savanna Formation Natural forest # 1 class 11 NA np 7 Wetlands Natural non fore # 1 class 12 NA np 246 Grassland Natural non fore. # 1 class 15 NA np 262 Pasture Farming # 1 class 30 NA np 35 Mining Non vegetated # 1 class 33 NA np 50 River,Lake and Ocean Water 3.5.3 Métricas para as manchas Vamos calcular o tamanho de cada mancha agora. mancha_area &lt;- lsm_p_area(r1985) # 630 manchas mancha_area Agora queremos saber o tamanho da maior mancha em cada class, e portanto o tamanho da maior mancha de mineração. mancha_area %&gt;% group_by(class) %&gt;% summarise(max_ha = max(value)) # 30.8 hectares (class 15 = mineração) 3.5.4 Quais métricas devo escolher? A decisão deve ser tomada com base em uma combinação de fatores. Incluindo tais fatores como: base teórica, considerações estatísticas, relevância para o objetivo/hipótese e a escala e heterogeneidade na paisagem de estudo. Queremos caracterizar áreas de mineração na paisagem, e aqui vamos olhar somente uma paisagem, em um momento do tempo. Então as métricas para a paisagem como todo não tem relevância. Estamos olhando uma classe (mineração), portanto vamos incluir as métricas para classes. Alem disso, as métricas de paisagem em nível de classe são mais eficazes na definição de processos ecológicos (Tischendorf, L. Can landscape indices predict ecological processes consistently?. Landscape Ecology 16, 235–254 (2001). https://doi.org/10.1023/A:1011112719782.). # métricas de composição para a paisagem por classes list_lsm(level = &quot;class&quot;, type = &quot;area and edge metric&quot;) # métricas de configuração para a paisagem por classes list_lsm(level = &quot;class&quot;, type = &quot;aggregation metric&quot;) 3.5.5 Métricas por classe de mineração Aqui vamos calcular todos as métricas por classe (função calculate_lsm())). # métricas de composição para a paisagem por classes metrics_comp &lt;- calculate_lsm(r1985, level = &quot;class&quot;, type = &quot;area and edge metric&quot;) # métricas de configuração para a paisagem por classes metrics_config &lt;- calculate_lsm(r1985, level = &quot;class&quot;, type = &quot;aggregation metric&quot;) E aqui, calcular correlações entre todos as métricas por classe (função show_correlation())). show_correlation(data = metrics_comp, method = &quot;pearson&quot;, labels = TRUE) show_correlation(data = metrics_config, method = &quot;pearson&quot;, labels = TRUE) Temos muitos valores e muitas métricas. Este se chama um “tiro no escuro”, algo cujo resultado se desconhece ou é imprevisível. Isso não é recomendado. Para fazer uma escolha melhor (mais robusta), seguindo princípios básicos da ciência, precisamos ler os estudos anteriores (artigos) para obter as métricas mais relevantes para nosso objetivo e a hipótese a ser testada. Com base em os estudos anteriores e os objetivos vamos incluir 8 métricas nos resultados. 3.5.6 Exportar as métricas O próximo passo é comunicar os resultados obtidos. Para isso precisamos resumir e apresentar as métricas selecionadas em tabelas e figuras. Agora já fizemos os cálculos, as tabelas e figuras podem ser feitas no R (figuras), tanto quanto em aplicativos diferentes (por exemplo tabelas atraves [“tabelas dinamicas”] no Microsoft Excel ou LibreOffice calc). Mas por isso, primeiramente precisamos exportar os resultados (veja mais exemplos aqui: Introdução ao R import-export. O arquivo vai sai no mesmo diretório do seu código (verifique com getwd()). bind_rows(metrics_comp, metrics_config) -&gt; metricas_1985 write.csv2(metricas_1985, &quot;metricas_lourenco_1985.csv&quot;, row.names=FALSE) 3.6 Preparando os resultados A entrada de dados seria com as métricas da paisagem calculados anteriormente. Vocês devem baixar o arquivo de Excel metricas_lourenco_1985.xlsx. Lembre-se, para facilitar, os dados deve ficar no mesmo diretório do seu código (verifique com getwd()). No caso de um arquivo de Excel simples, a importação poderia ser feita através menu de “Import Dataset” na janela/panel “Environment” de Rstudio. Ou com linhas de código: metricas_1985 &lt;- read_excel(&quot;metricas_lourenco_1985.xlsx&quot;) metricas_1985 # layer level class id metric value # &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; # 1 class 3 NA area_cv 529. # 1 class 4 NA area_cv 22.3 # 1 class 11 NA area_cv 71.2 Ou use o função file.choose(), que faz a busca para arquivos. metricas_1985 &lt;- read_excel(file.choose()) metricas_1985 ## # A tibble: 182 × 6 ## layer level class id metric value ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 class 3 NA area_cv 529. ## 2 1 class 4 NA area_cv 22.3 ## 3 1 class 11 NA area_cv 71.2 ## 4 1 class 12 NA area_cv 169. ## 5 1 class 15 NA area_cv 175. ## 6 1 class 30 NA area_cv 276. ## 7 1 class 33 NA area_cv 74.2 ## 8 1 class 3 NA area_mn 5664. ## 9 1 class 4 NA area_mn 0.848 ## 10 1 class 11 NA area_mn 0.255 ## # ℹ 172 more rows Os dados são padronizados (“tidy”), mas ainda não parece adequados para apresentação em tabelas ou figuras. Temos muitos valores e muitas métricas (listadas na coluna “metric”). Com base em os estudos anteriores e os objetivos vamos incluir 8 métricas (4 de composição e 4 de configuração). Métricas de composição: mean patch area (lsm_c_area_mn) Área médio das manchas por classe. SD patch area (lsm_c_area_sd) Desvio padrão das áreas dos manchas por classe. class area percentage of landscape (lsm_c_pland) Porcentagem de área na paisagem por classe. largest patch index (lsm_c_lpi) Índice de maior mancha (proporção da paisagem). Métricas de configuração: aggregation index (lsm_c_ai) Índice de agregação. patch cohesion index (lsm_c_cohesion) Índice de coesão das manchas. number of patches (lsm_c_np) Número de manchas. patch density (lsm_c_pd) Densidade de manchas. Escolheremos (atraves um filtro) as métricas que queremos para obter uma tabela de dados. Mantendo os dados originais, assim sendo para acresentar mais métricas nos resultados, preciso somente acrescentar mais no codigo. # Arquivo com os nomes das classes class_in &lt;- &quot;C:\\\\Users\\\\user\\\\Documents\\\\Articles\\\\gis_layers\\\\gisdata\\\\inst\\\\raster\\\\mapbiomas_cover_lourenco_utm\\\\mapbiomas_6_legend.xlsx&quot; class_nomes &lt;- read_excel(class_in) # Especificar métricas desejados met_comp &lt;- c(&quot;pland&quot;, &quot;lpi&quot;, &quot;area_mn&quot;, &quot;area_sd&quot;) met_conf &lt;- c(&quot;ai&quot;, &quot;cohesion&quot;, &quot;np&quot;, &quot;pd&quot;) met_todos &lt;- c(met_comp, met_conf) # Escholer métricas desejados do conjunto completo metricas_1985 %&gt;% filter(metric %in% met_todos) %&gt;% left_join(class_nomes, by = c(&quot;class&quot; = &quot;aid&quot;)) -&gt; metricas_nomes 3.7 Uma tabela versatil Mas, ainda não tem uma coluna com os nomes das métricas. Portanto, solução simples é de exportar no formato de .csv e finalizar/editar no Excel / calc. Outra opção que pode facilitar, particularmente quando pode há mudanças e revisões, é produzir a tabela no R. Aqui vamos repetir no R os passos que vocês conhecem com as ferramentas de Excel (arraste e solte, copiar-colar, filtro, tabela dinâmica). 3.8 Reorganização Escolhendo as colunas desejadas (select), reorganizando para as métricas ficam nas colunas (pivot_wider) e colocando as colunas novas na sequência desejada (select). metricas_nomes %&gt;% # Escholer métricas desejados do conjunto completo de métricas. dplyr::select(c(type_class, classe_descricao, hexadecimal_code, metric, value)) %&gt;% # reorganizando pivot_wider(names_from = metric, values_from = value) -&gt; metricas_tab 3.9 Uma figura elegante Uma imagem vale mais que mil palavras. Portanto, gráficos/figuras/imagens são uma das mais importantes formas de comunicar a ciência. Como exemplo ilustrativo, aqui vamos produzir gráficos comparando métricas de composição e configuração da paisagem ao redor do Garimpo do Lourenço. É uma boa ideia gastar bastante tempo para tornar figuras científicas as mais informativas e atraentes possíveis. Escusado será dizer que a precisão empírica é primordial. E por isso, o que fica excluído/omitido é tão importante quanto o que foi incluído. Para ajudar, você deve se perguntar o seguinte ao criar uma figura: eu apresentaria essa figura em uma apresentação para um grupo de colegas? Eu o apresentaria a um público de não especialistas? Eu gostaria que essa figura aparecesse em um artigo de notícias sobre meu trabalho? É claro que todos esses locais exigem diferentes graus de precisão, complexidade e estética, mas uma boa figura deve servir para educar simultaneamente públicos muito diferentes. Tabelas versus gráficos — A primeira pergunta que você deve se fazer é se você pode transformar aquela tabela (chata e feia) em algum tipo de gráfico. Você realmente precisa dessa tabela no texto principal? Você não pode simplesmente traduzir as entradas das células em um gráfico de barras/colunas/xy? Se você pode, você deve. Quando uma tabela não pode ser facilmente traduzida em uma figura, na maioria das vezes a provavelmente pertence às Informações Suplementares/Anexos/Apêndices. 3.9.1 Gráfico de barra Primeiramente, vamos produzir uma gráfico de barra comparando a proporção que cada classe representa na paisagem. # Inclundo cores conforme legenda da Mapbiomas Coleção 6 # Legenda nomes ordem alfabetica classe_cores &lt;- c(&quot;Campo Alagado e Área Pantanosa&quot; = &quot;#45C2A5&quot;, &quot;Formação Campestre&quot; = &quot;#B8AF4F&quot;, &quot;Formação Florestal&quot; = &quot;#006400&quot;, &quot;Formação Savânica&quot; = &quot;#00ff00&quot;, &quot;Mineração&quot; = &quot;#af2a2a&quot;, &quot;Pastagem&quot; = &quot;#FFD966&quot;, &quot;Rio, Lago e Oceano&quot; = &quot;#0000FF&quot;) E agora o grafico……. # Grafico de barra basica metricas_tab %&gt;% mutate(class_prop = pland) %&gt;% ggplot(aes(x = classe_descricao, y = class_prop)) + geom_col() # Agora com ajustes # Agrupando por tipo (natural e antropico) # Com cores conforme legenda da Mapbiomas Coleção 6 # Corrigindo texto dos eixos. # Mudar posição da leganda para o texto com nomes longas encaixar. metricas_tab %&gt;% mutate(class_prop = pland) %&gt;% ggplot(aes(x = type_class, y = class_prop, fill = classe_descricao)) + scale_fill_manual(&quot;classe&quot;, values = classe_cores) + geom_col(position = position_dodge2(width = 1)) + coord_flip() + labs(title = &quot;MapBiomas cobertura da terra&quot;, subtitle = &quot;Entorno do Garimpo do Lorenço 1985&quot;, y = &quot;Proporção da paisagem (%)&quot;, x = &quot;&quot;) + theme(legend.position=&quot;bottom&quot;) + guides(fill = guide_legend(nrow = 4)) Uma imagem vale mais que mil palavras: Mas existe uma separação grande na faixa de valores e ainda é difícil de ver todas as classes. Temos uma distribuição com valores muito mais altos comparada com os outros. extremos. Uma solução seria uma transformação (por exemplo “log”), assim os valores ficarem mais proximos. 3.9.2 Gráfico de boxplot Agora com uma métrica de configuração: # Métrica de configuração: Densidade de manchas (coluna &quot;pd&quot;). # Agrupando por tipo (natural e antrópico) # Incluindo boxplot indicando tendência central (mediano) # Com cores conforme legenda da Mapbiomas Coleção 6 # Tamanho dos pontos proporcional o numero de manchas # Corrigindo texto dos eixos. # Mudar posição da leganda para o texto com nomes longas encaixar. metricas_tab %&gt;% ggplot(aes(x = type_class, y = pd)) + geom_boxplot(colour = &quot;grey50&quot;) + geom_point(aes(size = np, colour = classe_descricao)) + scale_color_manual(&quot;classe&quot;, values = classe_cores) + scale_size(guide = &quot;none&quot;) + coord_flip() + labs(title = &quot;MapBiomas cobertura da terra&quot;, subtitle = &quot;Entorno do Garimpo do Lorenço 1985&quot;, y = &quot;Densidade de manchas (número por 100 hectares)&quot;, x = &quot;&quot;) + theme(legend.position=&quot;bottom&quot;) + guides(col = guide_legend(nrow = 4)) 3.10 Comparação entre anos Calcular as métricas para 3 anos. # metricas desejados what_metricas &lt;- c(&quot;lsm_c_pland&quot;, &quot;lsm_c_lpi&quot;, &quot;lsm_c_area_mn&quot;, &quot;lsm_c_area_sd&quot;, &quot;lsm_c_ai&quot;, &quot;lsm_c_cohesion&quot;, &quot;lsm_c_np&quot;, &quot;lsm_c_pd&quot;) # rodar metricas_anos &lt;- sample_lsm(landscape = mapbiomas_85a20, y = acesso_buffers, plot_id = data.frame(acesso_buffers)[, &#39;raio_km&#39;], what = what_metricas, edge_depth = 1) # Organizar dados # Dados rferentes os buffers resultados_anos &lt;- acesso_buffers %&gt;% left_join(metricas_anos %&gt;% dplyr::mutate(value = round(value,2), ano = case_when(layer==1 ~1985, layer==2~2003, layer==3~2020)) %&gt;% dplyr::select(ano, plot_id, class, metric, value), by=c(&quot;raio_km&quot;=&quot;plot_id&quot;)) # Dados referentes os classes resultados_anos &lt;- resultados_anos %&gt;% left_join(class_nomes, by = c(&quot;class&quot; = &quot;aid&quot;)) Agora grafico de barra com varios anos # It&#39;s recommended to use a named vector # Legenda nomes ordem alfabetica classe_cores &lt;- c(&quot;Campo Alagado e Área Pantanosa&quot; = &quot;#45C2A5&quot;, &quot;Formação Campestre&quot; = &quot;#B8AF4F&quot;, &quot;Formação Florestal&quot; = &quot;#006400&quot;, &quot;Formação Savânica&quot; = &quot;#00ff00&quot;, &quot;Mineração&quot; = &quot;#af2a2a&quot;, &quot;Pastagem&quot; = &quot;#FFD966&quot;, &quot;Rio, Lago e Oceano&quot; = &quot;#0000FF&quot;, &quot;Outras Lavouras Temporárias&quot; = &quot;#e787f8&quot;) resultados_anos %&gt;% mutate(rcor = paste(&quot;#&quot;, hexadecimal_code, sep=&quot;&quot;)) %&gt;% filter(metric==&quot;pland&quot;) %&gt;% ggplot(aes(x=ano, y=value)) + geom_col(position=&quot;stack&quot;, aes(fill=classe_descricao)) + scale_fill_manual(values = classe_cores) + facet_grid(raio_km~type_class) Agora com “pland” e densidade de manchas juntos. resultados_anos %&gt;% mutate(rcor = paste(&quot;#&quot;, hexadecimal_code, sep=&quot;&quot;)) %&gt;% filter(metric==&quot;pland&quot;) %&gt;% ggplot(aes(x=ano, y=value)) + geom_col(position=&quot;stack&quot;, aes(fill=classe_descricao)) + scale_fill_manual(&quot;classe&quot;, values = classe_cores) + scale_y_continuous(breaks=c(0,50,100)) + scale_x_continuous(breaks=c(1985,2003, 2020)) + facet_grid(raio_km~type_class) + labs(title = &quot;MapBiomas cobertura da terra&quot;, subtitle = &quot;Entorno do Garimpo do Lorenço 1985-2020&quot;, y = &quot;Porcentagem da paisagem&quot;, x = &quot;Ano&quot;) + theme(legend.position=&quot;bottom&quot;, legend.title = element_text(size = 3), legend.text = element_text(size = 3), legend.key.size = unit(0.1, &quot;lines&quot;)) + guides(fill = guide_legend(nrow = 4)) -&gt; fig_pland # Densidade de manchas resultados_anos %&gt;% mutate(rcor = paste(&quot;#&quot;, hexadecimal_code, sep=&quot;&quot;)) %&gt;% filter(metric==&quot;pd&quot;) %&gt;% ggplot(aes(x = factor(ano), y = value)) + geom_boxplot(colour = &quot;grey50&quot;) + geom_point(aes(colour = classe_descricao)) + scale_color_manual(&quot;classe&quot;, values = classe_cores) + scale_size(guide = &quot;none&quot;) + facet_grid(raio_km~type_class) + labs(title = &quot;MapBiomas cobertura da terra&quot;, subtitle = &quot;Entorno do Garimpo do Lorenço 1985-2020&quot;, y = &quot;Densidade de manchas (número por 100 hectares)&quot;, x = &quot;Ano&quot;) + theme(legend.position=&quot;bottom&quot;, legend.title = element_text(size = 3), legend.text = element_text(size = 3), legend.key.size = unit(0.1, &quot;lines&quot;)) + guides(fill = guide_legend(nrow = 4)) -&gt; fig_pd grid.arrange(fig_pland, fig_pd, nrow=1) 3.11 Conclusões e próximos passos Os resultados apresentados na figura anterior não segam os resultados esperados que a cobertura de classes antrópicos ia aumentar ao longo do tempo. Para entender melhor os padores, precisamos: Verficar padrões nas outras metricas calculados Verficar padrões com mais anos Verficar padrões usando poligonos/pontos dos processos de mineração (dados no SIGMINE https://www.gov.br/anm/pt-br e https://app.anm.gov.br/dadosabertos/SIGMINE/PROCESSOS_MINERARIOS/) Alem disso, seria relevante buscar complementar os dados de MapBiomas com uma classificação supervisionado usando imagens de Sentinel-2 (exemplo com QGIS Semi-Automatic Classification plugin aqui: https://fromgistors.blogspot.com/2016/09/basic-tutorial-2.html). Assim para aumentar a precisão dos resultados. Uma forma alternativa para visualização as mudanças entre anos seria um diagrama “Sankey”/“Alluvial”. Como exemplo, veja figura 3 no artigo “Rapid land use conversion in the Cerrado has affected water transparency in a hotspot of ecotourism, Bonito, Brazil” https://doi.org/10.1177/19400829221127087 . Figura 3.1: Diagrama Sankey mostrando a mudança de uso da terra na bacia do rio Prata entre 2010 (lado esquerdo) e 2020 (lado direto). Fonte: Figura 3. Chiaravalloti et. al. 2022. Tropical Conservation Science. doi:10.1177/19400829221127087 No R pode fazer com o pacote “networkD3” segue tutoriais: https://www.displayr.com/sankey-diagrams-r/ https://epirhandbook.com/en/diagrams-and-charts.html#alluvialsankey-diagrams https://rpubs.com/droach/CPP526-codethrough "],["cap20.html", "Capítulo 4 Pré-requisitos 4.1 Introdução 4.2 Instalação do R 4.3 Instalação do RStudio 4.4 Versão do R 4.5 Pacotes 4.6 Dados", " Capítulo 4 Pré-requisitos Conteudo copiado, com pequenas alterações e atualizações de Capítulo 3 Pré-requisitos, do livro Análises Ecológicas no R . 4.1 Introdução O objetivo deste capítulo é informar como fazer a instalação dos Programas R e RStudio, além de descrever os pacotes e dados necessários para reproduzir os exemplos do livro. 4.2 Instalação do R Abaixo descrevemos os sete passos necessários para a instalação do programa R no seu computador. Para Windows, use link https://cran.r-project.org/bin/windows/base/ e vai para passo 6 : Para começarmos a trabalhar com o R é necessário baixá-lo na página do R Project. Então, acesse esse site http://www.r-project.org Clique no link download R Na página CRAN Mirros (Comprehensive R Archive Network), escolha uma das páginas espelho do Brasil mais próxima de você para baixar o programa Escolha agora o sistema operacional do seu computador (passos adicionais existem para diferentes distribuições Linux ou MacOS). Aqui faremos o exemplo com o Windows Clique em base para finalmente chegar à página de download com a versão mais recente do R Clique no arquivo Download R (versão mais recente) for Windows que será instalado no seu computador Abra o arquivo que foi baixado no seu computador e siga os passos indicados para finalizar a instalação do programa R Figura 4.1: Esquema ilustrativo demonstrando os passos necessários para instalação do programa R no computador. Importante Para o Sistema Operacional (SO) Windows, alguns pacotes são dependentes da instalação separada do Rtools40. Da mesma forma, GNU/Linux e MacOS também possuem dependências de outras bibliotecas para pacotes específicos, mas que não abordaremos aqui. Essas informações de dependência geralmente são retornadas como erros e você pode procurar ajuda em fóruns específicos. 4.3 Instalação do RStudio O RStudio possui algumas características que o tornam popular: várias janelas de visualização, marcação e preenchimento automático do script, integração com controle de versão, dentre outras funcionalidades. Abaixo descrevemos os cinco passos necessários para a instalação do RStudio no seu computador: Para fazer o download do RStudio, acessamos o site https://posit.co/download/rstudio-desktop/, Clique em download…, Abra o arquivo que foi baixado no seu computador e siga os passos indicados para finalizar a instalação do programa RStudio. Figura 4.2: Esquema ilustrativo demonstrando os passos necessários para instalação do programa RStudio no computador. 4.4 Versão do R Todas os códigos, pacotes e análises disponibilizados no livro foram realizados no Programa R versão 4.3.2 (10-12-2023). 4.5 Pacotes Descrevemos no Capítulo 5 o que são e como instalar os pacotes para realizar as análises estatísticas no R. Importante Criamos o pacote eprdados que contém todas as informações e dados utilizados neste livro. Assim, recomendamos que você instale e carregue este pacote no início de cada capítulo para ter acesso aos dados necessários para executar as funções no R. Para a instalação do pacote eprdados no macOS, você precisará ter instalado o programa XCode que pode ser baixado aqui. Este programa é disponibilizado gratuitamente pela Apple e é necessário para compilar quaisquer programas distribuídos em código fonte (ou seja, sem um binário). Após instalar esse programa e o pacote devtools, você poderá instalar o eprdados utilizando as instruções abaixo. Abaixo, listamos todos os pacotes utilizados no livro. Você pode instalar os pacotes agora ou esperar para instalá-los quando ler o Capítulo 5 e entender o que são as funções install.packages(), library() e install_github(). Para fazer a instalação, você vai precisar estar conectado à internet. install.packages(c(&quot;ade4&quot;, &quot;adespatial&quot;, &quot;ape&quot;, &quot;bbmle&quot;, &quot;betapart&quot;, &quot;BiodiversityR&quot;, &quot;car&quot;, &quot;cati&quot;, &quot;datasauRus&quot;, &quot;devtools&quot;, &quot;DHARMa&quot;, &quot;dplyr&quot;, &quot;ecolottery&quot;, &quot;emmeans&quot;, &quot;factoextra&quot;, &quot;FactoMineR&quot;, &quot;fasterize&quot;, &quot;FD&quot;, &quot;forcats&quot;, &quot;geobr&quot;, &quot;generalhoslem&quot;, &quot;GGally&quot;, &quot;ggExtra&quot;, &quot;ggforce&quot;, &quot;ggplot2&quot;, &quot;ggpubr&quot;, &quot;ggrepel&quot;, &quot;ggspatial&quot;, &quot;glmmTMB&quot;, &quot;grid&quot;, &quot;gridExtra&quot;, &quot;here&quot;, &quot;hillR&quot;, &quot;iNEXT&quot;, &quot;janitor&quot;, &quot;kableExtra&quot;, &quot;knitr&quot;, &quot;labdsv&quot;, &quot;lattice&quot;, &quot;leaflet&quot;, &quot;lmtest&quot;, &quot;lsmeans&quot;, &quot;lubridate&quot;, &quot;mapview&quot;, &quot;MASS&quot;, &quot;MuMIn&quot;, &quot;naniar&quot;, &quot;nlme&quot;, &quot;ordinal&quot;, &quot;palmerpenguins&quot;, &quot;performance&quot;, &quot;pez&quot;, &quot;phyloregion&quot;, &quot;phytools&quot;, &quot;picante&quot;, &quot;piecewiseSEM&quot;, &quot;purrr&quot;, &quot;pvclust&quot;, &quot;raster&quot;, &quot;readr&quot;, &quot;reshape2&quot;, &quot;rgdal&quot; , &quot;Rmisc&quot;, &quot;rnaturalearth&quot;, &quot;RVAideMemoire&quot;, &quot;sciplot&quot;, &quot;sf&quot;, &quot;sidrar&quot;, &quot;sjPlot&quot;, &quot;spData&quot;, &quot;spdep&quot;, &quot;stringr&quot;, &quot;SYNCSA&quot;, &quot;terra&quot;, &quot;tibble&quot;, &quot;tidyr&quot;, &quot;tidyverse&quot;, &quot;tmap&quot;, &quot;tmaptools&quot;, &quot;TPD&quot;, &quot;vcd&quot;, &quot;vegan&quot;, &quot;viridis&quot;, &quot;visdat&quot;, &quot;mvabund&quot;, &quot;rdist&quot;, &quot;udunits2&quot;), dependencies = TRUE) Diferente dos pacotes anteriores que são baixados do CRAN, alguns pacotes são baixados do GitHub dos pesquisadores responsáveis pelos pacotes. GitHub é um repositório remoto de códigos que permite controle de versão, muito utilizado por desenvolvedores e programadores. Nestes casos, precisamos carregar o pacote devtools para acessar a função install_github. Durante as instalações destes pacotes, algumas vezes o R irá pedir para você digitar um número indicando os pacotes que você deseja fazer update. Neste caso, digite 1 para indicar que ele deve atualizar os pacotes dependentes antes de instalar os pacotes requeridos. library(devtools) install_github(&quot;darrennorris/eprdados&quot;) install_github(&quot;ropensci/rnaturalearthhires&quot;) 4.6 Dados A maioria dos exemplos do livro utilizam dados reais extraídos de artigos científicos que já foram publicados ou dados que foram coletados por um dos autores deste livro. Todos os dados, publicados ou simulados, estão disponíveis no pacote eprdados. Além disso, em cada capítulo fazemos uma breve descrição dos dados para facilitar a compreensão sobre como essas variáveis estão relacionadas com as perguntas do exemplo. "],["cap21.html", "Capítulo 5 Introdução ao R Pré-requisitos do capítulo 5.1 Contextualização 5.2 R e RStudio 5.3 Funcionamento da linguagem R 5.4 Estrutura e manipulação de objetos 5.5 Para se aprofundar 5.6 Exercícios", " Capítulo 5 Introdução ao R Conteudo copiado, com pequenas alterações e atualizações de Capítulo 4 Introdução ao R, do livro Análises Ecológicas no R . Pré-requisitos do capítulo Pacotes e dados que serão utilizados neste capítulo. ## Pacotes library(palmerpenguins) ## Dados necessários pinguins &lt;- palmerpenguins::penguins 5.1 Contextualização O objetivo deste capítulo é apresentar os aspectos básicos da linguagem R para a realização dos principais passos para a manipulação, visualização e análise de dados. Abordaremos aqui as questões básicas sobre a linguagem R, como: i) R e RStudio, ii) funcionamento da linguagem, iii) estrutura e manipulação de objetos, iv) exercícios e v) principais livros e material para se aprofundar nos seus estudos. Todo processo de aprendizagem torna-se mais efetivo quando a teoria é combinada com a prática. Assim, recomendamos fortemente que você, leitor(a) acompanhe os códigos e exercícios deste livro, ao mesmo tempo que os executa em seu computador e não só os leia passivamente. Além disso, se você tiver seus próprios dados é muito importante tentar executar e/ou replicar as análises e/ou gráficos. Por motivos de espaço, não abordaremos todas as questões relacionadas ao uso da linguagem R neste capítulo. Logo, aconselhamos que você consulte o material sugerido no final do capítulo para se aprofundar. Este capítulo, na maioria das vezes, pode desestimular as pessoas que estão iniciando, uma vez que o mesmo não apresenta os códigos para realizar as análises estatísticas. Contudo, ele é essencial para o entendimento e interpretação do que está sendo informado nas linhas de código, além de facilitar a manipulação dos dados antes de realizar as análises estatísticas. Você perceberá que não usará este capítulo para fazer as análises, mas voltará aqui diversas vezes para relembrar qual é o código ou o que significa determinada expressão ou função usada nos próximos capítulos. 5.2 R e RStudio Com o R é possível manipular, analisar e visualizar dados, além de escrever desde pequenas linhas de códigos até programas inteiros. O R é a versão em código aberto de uma linguagem de programação chamada de S, criada por John M. Chambers (Stanford University, CA, EUA) nos anos 1980 no Bell Labs. No final dos anos 1990, Robert Gentleman e Ross Ihaka (ambos da Universidade de Auckland, Nova Zelândia), iniciaram o desenvolvimento da versão livre da linguagem S, a linguagem R, com o seguinte histórico: Desenvolvimento (1997-2000), Versão 1 (2000-2004), Versão 2 (2004-2013), Versão 3 (2013-2020) e Versão 4 (2020). Atualmente a linguagem R é mantida por uma rede de colaboradores denominada R Core Team. A origem do nome R é desconhecida, mas reza a lenda que ao lançarem o nome da linguagem os autores se valeram da letra que vinha antes do S, uma vez que a linguagem R foi baseada nela e utilizaram a letra “R”. Outra história conta que pelo fato do nome dos dois autores iniciarem por “R”, batizaram a linguagem com essa letra, vai saber. Um aspecto digno de nota é que a linguagem R é uma linguagem de programação interpretada, assim como o Python. Isso a faz ser mais fácil de ser utilizada, pois processa linhas de código e as transforma em linguagem de máquina (código binário que o computador efetivamente lê), apesar desse fato diminuir a velocidade de processamento. Para começarmos a trabalhar com o R é necessário baixá-lo na página do R Project. Os detalhes de instalação são apresentados no Capítulo 4. Reserve um tempo para explorar esta página do R-Project (https://www.r-project.org/). Existem vários livros dedicados a diversos assuntos baseados no R. Além disso, estão disponíveis manuais em diversas línguas para serem baixados gratuitamente. Como o R é um software livre, não existe a possibilidade de o usuário entrar em contato com um serviço de suporte de usuários. Ao invés disso, existem várias listas de e-mails que fornecem suporte à comunidade de usuários. Nós, particularmente, recomendamos o ingresso nas seguintes listas: R-help, R-sig-ecolog, R-br e discourse.curso-r. Os dois últimos grupos reúnem pessoas usuárias brasileiras do programa R. Apesar de podermos utilizar o R com o IDE (Ambiente de Desenvolvimento Integrado - Integrated Development Environment) RGui que vem com a instalação da linguagem R para usuários Windows ou no próprio terminal para usuários Linux e MacOS, existem alguns IDEs específicos para facilitar nosso uso dessa linguagem. Figura 5.1: Interface do RGui. Os números indicam: (1) R Script, (2) R Console, e (3) R Graphics. Dessa forma, nós utilizamos o IDE RStudio, e assumimos que você que está lendo fará o mesmo. O RStudio permite diversas personalizações, grande parte delas contidas em Tools &gt; Global options. Incentivamos as leitoras e leitores a “fuçar” com certa dose de cuidado, nas opções para personalização. Dentre essas mudanças, destacamos três: Tools &gt; Global options &gt; Appearance &gt; Editor theme: para escolher um tema para seu RStudio Tools &gt; Global options &gt; Code &gt; [X] Soft-wrap R source files: com essa opção habilitada, quando escrevemos comentários longos ou mudamos a largura da janela que estamos trabalhando, todo o texto e o código se ajustam a janela automaticamente Tools &gt; Global options &gt; Code &gt; Display &gt; [X Show Margis] e Margin column (80): com essa opção habilitada e para esse valor (80), uma linha vertical irá aparecer no script marcando 80 caracteres, um comprimento máximo recomendado para padronização dos scripts Importante Para evitar possíveis erros é importante instalar primeiro o software da linguagem R e depois o IDE RStudio. O RStudio permite também trabalhar com projetos. Projeto do RStudio é uma forma de organizar os arquivos de scripts e dados dentro de um diretório, facilitando o compartilhamento de fluxo de análises de dados e aumentando assim a reprodutibilidade. Podemos criar um Projeto do RStudio indo em File &gt; New Project ou no ícone de cubo azul escuro que possui um R dentro com um um círculo verde com um sinal de + na parte superior esquerda ou ainda no canto superior direito que possui cubo azul escrito Project que serve para gerenciar os projetos e depois em New Project. Depois de escolher uma dessas opções, uma janela se abrirá onde escolhemos uma das três opções: i) New Directory (para criar um diretório novo com diversas opções), ii) Existing Directory (para escolher um diretório já existente) e iii) Version Control (para criar um projeto que será versionado pelo git ou Subversion). 5.3 Funcionamento da linguagem R Nesta seção, veremos os principais conceitos para entender como a linguagem R funciona ou como geralmente utilizamos o IDE RStudio no dia a dia, para executar nossas rotinas utilizando a linguagem R. Veremos então: i) console, ii) script, iii) operadores, iv) objetos, v) funções, vi) pacotes, vii) ajuda (help), viii) ambiente (environment/workspace), ix) citações e x) principais erros. Antes de iniciarmos o uso do R pelo RStudio é fundamental entendermos alguns pontos sobre as janelas e o funcionamento delas no RStudio. Figura 5.2: Interface do RStudio. Os números indicam: (1) janela com abas de Script, R Markdown, dentre outras; (2) janela com abas de Console, Terminal e Jobs; (3) janela com abas de Environment, History, Conections e Tutorial; e (4) janela com abas de Files, Plots, Packages, Help e Viewer. Detalhando algumas dessas janelas e abas, temos: Console: painel onde os códigos são rodados e vemos as saídas Editor/Script: painel onde escrevemos nossos códigos em R, R Markdown ou outro formato Environment: painel com todos os objetos criados na sessão History: painel com o histórico dos códigos rodados Files: painel que mostra os arquivos no diretório de trabalho Plots: painel onde os gráficos são apresentados Packages: painel que lista os pacotes Help: painel onde a documentação das funções é exibida No RStudio, alguns atalhos são fundamentais para aumentar nossa produtividade: F1: abre o painel de Help quando digitado em cima do nome de uma função Ctrl + Enter: roda a linha de código selecionada no script Ctrl + Shift + N: abre um novo script Ctrl + S: salva um script Ctrl + Z: desfaz uma operação Ctrl + Shift + Z: refaz uma operação Alt + -: insere um sinal de atribuição (&lt;-) Ctrl + Shift + M: insere um operador pipe (%&gt;%) Ctrl + Shift + C: comenta uma linha no script - insere um (#) Ctrl + I: indenta (recuo inicial das linhas) as linhas Ctrl + Shift + A: reformata o código Ctrl + Shift + R: insere uma sessão (# ———————-) Ctrl + Shift + H: abre uma janela para selecionar o diretório de trabalho Ctrl + Shift + F10: reinicia o console Ctrl + L: limpa os códigos do console Alt + Shift + K: abre uma janela com todos os atalhos disponíveis 5.3.1 Console O console é onde a versão da linguagem R instalada é carregada para executar os códigos da linguagem R (Figura 5.2 janela 2). Na janela do console aparecerá o símbolo &gt;, seguido de uma barra vertical | que fica piscando (cursor), onde digitamos ou enviamos nossos códigos do script. Podemos fazer um pequeno exercício: vamos digitar 10 + 2, seguido da tecla Enter para que essa operação seja executada. 10 + 2 ## [1] 12 O resultado retorna o valor 12, precedido de um valor entre colchetes. Esses colchetes demonstram a posição do elemento numa sequência de valores. Se fizermos essa outra operação 1:42, o R vai criar uma sequência unitária de valores de 1 a 42. A depender da largura da janela do console, vai aparecer um número diferente entre colchetes indicando sua posição na sequência: antes do número 1 vai aparecer o [1], depois quando a sequência for quebrada, vai aparecer o número correspondente da posição do elemento, por exemplo, [37]. 1:42 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ## [25] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Podemos ver o histórico dos códigos executados no console na aba History (Figura 5.2 janela 3). 5.3.2 Scripts Scripts são arquivos de texto simples, criados com a extensão (terminação) .R (Figura 5.2 janela 1). Para criar um script, basta ir em File &gt; New File &gt; R Script, ou clicar no ícone com uma folha branca e um círculo verde com um sinal de +, logo abaixo de File, ou ainda usando o atalho Ctrl + Shift + N. Uma vez escrito os códigos no script podemos rodar esses códigos de duas formas: i) todo o script de uma vez, clicando em Source (que fina no canto superior direito da aba script) ou usando o atalho Ctrl + Shift + Enter; ou ii) apenas a linha onde o cursor estiver posicionado, independentemente de sua posição naquela linha, clicando em Run ou usando o atalho Ctrl + Enter. Devemos sempre salvar nossos scripts, tomando por via de regra: primeiro criar o arquivo e depois ir salvando nesse mesmo arquivo a cada passo de desenvolvimento das análises (não é raro o RStudio fechar sozinho e você perder algum tempo de trabalho). Há diversos motivos para se criar um script: continuar o desenvolvimento desse script em outro momento ou em outro computador, preservar trabalhos passados, ou ainda compartilhar seus códigos com outras pessoas. Para criar ou salvar um script basta ir em File &gt; Save, escolher um diretório e nome para o script e salvá-lo. Podemos ainda utilizar o atalho Ctrl + S. Em relação aos scripts, há ainda os comentários, representados pelos símbolos # (hash), #' (hash-linha) e #&gt; (hash-maior). A diferença entre eles é que para o segundo e terceiro, quando pressionamos a tecla Enter o comentário #' e #&gt; são inseridos automaticamente na linha seguinte. Linhas de códigos do script contendo comentários em seu início não são lidos pelo console do R. Se o comentário estiver no final da linha, essa linha de código ainda será lida. Os comentários são utilizados geralmente para: i) descrever informações sobre dados ou funções e/ou ii) suprimir linhas de código. É interessante ter no início de cada script um cabeçalho identificando o objetivo ou análise, autor e data para facilitar o compartilhamento e reprodutibilidade. Os comentários podem ser inseridos ou retirados das linhas com o atalho Ctrl + Shift + C. #&#39; --- #&#39; Título: Capítulo 04 - Introdução ao R #&#39; Autor: Maurício Vancine #&#39; Data: 11-11-2021 #&#39; --- Além disso, podemos usar comentários para adicionar informações sobre os códigos. ## Comentários # O R não lê a linha do código depois do # (hash). 42 # Essas palavras não são executadas, apenas o 42, a resposta para questão fundamental da vida, o universo e tudo mais. ## [1] 42 Por fim, outro ponto fundamental é ter boas práticas de estilo de código. Quanto mais organizado e padronizado estiver seus scripts, mais fácil de entendê-los e de procurar possíveis erros. Existem dois guias de boas práticas para adequar seus scripts: Hadley Wickham e Google. Para simplificar a vida temos o pacote styler (https://styler.r-lib.org/), que serve para adequar o codigo. Ainda em relação aos scripts, temos os Code Snippets (Fragmentos de código), que são macros de texto usadas para inserir rapidamente fragmentos comuns de código. Por exemplo, o snippet fun insere uma definição de função R. Para mais detalhes, ler o artigo do RStudio Code Snippets. # fun {snippet} fun name &lt;- function(variables) { } Uma aplicação bem interessante dos Code Snippets no script é o ts. Basta digitar esse código e em seguida pressionar a tecla Tab para inserir rapidamente a data e horário atuais no script em forma de comentário. # ts {snippet} # Thu Nov 11 18:19:26 2021 ------------------------------ 5.3.3 Operadores No R, podemos agrupar os operadores em cinco tipos: aritméticos, relacionais, lógicos, atribuição e diversos. Como exemplo, podemos fazer operações simples usando os operadores aritméticos. ## Operações aritméticas 10 + 2 # adição ## [1] 12 10 * 2 # multiplicação ## [1] 20 Precisamos ficar atentos à prioridade dos operadores aritméticos: PRIORITÁRIO () &gt; ^ &gt; * ou / &gt; + ou - NÃO PRIORITÁRIO Veja no exemplo abaixo como o uso dos parênteses muda o resultado. ## Sem especificar a ordem # Segue a ordem dos operadores. 1 * 2 + 2 / 2 ^ 2 ## [1] 2.5 ## Especificando a ordem # Segue a ordem dos parenteses. ((1 * 2) + (2 / 2)) ^ 2 ## [1] 9 5.3.4 Objetos Objetos são palavras às quais são atribuídos dados. A atribuição possibilita a manipulação de dados ou armazenamento dos resultados de análises. Utilizaremos os símbolos &lt; (menor), seguido de - (menos), sem espaço, dessa forma &lt;-. Também podemos utilizar o símbolo de igual (=), mas não recomendamos, por não fazer parte das boas práticas de escrita de códigos em R. Podemos inserir essa combinação de símbolos com o atalho Alt + -. Para demonstrar, vamos atribuir o valor 10 à palavra obj_10, e chamar esse objeto novamente para verificar seu conteúdo. ## Atribuição - símbolo (&lt;-) obj_10 &lt;- 10 obj_10 ## [1] 10 Importante Recomendamos sempre verificar o conteúdo dos objetos chamando-os novamente para confirmar se a atribuição foi realizada corretamente e se o conteúdo corresponde à operação realizada. Todos os objetos criados numa sessão do R ficam listados na aba Environment . Além disso, o RStudio possui a função autocomplete, ou seja, podemos digitar as primeiras letras de um objeto (ou função) e em seguida apertar Tab para que o RStudio liste tudo que começar com essas letras. Dois pontos importantes sobre atribuições: primeiro, o R sobrescreve os valores dos objetos com o mesmo nome, deixando o objeto com o valor da última atribuição. ## Sobrescreve o valor dos objetos obj &lt;- 100 obj ## [1] 100 ## O objeto &#39;obj&#39; agora vale 2 obj &lt;- 2 obj ## [1] 2 Segundo, o R tem limitações ao nomear objetos: nome de objetos só podem começar por letras (a-z ou A-Z) ou pontos (.) nome de objetos só podem conter letras (a-z ou A-Z), números (0-9), underscores (_) ou pontos (.) R é case-sensitive, i.e., ele reconhece letras maiúsculas como diferentes de letras minúsculas. Assim, um objeto chamado “resposta” é diferente do objeto “RESPOSTA” devemos evitar acentos ou cedilha (ç) para facilitar a memorização dos objetos e também para evitar erros de codificação (encoding) de caracteres nomes de objetos não podem ser iguais a nomes especiais, reservados para programação (break, else, FALSE, for, function, if, Inf, NA, NaN, next, repeat, return, TRUE, while) Podemos ainda utilizar objetos para fazer operações e criar objetos. Isso pode parecer um pouco confuso para os iniciantes, mas é fundamental aprender essa lógica para passar para os próximos passos. ## Definir dois objetos va1 &lt;- 10 va2 &lt;- 2 ## Operações com objetos e atribuicão adi &lt;- va1 + va2 adi ## [1] 12 5.3.5 Funções Funções são códigos preparados para realizar uma tarefa específica de modo simples. Outra forma de entender uma função é: códigos que realizam operações em argumentos. Devemos retomar ao conceito do ensino médio de funções: os dados de entrada são argumentos e a função realizará alguma operação para modificar esses dados de entrada. A estrutura de uma função é muito similar à sintaxe usada em planilhas eletrônicas, sendo composta por: nome_da_função(argumento1, argumento2, …) Nome da função: remete ao que ela faz Parênteses: limitam a função Argumentos: valores, parâmetros ou expressões onde a função atuará Vírgulas: separam os argumentos Os argumentos de uma função podem ser de dois tipos: Valores ou objetos: a função alterará os valores em si ou os valores atribuídos aos objetos Parâmetros: valores fixos que informam um método ou a realização de uma operação. Informa-se o nome desse argumento, seguido de “=” e um número, texto ou TRUE ou FALSE Alguns exemplos de argumentos como valores ou objetos. ## Funções - argumentos como valores sum(10, 2) ## [1] 12 ## Funções - argumentos como objetos sum(va1, va2) ## [1] 12 Vamos ver agora alguns exemplos de argumentos usados como parâmetros. Note que apesar do valor do argumento ser o mesmo (10), seu efeito no resultado da função rep() muda drasticamente. Aqui também é importante destacar um ponto: i) podemos informar os argumentos sequencialmente, sem explicitar seus nomes, ou ii) independente da ordem, mas explicitando seus nomes. Entretanto, como no exemplo abaixo, devemos informar o nome do argumento (i.e., parâmetro), para que seu efeito seja o que desejamos. ## Funções - argumentos como parâmetros ## Repetição - repete todos os elementos rep(x = 1:5, times = 10) ## [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 ## [38] 3 4 5 1 2 3 4 5 1 2 3 4 5 ## Repetição - repete cada um dos elementos rep(x = 1:5, each = 10) ## [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 ## [38] 4 4 4 5 5 5 5 5 5 5 5 5 5 Um ponto fundamental e que deve ser entendido é o fluxo de atribuições do resultado da operação de funções a novos objetos. No desenvolvimento de qualquer script na linguagem R, grande parte da estrutura do mesmo será dessa forma: atribuição de dados a objetos &gt; operações com funções &gt; atribuição dos resultados a novos objetos &gt; operações com funções desses novos objetos &gt; atribuição dos resultados a novos objetos. Ao entender esse funcionamento, começamos a entender como devemos pensar na organização do nosso script para montar as análises que precisamos. ## Atribuicão dos resultados ## Repetição rep_times &lt;- rep(1:5, times = 10) rep_times ## [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 ## [38] 3 4 5 1 2 3 4 5 1 2 3 4 5 ## Somar e atribuir rep_times_soma &lt;- sum(rep_times) rep_times_soma ## [1] 150 ## Raiz e atribuir rep_times_soma_raiz &lt;- sqrt(rep_times_soma) rep_times_soma_raiz ## [1] 12.24745 Por fim, é fundamental também entender a origem das funções que usamos no R. Todas as funções são advindas de pacotes. Esses pacotes possuem duas origens. pacotes já instalados por padrão e que são carregados quando abrimos o R (R Base) pacotes que instalamos e carregamos com funções 5.3.6 Pacotes Pacotes são conjuntos extras de funções para executar tarefas específicas, além dos pacotes instalados no R Base. Existe literalmente milhares de pacotes (~19,000 enquanto estamos escrevendo esse livro) para as mais diversas tarefas: estatística, ecologia, geografia, sensoriamento remoto, econometria, ciências sociais, gráficos, machine learning, etc. Podemos verificar este vasto conjunto de pacotes pelo link que lista por nome os pacotes oficiais, ou seja, que passaram pelo crivo do CRAN. Existem ainda muito mais pacotes em desenvolvimento, geralmente disponibilizados em repositórios do GitHub ou GitLab. Podemos listar esses pacotes disponíveis no CRAN com esse código. ## Número atual de pacotes no CRAN: 20192 em 15/12/2023 nrow(available.packages()) Primeiramente, com uma sessão do R sem carregar nenhum pacote extra, podemos verificar pacotes carregados pelo R Base utilizando a função search(). ## Verificar pacotes carregados search() Podemos ainda verificar todos pacotes instalados em nosso computador com a função library(). ## Verificar pacotes instalados library() No R, quando tratamos de pacotes, devemos destacar a diferença de dois conceitos: instalar um pacote e carregar um pacote. A instalação de pacotes possui algumas características: Instala-se um pacote apenas uma vez Precisamos estar conectados à internet O nome do pacote precisa estar entre aspas na função de instalação Função (CRAN): install.packages() Vamos instalar o pacote vegan diretamente do CRAN, que possui funções para realizar uma série de análise em ecologia. Para isso, podemos ir em Tools &gt; Install Packages..., ou ir na aba Packages , procurar o pacote e simplesmente clicar em “Install”. Podemos ainda utilizar a função install.packages(). ## Instalar pacotes install.packages(&quot;vegan&quot;) Podemos conferir em que diretórios um pacote será instalado com a função .libPaths(). ## Diretórios de intalação dos pacotes .libPaths() ## [1] &quot;C:/Users/user/AppData/Local/R/win-library/4.3&quot; ## [2] &quot;C:/Program Files/R/R-4.3.2/library&quot; Importante Uma vez instalado um pacote, não há necessidade de instalá-lo novamente. Entretanto, todas às vezes que iniciarmos uma sessão no R, precisamos carregar os pacotes com as funções que precisamos utilizar. O carregamento de pacotes possui algumas características: Carrega-se o pacote toda vez que se abre uma nova sessão do R Não precisamos estar conectados à internet O nome do pacote não precisa estar entre aspas na função de carregamento Funções: library() ou require() Vamos carregar o pacote vegan que instalamos anteriormente. Podemos ir na aba Packages e assinalar o pacote que queremos carregar ou utilizar a função library(). ## Carregar pacotes library(vegan) Como dissemos, alguns pacotes em desenvolvimento encontram-se disponíveis em repositórios como por exemplo: GitHub, GitLab e Bioconductor. Para instalar pacotes do GitHub, por exemplo, precisamos instalar e carregar o pacote devtools. Para funcionar, deve instalar “RTools” antes (https://cran.r-project.org/bin/windows/Rtools/) . ## Instalar pacote devtools install.packages(&quot;devtools&quot;) ## Carregar pacote devtools library(devtools) Uma vez instalado e carregado esse pacote, podemos instalar o pacote do GitHub, utilizando a função devtools::install_github(). Precisamos atentar para usar essa forma “nome_usuario/nome_repositorio”, retirados do link do repositório de interesse. Como exemplo, podemos instalar o pacote eprdados do repositório do GitHub darrennorris/eprdados e depois utilizar a função library() para carregá-lo. Para funcionar, deve instalar “RTools” antes (https://cran.r-project.org/bin/windows/Rtools/) . ## Instalar pacote do github devtools::install_github(&quot;darrennorris/eprdados&quot;) ## Carregar pacote do github library(&quot;eprdados&quot;) Podemos ver a descrição de um pacote com a função packageDescription(). ## Descrição de um pacote packageDescription(&quot;vegan&quot;) ## Package: vegan ## Title: Community Ecology Package ## Version: 2.6-4 ## Authors@R: c(person(&quot;Jari&quot;, &quot;Oksanen&quot;, role=c(&quot;aut&quot;,&quot;cre&quot;), ## email=&quot;jhoksane@gmail.com&quot;), person(&quot;Gavin L.&quot;, &quot;Simpson&quot;, ## role=&quot;aut&quot;, email=&quot;ucfagls@gmail.com&quot;), person(&quot;F. ## Guillaume&quot;, &quot;Blanchet&quot;, role=&quot;aut&quot;), person(&quot;Roeland&quot;, ## &quot;Kindt&quot;, role=&quot;aut&quot;), person(&quot;Pierre&quot;, &quot;Legendre&quot;, ## role=&quot;aut&quot;), person(&quot;Peter R.&quot;, &quot;Minchin&quot;, role=&quot;aut&quot;), ## person(&quot;R.B.&quot;, &quot;O&#39;Hara&quot;, role=&quot;aut&quot;), person(&quot;Peter&quot;, ## &quot;Solymos&quot;, role=&quot;aut&quot;), person(&quot;M. Henry H.&quot;, &quot;Stevens&quot;, ## role=&quot;aut&quot;), person(&quot;Eduard&quot;, &quot;Szoecs&quot;, role=&quot;aut&quot;), ## person(&quot;Helene&quot;, &quot;Wagner&quot;, role=&quot;aut&quot;), person(&quot;Matt&quot;, ## &quot;Barbour&quot;, role=&quot;aut&quot;), person(&quot;Michael&quot;, &quot;Bedward&quot;, ## role=&quot;aut&quot;), person(&quot;Ben&quot;, &quot;Bolker&quot;, role=&quot;aut&quot;), ## person(&quot;Daniel&quot;, &quot;Borcard&quot;, role=&quot;aut&quot;), person(&quot;Gustavo&quot;, ## &quot;Carvalho&quot;, role=&quot;aut&quot;), person(&quot;Michael&quot;, &quot;Chirico&quot;, ## role=&quot;aut&quot;), person(&quot;Miquel&quot;, &quot;De Caceres&quot;, role=&quot;aut&quot;), ## person(&quot;Sebastien&quot;, &quot;Durand&quot;, role=&quot;aut&quot;), person(&quot;Heloisa ## Beatriz Antoniazi&quot;, &quot;Evangelista&quot;, role=&quot;aut&quot;), ## person(&quot;Rich&quot;, &quot;FitzJohn&quot;, role=&quot;aut&quot;), person(&quot;Michael&quot;, ## &quot;Friendly&quot;, role=&quot;aut&quot;), person(&quot;Brendan&quot;,&quot;Furneaux&quot;, ## role=&quot;aut&quot;), person(&quot;Geoffrey&quot;, &quot;Hannigan&quot;, role=&quot;aut&quot;), ## person(&quot;Mark O.&quot;, &quot;Hill&quot;, role=&quot;aut&quot;), person(&quot;Leo&quot;, &quot;Lahti&quot;, ## role=&quot;aut&quot;), person(&quot;Dan&quot;, &quot;McGlinn&quot;, role=&quot;aut&quot;), ## person(&quot;Marie-Helene&quot;, &quot;Ouellette&quot;, role=&quot;aut&quot;), ## person(&quot;Eduardo&quot;, &quot;Ribeiro Cunha&quot;, role=&quot;aut&quot;), ## person(&quot;Tyler&quot;, &quot;Smith&quot;, role=&quot;aut&quot;), person(&quot;Adrian&quot;, ## &quot;Stier&quot;, role=&quot;aut&quot;), person(&quot;Cajo J.F.&quot;, &quot;Ter Braak&quot;, ## role=&quot;aut&quot;), person(&quot;James&quot;, &quot;Weedon&quot;, role=&quot;aut&quot;)) ## Depends: permute (&gt;= 0.9-0), lattice, R (&gt;= 3.4.0) ## Suggests: parallel, tcltk, knitr, markdown ## Imports: MASS, cluster, mgcv ## VignetteBuilder: utils, knitr ## Description: Ordination methods, diversity analysis and other ## functions for community and vegetation ecologists. ## License: GPL-2 ## BugReports: https://github.com/vegandevs/vegan/issues ## URL: https://github.com/vegandevs/vegan ## NeedsCompilation: yes ## Packaged: 2022-10-11 08:36:07 UTC; jarioksa ## Author: Jari Oksanen [aut, cre], Gavin L. Simpson [aut], F. Guillaume ## Blanchet [aut], Roeland Kindt [aut], Pierre Legendre [aut], ## Peter R. Minchin [aut], R.B. O&#39;Hara [aut], Peter Solymos ## [aut], M. Henry H. Stevens [aut], Eduard Szoecs [aut], Helene ## Wagner [aut], Matt Barbour [aut], Michael Bedward [aut], Ben ## Bolker [aut], Daniel Borcard [aut], Gustavo Carvalho [aut], ## Michael Chirico [aut], Miquel De Caceres [aut], Sebastien ## Durand [aut], Heloisa Beatriz Antoniazi Evangelista [aut], ## Rich FitzJohn [aut], Michael Friendly [aut], Brendan Furneaux ## [aut], Geoffrey Hannigan [aut], Mark O. Hill [aut], Leo Lahti ## [aut], Dan McGlinn [aut], Marie-Helene Ouellette [aut], ## Eduardo Ribeiro Cunha [aut], Tyler Smith [aut], Adrian Stier ## [aut], Cajo J.F. Ter Braak [aut], James Weedon [aut] ## Maintainer: Jari Oksanen &lt;jhoksane@gmail.com&gt; ## Repository: CRAN ## Date/Publication: 2022-10-11 12:40:02 UTC ## Built: R 4.3.2; x86_64-w64-mingw32; 2023-11-02 03:07:22 UTC; windows ## Archs: x64 ## ## -- File: C:/Users/user/AppData/Local/R/win-library/4.3/vegan/Meta/package.rds A maioria dos pacotes possui conjuntos de dados que podem ser acessados pela função data(). Esses conjuntos de dados podem ser usados para testar as funções do pacote. Se estiver com dúvida na maneira como você deve preparar a planilha para realizar uma análise específica, entre na Ajuda (Help) da função e veja os conjuntos de dados que estão no exemplo desta função. Como exemplo, vamos carregar os dados dune do pacote vegan, que são dados de observações de 30 espécies vegetais em 20 locais. ## Carregar dados de um pacote library(vegan) data(dune) dune[1:6, 1:6] ## Achimill Agrostol Airaprae Alopgeni Anthodor Bellpere ## 1 1 0 0 0 0 0 ## 2 3 0 0 2 0 3 ## 3 0 4 0 7 0 2 ## 4 0 8 0 2 0 2 ## 5 2 0 0 0 4 2 ## 6 2 0 0 0 3 0 E um último ponto fundamental sobre pacotes, diz respeito à atualização dos mesmos. Os pacotes são atualizados com frequência, e infelizmente (ou felizmente, pois as atualizações podem oferecer algumas quebras entre pacotes), não se atualizam sozinhos. Muitas vezes, a instalação de um pacote pode depender da versão dos pacotes dependentes, e geralmente uma janela com diversas opções numéricas se abre perguntando se você quer que todos os pacotes dependentes sejam atualizados. Podemos ir na aba Packages e clicar em “Update” ou usar a função update.packages(checkBuilt = TRUE, ask = FALSE) para atualizá-los, entretanto, essa é uma função que costuma demorar muito para terminar de ser executada. ## Atualização dos pacotes update.packages(checkBuilt = TRUE, ask = FALSE) Destacamos e incentivamos ainda uma prática que achamos interessante para aumentar a reprodutibilidade de nossos códigos e scripts: a de chamar as funções de pacotes carregados dessa forma pacote::função(). Com o uso dessa prática, deixamos claro o pacote em que a função está implementada. Esta prática é importante por que com frequência pacotes diferentes criam funções com mesmo nome, mas com características internas (argumentos) diferentes. Assim, não expressar o pacote de interesse pode gerar erros na execução de suas análises. Destacamos aqui o exemplo de como instalar pacotes do GitHub do pacote devtools. ## Pacote seguido da função implementada daquele pacote devtools::install_github() 5.3.7 Ajuda (Help) Um importante passo para melhorar a usabilidade e ter mais familiaridade com a linguagem R é aprender a usar a ajuda (help) de cada função. Para tanto, podemos utilizar a função help() ou o operador ?, depois de ter carregado o pacote. O arquivo de ajuda do R possui tópicos, que nos auxiliam muito no entendimento dos dados de entrada, argumentos e que operações estão sendo realizadas.Abaixo descrevemos esses tópicos: Description: resumo da função Usage: como utilizar a função e quais os seus argumentos Arguments: detalha os argumentos e como os mesmos devem ser especificados Details: detalhes importantes para se usar a função Value: mostra como interpretar a saída (output) da função (os resultados) Note: notas gerais sobre a função Authors: autores da função References: referências bibliográficas para os métodos usados para construção da função See also: funções relacionadas Examples: exemplos do uso da função. Às vezes pode ser útil copiar esse trecho e colar no R para ver como funciona e como usar a função. Vamos realizar um exemplo, buscando o help da função aov(), que realiza uma análise de variância. ## Ajuda help(aov) ?aov Além das funções, podemos buscar detalhes de um pacote específico, para uma página simples do help utilizando a função help() ou o operador ?. Entretanto, para uma opção que ofereça uma descrição detalhada e um índice de todas as funções do pacote, podemos utilizar a função library(), mas agora utilizando o argumento help, indicando o pacote de interesse entre aspas. ## Ajuda do pacote help(vegan) ?vegan ## Help detalhado library(help = &quot;vegan&quot;) Podemos ainda procurar o nome de uma função para realizar uma análise específica utilizando a função help.search() com o termo que queremos em inglês e entre aspas. ## Procurar por funções que realizam modelos lineares help.search(&quot;linear models&quot;) Outra ferramenta de busca é a página rseek, na qual é possível buscar por um termo não só nos pacotes do R, mas também em listas de emails, manuais, páginas na internet e livros sobre o programa. 5.3.8 Ambiente (Environment) O ambiente (environment), como vimos, é onde os objetos criados são armazenados. É fundamental entender que um objeto é uma alocação de um pequeno espaço na memória RAM do nosso computador, onde o R armazenará um valor ou o resultado de uma função, utilizando o nome dos objetos que definimos na atribuição. Sendo assim, se fizermos a atribuição de um objeto maior que o tamanho da memória RAM do nosso computador, esse objeto não será alocado, e a atribuição não funcionará, retornando um erro. Existem opções para contornar esse tipo de limitação, mas não a abordaremos aqui. Entretanto, podemos utilizar a função object.size() para saber quanto espaço nosso objeto criado está alocando de memória RAM. ## Tamanho de um objeto object.size(adi) ## 56 bytes Podemos listar todos os objetos criados com a função ls() ou objects(). ## Listar todos os objetos ls() Podemos ainda remover todos os objetos criados com a função rm() ou remove(). Ou ainda fazer uma função composta para remover todos os objetos do Environment. ## Remover um objeto rm(adi) ## Remover todos os objetos criados rm(list = ls()) Quando usamos a função ls() agora, nenhum objeto é listado. ## Listar todos os objetos ls() ## character(0) Toda a vez que fechamos o R os objetos criados são apagados do Environment. Dessa forma, em algumas ocasiões, por exemplo, análises estatísticas que demoram um grande tempo para serem realizadas, pode ser interessante exportar alguns ou todos os objetos criados. Para salvar todos os objetos, ou seja, todo o Workspace, podemos ir em Session -&gt; Save Workspace As... e escolher o nome do arquivo do Workspace, por exemplo, “meu_workspace.RData”. Podemos ainda utilizar funções para essas tarefas. A função save.image() salva todo Workspace com a extensão .RData. ## Salvar todo o workspace save.image(file = &quot;meu_workspace.RData&quot;) Depois disso, podemos fechar o RStudio tranquilamente e quando formos trabalhar novamente, podemos carregar os objetos criados indo em Session -&gt; Load Workspace... ou utilizando a função load(). ## Carregar todo o workspace load(&quot;meu_workspace.RData&quot;) Entretanto, em algumas ocasiões, não precisamos salvar todos os objetos. Dessa forma, podemos salvar apenas alguns objetos específicos usando a função save(), também com a extensão .RData. ## Salvar apenas um objeto save(obj1, file = &quot;meu_obj.RData&quot;) ## Salvar apenas um objeto save(obj1, obj2, file = &quot;meus_objs.RData&quot;) ## Carregar os objetos load(&quot;meus_objs.RData&quot;) Ou ainda, podemos salvar apenas um objeto com a extensão .rds. Para isso, usamos as funções saveRDS() e readRDS(), para exportar e importar esses dados, respectivamente. É importante ressaltar que nesse formato .rds, apenas um objeto é salvo por arquivo criado e que para que o objeto seja criado no Workspace do R, ele precisa ser lido e atribuído à um objeto. ## Salvar um objeto para um arquivo saveRDS(obj, file = &quot;meu_obj.rds&quot;) ## Carregar esse objeto obj &lt;- readRDS(file = &quot;meu_obj.rds&quot;) 5.3.9 Citações Ao utilizar o R para realizar alguma análise em nossos estudos, é fundamental a citação do mesmo. Para saber como citar o R em artigos, existe uma função denominada citation(), que provê um formato genérico de citação e um BibTeX para arquivos LaTeX e R Markdown. ## Citação do R citation() ## To cite R in publications use: ## ## R Core Team (2023). _R: A Language and Environment for Statistical ## Computing_. R Foundation for Statistical Computing, Vienna, ## Austria. &lt;https://www.R-project.org/&gt;. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2023}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please cite ## it when using it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; ## for citing R packages. No resultado dessa função, há uma mensagem muito interessante: “See also ‘citation(“pkgname”)’ for citing R packages.”. Dessa forma, aconselhamos, sempre que possível, claro, citar também os pacotes utilizados nas análises para dar os devidos créditos aos desenvolvedores e desenvolvedoras das funções implementadas nos pacotes. Como exemplo, vamos ver como fica a citação do pacote vegan. ## Citação do pacote vegan citation(&quot;vegan&quot;) ## To cite package &#39;vegan&#39; in publications use: ## ## Oksanen J, Simpson G, Blanchet F, Kindt R, Legendre P, Minchin P, ## O&#39;Hara R, Solymos P, Stevens M, Szoecs E, Wagner H, Barbour M, ## Bedward M, Bolker B, Borcard D, Carvalho G, Chirico M, De Caceres ## M, Durand S, Evangelista H, FitzJohn R, Friendly M, Furneaux B, ## Hannigan G, Hill M, Lahti L, McGlinn D, Ouellette M, Ribeiro Cunha ## E, Smith T, Stier A, Ter Braak C, Weedon J (2022). _vegan: ## Community Ecology Package_. R package version 2.6-4, ## &lt;https://CRAN.R-project.org/package=vegan&gt;. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {vegan: Community Ecology Package}, ## author = {Jari Oksanen and Gavin L. Simpson and F. Guillaume Blanchet and Roeland Kindt and Pierre Legendre and Peter R. Minchin and R.B. O&#39;Hara and Peter Solymos and M. Henry H. Stevens and Eduard Szoecs and Helene Wagner and Matt Barbour and Michael Bedward and Ben Bolker and Daniel Borcard and Gustavo Carvalho and Michael Chirico and Miquel {De Caceres} and Sebastien Durand and Heloisa Beatriz Antoniazi Evangelista and Rich FitzJohn and Michael Friendly and Brendan Furneaux and Geoffrey Hannigan and Mark O. Hill and Leo Lahti and Dan McGlinn and Marie-Helene Ouellette and Eduardo {Ribeiro Cunha} and Tyler Smith and Adrian Stier and Cajo J.F. {Ter Braak} and James Weedon}, ## year = {2022}, ## note = {R package version 2.6-4}, ## url = {https://CRAN.R-project.org/package=vegan}, ## } Podemos ainda utilizar a função write_bib() do pacote knitr para exportar a citação do pacote no formato .bib. ## Exportar uma citação em formato .bib knitr::write_bib(&quot;vegan&quot;, file = &quot;vegan_ex.bib&quot;) 5.3.10 Principais erros de iniciantes Errar quando se está começando a usar o R é muito comum e faz parte do aprendizado. Entretanto, os erros nunca devem ser encarados como uma forma de desestímulo, mas sim como um desafio para continuar tentando. Todos nós, autores deste livro inclusive, e provavelmente usuários mais ou menos experientes, já passaram por um momento em que se quer desistir de tudo. Jovem aprendiz de R, a única diferença entre você que está iniciando agora e nós que usamos o R há mais tempo são as horas a mais de uso (e ódio). O que temos a mais é experiência para olhar o erro, lê-lo e conseguir interpretar o que está errado e saber buscar ajuda. Dessa forma, o ponto mais importante de quem está iniciando é ter paciência, calma, bom humor, ler e entender as mensagens de erros. Recomendamos uma prática que pode ajudar: caso não esteja conseguindo resolver alguma parte do seu código, deixe ele de lado um tempo, descanse, faça uma caminhada, tome um banho, converse com seus animais de estimação ou plantas, tenha um pato de borracha ou outro objeto inanimado (um dos autores tem um sapinho de madeira), explique esse código para esse pato (processo conhecido como Debug com Pato de Borracha), logo a solução deve aparecer. Listaremos aqui o que consideramos os principais erros dos iniciantes no R. 1. Esquecer de completar uma função ou bloco de códigos Esquecer de completar uma função ou bloco de códigos é algo bem comum. Geralmente esquecemos de fechar aspas \"\" ou parênteses (), mas geralmente o R nos informa isso, indicando um símbolo de + no console. Se você cometeu esse erro, lembre-se de apertar a tecla esc do seu computador clicando antes com o cursor do mouse no console do R. sum(1, 2 + ## Error: &lt;text&gt;:3:0: unexpected end of input ## 1: sum(1, 2 ## 2: + ## ^ 2. Esquecer de vírgulas dentro de funções Outro erro bastante comum é esquecer de acrescentar a vírgula , para separar argumentos dentro de uma função, principalmente se estamos compondo várias funções acopladas, i.e., uma função dentro da outra. sum(1 2) ## Error: &lt;text&gt;:1:7: unexpected numeric constant ## 1: sum(1 2 ## ^ 3. Chamar um objeto pelo nome errado Pode parecer simples, mas esse é de longe o erro mais comum que pessoas iniciantes comentem. Quando temos um script longo, é de se esperar que tenhamos atribuído diversos objetos e em algum momento atribuímos um nome do qual não lembramos. Dessa forma, quando chamamos o objeto ele não existe e o console informa um erro. Entretanto, esse tipo de erro pode ser facilmente identificado, como o exemplo abaixo. obj &lt;- 10 OBJ ## Error in eval(expr, envir, enclos): object &#39;OBJ&#39; not found 4. Esquecer de carregar um pacote Esse também é um erro recorrente, mesmo para usuários mais experientes. Em scripts de análises complexas, que requerem vários pacotes, geralmente esquecemos de um ou outro pacote. A melhor forma de evitar esse tipo de erro é listar os pacotes que vamos precisar usar logo no início do script. ## Carregar dados data(dune) ## Warning in data(dune): data set &#39;dune&#39; not found ## Função do pacote vegan decostand(dune[1:6, 1:6], &quot;hell&quot;) ## Error in decostand(dune[1:6, 1:6], &quot;hell&quot;): could not find function &quot;decostand&quot; Geralmente a mensagem de erro será de que a função não foi encontrada ou algo nesse sentido. Carregando o pacote, esse erro é contornado. ## Carregar o pacote library(vegan) ## This is vegan 2.6-4 ## Carregar dados data(dune) ## Função do pacote vegan decostand(dune[1:6, 1:6], &quot;hell&quot;) ## Achimill Agrostol Airaprae Alopgeni Anthodor Bellpere ## 1 1.0000000 0.0000000 0 0.0000000 0.0000000 0.0000000 ## 2 0.6123724 0.0000000 0 0.5000000 0.0000000 0.6123724 ## 3 0.0000000 0.5547002 0 0.7337994 0.0000000 0.3922323 ## 4 0.0000000 0.8164966 0 0.4082483 0.0000000 0.4082483 ## 5 0.5000000 0.0000000 0 0.0000000 0.7071068 0.5000000 ## 6 0.6324555 0.0000000 0 0.0000000 0.7745967 0.0000000 5. Usar o nome da função de forma errônea Esse erro não é tão comum, mas pode ser incômodo às vezes. Algumas funções possuem nomes no padrão “Camel Case”, i.e., com letras maiúsculas no meio do nome da função. Isso às vezes pode confundir, ou ainda, as funções podem ou não ser separadas com ., como row.names() e rownames(). ## Soma das colunas colsums(dune) ## Error in colsums(dune): could not find function &quot;colsums&quot; ## Soma das colunas colSums(dune) ## Achimill Agrostol Airaprae Alopgeni Anthodor Bellpere Bromhord Chenalbu ## 16 48 5 36 21 13 15 1 ## Cirsarve Comapalu Eleopalu Elymrepe Empenigr Hyporadi Juncarti Juncbufo ## 2 4 25 26 2 9 18 13 ## Lolipere Planlanc Poaprat Poatriv Ranuflam Rumeacet Sagiproc Salirepe ## 58 26 48 63 14 18 20 11 ## Scorautu Trifprat Trifrepe Vicilath Bracruta Callcusp ## 54 9 47 4 49 10 6. Atentar para o diretório correto Muitas vezes o erro é simplesmente porque o usuário(a) não definiu o diretório correto onde está o arquivo a ser importado ou exportado. Por isso é fundamental sempre verificar se o diretório foi definido corretamente, geralmente usando as funções dir() ou list.files() para listar no console a lista de arquivos no diretório. Podemos ainda usar o argumento pattern para listar arquivos por um padrão textual. ## Listar os arquivos do diretório definido dir() list.files() ## Listar os arquivos do diretório definido por um padrão dir(pattern = &quot;.csv&quot;) Além disso, é fundamental ressaltar a importância de verificar se o nome do arquivo que importaremos foi digitado corretamente, atentando-se também para a extensão: .csv, .txt, .xlsx, etc. 5.4 Estrutura e manipulação de objetos O conhecimento sobre a estrutura e manipulação de objetos é fundamental para ter domínio e entendimento do funcionamento da linguagem R. Nesta seção, trataremos da estrutura e manipulação de dados no R, no que ficou conhecido como modo R Base, em contrapartida ao tidyverse, tópico tratado no Capítulo ??. Abordaremos aqui temas chaves, como: i) atributos de objetos, ii) manipulação de objetos unidimensionais e multidimensionais, iii) valores faltantes e especiais, iv) diretório de trabalho e v) importar, conferir e exportar dados tabulares. 5.4.1 Atributo dos objetos Quando fazemos atribuições de dados no R (&lt;-), os objetos gerados possuem três características. Nome: palavra que o R reconhece os dados atribuídos Conteúdo: dados em si Atributos: modos (natureza) e estruturas (organização) dos elementos Vamos explorar mais a fundo os modos e estruturas dos objetos. Vale ressaltar que isso é uma simplificação, pois há muitas classes de objetos, como funções e saídas de funções que possuem outros atributos. Podemos verificar os atributos dos objetos com a função attributes(). ## Atributos attributes(dune) ## $names ## [1] &quot;Achimill&quot; &quot;Agrostol&quot; &quot;Airaprae&quot; &quot;Alopgeni&quot; &quot;Anthodor&quot; &quot;Bellpere&quot; ## [7] &quot;Bromhord&quot; &quot;Chenalbu&quot; &quot;Cirsarve&quot; &quot;Comapalu&quot; &quot;Eleopalu&quot; &quot;Elymrepe&quot; ## [13] &quot;Empenigr&quot; &quot;Hyporadi&quot; &quot;Juncarti&quot; &quot;Juncbufo&quot; &quot;Lolipere&quot; &quot;Planlanc&quot; ## [19] &quot;Poaprat&quot; &quot;Poatriv&quot; &quot;Ranuflam&quot; &quot;Rumeacet&quot; &quot;Sagiproc&quot; &quot;Salirepe&quot; ## [25] &quot;Scorautu&quot; &quot;Trifprat&quot; &quot;Trifrepe&quot; &quot;Vicilath&quot; &quot;Bracruta&quot; &quot;Callcusp&quot; ## ## $row.names ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ## [15] &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; ## ## $class ## [1] &quot;data.frame&quot; Modo dos objetos A depender da natureza dos elementos que compõem os dados e que foram atribuídos aos objetos, esses objetos podem ser, de forma simples um dos cinco modos: numérico do tipo inteiro (integer), numérico do tipo flutuante (double), texto (character), lógico (logical) ou complexo (complex). A atribuição de números no R pode gerar dois tipos de modos: integer para números inteiros e double para números flutuantes ou com decimais. ## Numérico double obj_numerico_double &lt;- 1 ## Modo mode(obj_numerico_double) ## [1] &quot;numeric&quot; ## Tipo typeof(obj_numerico_double) ## [1] &quot;double&quot; A título de praticidade, ambos são incorporados como o modo numeric, com o tipo double, a menos que especifiquemos que seja inteiro com a letra L depois do número, representando a palavra Larger, geralmente usando para armazenar números muito grandes. ## Numérico integer obj_numerico_inteiro &lt;- 1L ## Modo mode(obj_numerico_inteiro) ## [1] &quot;numeric&quot; ## Tipo typeof(obj_numerico_inteiro) ## [1] &quot;integer&quot; Além de números, podemos atribuir textos, utilizando para isso aspas \"\". ## Caracter ou string obj_caracter &lt;- &quot;a&quot; # atencao para as aspas ## Modo mode(obj_caracter) ## [1] &quot;character&quot; Em algumas situações, precisamos indicar a ocorrência ou não de um evento ou uma operação. Para isso, utilizamos as palavras reservadas (TRUE e FALSE), chamadas de variáveis booleanas, pois assumem apenas duas possibilidades: falso (0) ou verdadeiro (1). Devemos nos ater para o fato dessas palavras serem escritas com letras maiúsculas e sem aspas. ## Lógico obj_logico &lt;- TRUE # maiusculas e sem aspas ## Modo mode(obj_logico) ## [1] &quot;logical&quot; Por fim, existe um modo pouco utilizado que cria números complexos (raiz de números negativos). ## Complexo obj_complexo &lt;- 1+1i ## Modo mode(obj_complexo) ## [1] &quot;complex&quot; Podemos verificar o modo dos objetos ou fazer a conversão entre esses modos com diversas funções. ## Verificar o modo dos objetos is.numeric() is.integer() is.character() is.logical() is.complex() ## Conversões entre modos as.numeric() as.integer() as.character() as.logical() as.complex() ## Exemplo num &lt;- 1:5 num mode(num) cha &lt;- as.character(num) cha mode(cha) Estrutura dos objetos Uma vez entendido a natureza dos modos dos elementos dos objetos no R, podemos passar para o passo seguinte e entender como esses elementos são estruturados dentro dos objetos. Essa estruturação irá nos contar sobre a organização dos elementos, com relação aos modos e dimensionalidade da disposição desses elementos. De modo bem simples, os elementos podem ser estruturados em cinco tipos: Vetores e fatores: homogêneo (um modo) e unidimensional (uma dimensão). Um tipo especial de vetor são os fatores, usados para designar variáveis categóricas Matrizes: homogêneo (um modo) e bidimensional (duas dimensões) Arrays: homogêneo (um modo) e multidimensional (mais de duas dimensões) Data frames: heterogêneo (mais de um modo) e bidimensional (duas dimensões) Listas: heterogêneo (mais de um modo) e unidimensional (uma dimensão) Figura 5.3: Estruturas de dados mais comuns no R: vetores, matrizes, arrays, listas e data frames. Adaptado de: R for Data Science (2e) . Vetor Vetores representam o encadeamento de elementos numa sequência unidimensional. Dessa forma, no R, essa estrutura de dados pode ser traduzida como medidas de uma variável numérica (discretas ou contínuas), variável binária (booleana - TRUE e FALSE) ou descrição (informações em texto). Há diversas formas de se criar um vetor no R: Concatenando elementos com a função c() Criando sequências unitárias : ou com a função seq() Criando repetições com a função rep() “Colar” palavras com uma sequência numérica com a função paste() ou paste0() Amostrando aleatoriamente elementos com a função sample() ## Concatenar elementos numéricos concatenar &lt;- c(15, 18, 20, 22, 18) concatenar ## [1] 15 18 20 22 18 ## Sequência unitária (x1:x2) sequencia &lt;- 1:10 sequencia ## [1] 1 2 3 4 5 6 7 8 9 10 ## Sequência com diferentes espaçamentos sequencia_esp &lt;- seq(from = 0, to = 100, by = 10) sequencia_esp ## [1] 0 10 20 30 40 50 60 70 80 90 100 ## Repetição repeticao &lt;- rep(x = c(TRUE, FALSE), times = 5) repeticao ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE ## Cola palavra e sequência numérica colar &lt;- paste(&quot;amostra&quot;, 1:5) colar ## [1] &quot;amostra 1&quot; &quot;amostra 2&quot; &quot;amostra 3&quot; &quot;amostra 4&quot; &quot;amostra 5&quot; ## Amostragem aleatória amostragem &lt;- sample(x = 1:100, size = 10) amostragem ## [1] 5 84 34 92 3 58 42 24 30 43 Como os vetores são homogêneos, i.e., só comportam um modo, quando combinamos mais de um modo no mesmo objeto ocorre uma dominância de modos. Existe, dessa forma, uma coerção dos elementos combinados para que todos fiquem iguais. Essa dominância segue essa ordem: DOMINANTE character &gt; double &gt; integer &gt; logical RECESSIVO Além disso, podemos utilizar as conversões listadas anteriormente para alterar os modos. Vamos exemplificar combinando os vetores criados anteriormente e convertendo-os. ## Coerção c(colar, amostragem) ## [1] &quot;amostra 1&quot; &quot;amostra 2&quot; &quot;amostra 3&quot; &quot;amostra 4&quot; &quot;amostra 5&quot; &quot;5&quot; ## [7] &quot;84&quot; &quot;34&quot; &quot;92&quot; &quot;3&quot; &quot;58&quot; &quot;42&quot; ## [13] &quot;24&quot; &quot;30&quot; &quot;43&quot; ## Conversão as.numeric(repeticao) ## [1] 1 0 1 0 1 0 1 0 1 0 Fator O fator representa medidas de uma variável categórica, podendo ser nominal ou ordinal. É fundamental destacar que fatores no R devem ser entendidos como um vetor de integer, i.e., ele é composto por números inteiros representando os níveis da variável categórica. Para criar um fator no R usamos uma função específica factor(), na qual podemos especificar os níveis com o argumento level, ou fazemos uma conversão usando a função as.factor(). Trabalhar com fatores no R Base não é das tarefas mais agradáveis, sendo assim, no Capítulo ?? usamos a versão tidyverse usando o pacote forcats. Destacamos ainda a existência de fatores nominais para variáveis categóricas nominais e fatores ordinais para variáveis categóricas ordinais, quando há ordenamento entre os níveis, como dias da semana ou classes de altura. ## Fator nominal fator_nominal &lt;- factor(x = sample(x = c(&quot;floresta&quot;, &quot;pastagem&quot;, &quot;cerrado&quot;), size = 20, replace = TRUE), levels = c(&quot;floresta&quot;, &quot;pastagem&quot;, &quot;cerrado&quot;)) fator_nominal ## [1] cerrado pastagem pastagem pastagem pastagem floresta floresta pastagem ## [9] pastagem cerrado cerrado floresta floresta pastagem pastagem pastagem ## [17] pastagem pastagem cerrado pastagem ## Levels: floresta pastagem cerrado ## Fator ordinal fator_ordinal &lt;- factor(x = sample(x = c(&quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;), size = 20, replace = TRUE), levels = c(&quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;), ordered = TRUE) fator_ordinal ## [1] baixa media alta media media media baixa baixa baixa alta baixa media ## [13] baixa baixa baixa alta alta baixa baixa media ## Levels: baixa &lt; media &lt; alta ## Conversão fator &lt;- as.factor(x = sample(x = c(&quot;floresta&quot;, &quot;pastagem&quot;, &quot;cerrado&quot;), size = 20, replace = TRUE)) fator ## [1] floresta pastagem pastagem pastagem floresta pastagem floresta pastagem ## [9] cerrado floresta floresta cerrado pastagem pastagem cerrado floresta ## [17] floresta pastagem cerrado pastagem ## Levels: cerrado floresta pastagem Matriz A matriz representa dados no formato de tabela, com linhas e colunas. As linhas geralmente representam unidades amostrais (locais, transectos, parcelas) e as colunas representam variáveis numéricas (discretas ou contínuas), variáveis binárias (TRUE ou FALSE) ou descrições (informações em texto). Podemos criar matrizes no R de duas formas. A primeira delas dispondo elementos de um vetor em um certo número de linhas e colunas com a função matrix(), podendo preencher essa matriz com os elementos do vetor por linhas ou por colunas alterando o argumento byrow. ## Vetor ve &lt;- 1:12 ## Matrix - preenchimento por linhas - horizontal ma_row &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE) ma_row ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 ## Matrix - preenchimento por colunas - vertical ma_col &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = FALSE) ma_col ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 A segundo forma, podemos combinar vetores, utilizando a função rbind() para combinar vetores por linha, i.e., um vetor embaixo do outro, e cbind() para combinar vetores por coluna, i.e., um vetor ao lado do outro. ## Criar dois vetores vec_1 &lt;- c(1, 2, 3) vec_2 &lt;- c(4, 5, 6) ## Combinar por linhas - vertical - um embaixo do outro ma_rbind &lt;- rbind(vec_1, vec_2) ma_rbind ## [,1] [,2] [,3] ## vec_1 1 2 3 ## vec_2 4 5 6 ## Combinar por colunas - horizontal - um ao lado do outro ma_cbind &lt;- cbind(vec_1, vec_2) ma_cbind ## vec_1 vec_2 ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Array O array representa combinação de tabelas, com linhas, colunas e dimensões. Essa combinação pode ser feita em múltiplas dimensões, mas apesar disso, geralmente é mais comum o uso em Ecologia para três dimensões, por exemplo: linhas (unidades amostrais), colunas (espécies) e dimensão (tempo). Isso gera um “cubo mágico” ou “cartas de um baralho”, onde podemos comparar, nesse caso, comunidades ao longo do tempo. Além disso, arrays também são muito comuns em morfometria geométrica ou sensoriamento remoto. Podemos criar arrays no R dispondo elementos de um vetor em um certo número de linhas, colunas e dimensões com a função array(). Em nosso exemplo, vamos compor cinco comunidades de cinco espécies ao longo de três períodos. ## Array ar &lt;- array(data = sample(x = c(0, 1), size = 75, rep = TRUE), dim = c(5, 5, 3)) ar ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 1 1 0 ## [2,] 0 0 1 0 0 ## [3,] 0 1 1 0 1 ## [4,] 1 0 0 1 1 ## [5,] 0 0 0 0 0 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 1 1 0 ## [2,] 1 0 0 1 1 ## [3,] 1 0 1 0 0 ## [4,] 0 0 1 0 1 ## [5,] 0 0 0 1 1 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 1 1 1 1 ## [2,] 1 1 1 0 1 ## [3,] 0 1 1 1 0 ## [4,] 1 1 0 1 0 ## [5,] 1 0 1 1 1 Data frame O data frame também representa dados no formato de tabela, com linhas e colunas, muito semelhante à matriz. Mas diferentemente das matrizes, os data frames comportam mais de um modo em suas colunas. Dessa forma, as linhas do data frame ainda representam unidades amostrais (locais, transectos, parcelas), mas as colunas agora podem representar descrições (informações em texto), variáveis numéricas (discretas ou contínuas), variáveis binárias (TRUE ou FALSE) e variáveis categóricas (nominais ou ordinais). A forma mais simples de se criar data frames no R é através da combinação de vetores. Essa combinação é feita com a função data.frame() e ocorre de forma horizontal, semelhante à função cbind(). Sendo assim, todos os vetores precisam ter o mesmo número de elementos, ou seja, o mesmo comprimento. Podemos ainda nomear as colunas de cada vetor. Outra forma, seria converter uma matriz em um data frame, utilizando a função as.data.frame(). ## Criar três vetores vec_ch &lt;- c(&quot;sp1&quot;, &quot;sp2&quot;, &quot;sp3&quot;) vec_nu &lt;- c(4, 5, 6) vec_fa &lt;- factor(c(&quot;campo&quot;, &quot;floresta&quot;, &quot;floresta&quot;)) ## Data frame - combinar por colunas - horizontal - um ao lado do outro df &lt;- data.frame(vec_ch, vec_nu, vec_fa) df ## vec_ch vec_nu vec_fa ## 1 sp1 4 campo ## 2 sp2 5 floresta ## 3 sp3 6 floresta ## Data frame - nomear as colunas df &lt;- data.frame(especies = vec_ch, abundancia = vec_nu, vegetacao = vec_fa) df ## especies abundancia vegetacao ## 1 sp1 4 campo ## 2 sp2 5 floresta ## 3 sp3 6 floresta ## Data frame - converter uma matriz ma &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE) ma ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 df_ma &lt;- as.data.frame(ma) df_ma ## V1 V2 V3 ## 1 1 2 3 ## 2 4 5 6 ## 3 7 8 9 ## 4 10 11 12 Lista A lista é um tipo especial de vetor que aceita objetos como elementos. Ela é a estrutura de dados utilizada para agrupar objetos, e é geralmente a saída de muitas funções. Podemos criar listas através da função list(). Essa função funciona de forma semelhante à função c() para a criação de vetores, mas agora estamos concatenando objetos. Podemos ainda nomear os elementos (objetos) que estamos combinando. Um ponto interessante para entender data frames, é que eles são listas, em que todos os elementos (colunas) possuem o mesmo número de elementos, ou seja, mesmo comprimento. ## Lista lista &lt;- list(rep(1, 20), # vector factor(1, 1), # factor cbind(c(1, 2), c(1, 2))) # matrix lista ## [[1]] ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## ## [[2]] ## [1] 1 ## Levels: 1 ## ## [[3]] ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 ## Lista - nomear os elementos lista_nome &lt;- list(vector = rep(1, 20), # vector factor = factor(1, 1), # factor matrix = cbind(c(1, 2), c(1, 2))) # matrix lista_nome ## $vector ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## ## $factor ## [1] 1 ## Levels: 1 ## ## $matrix ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 Funções Uma última estrutura de objetos criados no R são as funções. Elas são objetos criados pelo usuário e reutilizados para fazer operações específicas. A criação de funções geralmente é um tópico tratado num segundo momento, quando o usuário de R adquire certo conhecimento da linguagem. Aqui abordaremos apenas seu funcionamento básico, diferenciando sua estrutura para entendimento e sua diferenciação das demais estruturas. Vamos criar uma função simples que retorna a multiplicação de dois termos. Criaremos a função com o nome multi, à qual será atribuída uma função com o nome function(), com dois argumentos x e y. Depois disso abrimos chaves {}, que é onde iremos incluir nosso bloco de código. Nosso bloco de código é composto por duas linhas, a primeira contendo a operação de multiplicação dos argumento com a atribuição ao objeto mu e a segunda contendo a função return() para retornar o valor da multiplicação. ## Criar uma função multi &lt;- function(x, y){ mu &lt;- (x * y) return(mu) } multi ## function(x, y){ ## ## mu &lt;- (x * y) ## return(mu) ## ## } ## Uso da função multi(42, 23) ## [1] 966 5.4.2 Manipulação de objetos unidimensionais Vamos agora explorar formas de manipular elementos de objetos unidimensionais, ou seja, vetores, fatores e listas. A primeira forma de manipulação é através da indexação, utilizando os operadores []. Com a indexação podemos acessar elementos de vetores e fatores por sua posição. Utilizaremos números, sequência de números ou operações booleanas para retornar partes dos vetores ou fatores. Podemos ainda retirar elementos dessas estruturas com o operador aritmético -. No exemplo a seguir, iremos fixar o ponto de partida da amostragem da função sample(), utilizando a função set.seed(42) (usamos 42 porque é a resposta para a vida, o universo e tudo mais - O Guia do Mochileiro das Galáxias, mas poderia ser outro número qualquer). Isso permite que o resultado da amostragem aleatória seja igual em diferentes computadores. ## Fixar a amostragem set.seed(42) ## Amostrar 10 elementos de uma sequência ve &lt;- sample(x = seq(0, 2, .05), size = 10) ve ## [1] 1.80 0.00 1.20 0.45 1.75 0.85 1.15 0.30 1.90 0.20 ## Seleciona o quinto elemento ve[5] ## [1] 1.75 ## Seleciona os elementos de 1 a 5 ve[1:5] ## [1] 1.80 0.00 1.20 0.45 1.75 ## Retira o décimo elemento ve[-10] ## [1] 1.80 0.00 1.20 0.45 1.75 0.85 1.15 0.30 1.90 ## Retira os elementos 2 a 9 ve[-(2:9)] ## [1] 1.8 0.2 Podemos ainda fazer uma seleção condicional do vetor. Ao utilizarmos operadores relacionais, teremos como resposta um vetor lógico. Esse vetor lógico pode ser utilizado dentro da indexação para seleção de elementos. ## Quais valores sao maiores que 1? ve &gt; 1 ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE ## Selecionar os valores acima de 1 no vetor ve ve[ve &gt; 1] ## [1] 1.80 1.20 1.75 1.15 1.90 Além da indexação, temos algumas funções que nos auxiliam em algumas operações com objetos unidimensionais. Para listas, também podemos usar a indexação [] para acessar ou retirar elementos. ## Lista li &lt;- list(elem1 = 1, elem2 = 2, elem3 = 3) ## Acessar o primeiro elemento li[1] ## $elem1 ## [1] 1 ## Retirar o primeiro elemento li[-1] ## $elem2 ## [1] 2 ## ## $elem3 ## [1] 3 Podemos ainda usar a indexação dupla [[]] para acessar os valores desses elementos. ## Acessar o valor do primeiro elemento li[[1]] ## [1] 1 ## Acessar o valor do segundo elemento li[[2]] ## [1] 2 Para listas nomeadas, podemos ainda utilizar o operador $ para acessar elementos pelo seu nome. ## Acessar o primeiro elemento li$elem1 ## [1] 1 E ainda podemos utilizar funções para medir o comprimento dessa lista, listar os nomes dos elementos ou ainda renomear os elementos: length() e names(). ## Comprimento length(li) ## [1] 3 ## Nomes names(li) ## [1] &quot;elem1&quot; &quot;elem2&quot; &quot;elem3&quot; ## Renomear names(li) &lt;- paste0(&quot;elemento0&quot;, 1:3) li ## $elemento01 ## [1] 1 ## ## $elemento02 ## [1] 2 ## ## $elemento03 ## [1] 3 5.4.3 Manipulação de objetos multidimensionais Da mesma forma que para objetos unidimensionais, podemos manipular elementos de objetos multidimensionais, ou seja, matrizes, data frames e arrays. Novamente, a primeira forma de manipulação é através da indexação, utilizando os operadores []. Com a indexação podemos acessar elementos de matrizes, data frames e arrays por sua posição. Podemos ainda retirar elementos dessas estruturas com o operador aritmético -. Entretanto, agora temos mais de uma dimensão na estruturação dos elementos dentro dos objetos. Assim, utilizamos números, sequência de números ou operação booleanas para retornar partes desses objetos, mas as dimensões têm de ser explicitadas e separadas por vírgulas para acessar linhas e colunas. Essa indexação funciona para matrizes e data frames. Para arrays, especificamos também as dimensões, também separadas por vírgulas para acessar essas dimensões. ## Matriz ma &lt;- matrix(1:12, 4, 3) ma ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## Indexação ma[3, ] # linha 3 ## [1] 3 7 11 ma[, 2] # coluna 2 ## [1] 5 6 7 8 ma[1, 2] # elemento da linha 1 e coluna 2 ## [1] 5 ma[1, 1:2] # elementos da linha 1 e coluna 1 e 2 ## [1] 1 5 ma[1, c(1, 3)] # elementos da linha 1 e coluna 1 e 3 ## [1] 1 9 ma[-1, ] # retirar a linha 1 ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 3 7 11 ## [3,] 4 8 12 ma[, -3] # retirar a coluna 3 ## [,1] [,2] ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 Para data frames, além de utilizar números e/ou sequências de números dentro do operador [] simples, podemos utilizar o operador [[]] duplo para retornar apenas os valores de uma linha ou uma coluna. Se as colunas estiverem nomeadas, podemos utilizar o nome da coluna de interesse entre aspas dentro dos operadores [] (retornar coluna) e [[]] (retornar apenas os valores), assim como ainda podemos utilizar o operador $ para data frames. Essas últimas operações retornam um vetor, para o qual podemos fazer operações de vetores ou ainda atualizar o valor dessa coluna selecionada ou adicionar outra coluna. ## Criar três vetores sp &lt;- paste(&quot;sp&quot;, 1:10, sep = &quot;&quot;) abu &lt;- 1:10 flo &lt;- factor(rep(c(&quot;campo&quot;, &quot;floresta&quot;), each = 5)) ## data frame df &lt;- data.frame(sp, abu, flo) df ## sp abu flo ## 1 sp1 1 campo ## 2 sp2 2 campo ## 3 sp3 3 campo ## 4 sp4 4 campo ## 5 sp5 5 campo ## 6 sp6 6 floresta ## 7 sp7 7 floresta ## 8 sp8 8 floresta ## 9 sp9 9 floresta ## 10 sp10 10 floresta ## [] - números df[, 1] ## [1] &quot;sp1&quot; &quot;sp2&quot; &quot;sp3&quot; &quot;sp4&quot; &quot;sp5&quot; &quot;sp6&quot; &quot;sp7&quot; &quot;sp8&quot; &quot;sp9&quot; &quot;sp10&quot; ## [] - nome das colunas - retorna coluna df[&quot;flo&quot;] ## flo ## 1 campo ## 2 campo ## 3 campo ## 4 campo ## 5 campo ## 6 floresta ## 7 floresta ## 8 floresta ## 9 floresta ## 10 floresta ## [[]] - nome das colunas - retorna apenas os valores df[[&quot;flo&quot;]] ## [1] campo campo campo campo campo floresta floresta floresta ## [9] floresta floresta ## Levels: campo floresta ## $ funciona apenas para data frame df$sp ## [1] &quot;sp1&quot; &quot;sp2&quot; &quot;sp3&quot; &quot;sp4&quot; &quot;sp5&quot; &quot;sp6&quot; &quot;sp7&quot; &quot;sp8&quot; &quot;sp9&quot; &quot;sp10&quot; ## Operação de vetors length(df$abu) ## [1] 10 ## Converter colunas df$abu &lt;- as.character(df$abu) mode(df$abu) ## [1] &quot;character&quot; ## Adicionar ou mudar colunas set.seed(42) df$abu2 &lt;- sample(x = 0:1, size = nrow(df), rep = TRUE) df ## sp abu flo abu2 ## 1 sp1 1 campo 0 ## 2 sp2 2 campo 0 ## 3 sp3 3 campo 0 ## 4 sp4 4 campo 0 ## 5 sp5 5 campo 1 ## 6 sp6 6 floresta 1 ## 7 sp7 7 floresta 1 ## 8 sp8 8 floresta 1 ## 9 sp9 9 floresta 0 ## 10 sp10 10 floresta 1 Podemos ainda fazer seleções condicionais para retornar linhas com valores que temos interesse, semelhante ao uso de filtro de uma planilha eletrônica. ## Selecionar linhas de uma matriz ou data frame df[df$abu &gt; 4, ] ## sp abu flo abu2 ## 5 sp5 5 campo 1 ## 6 sp6 6 floresta 1 ## 7 sp7 7 floresta 1 ## 8 sp8 8 floresta 1 ## 9 sp9 9 floresta 0 df[df$flo == &quot;floresta&quot;, ] ## sp abu flo abu2 ## 6 sp6 6 floresta 1 ## 7 sp7 7 floresta 1 ## 8 sp8 8 floresta 1 ## 9 sp9 9 floresta 0 ## 10 sp10 10 floresta 1 Além disso, há uma série de funções para conferência e manipulação de dados que listamos na Tabela seguinte: 5.4.4 Valores faltantes e especiais Valores faltantes e especiais são valores reservados que representam dados faltantes, indefinições matemáticas, infinitos e objetos nulos. NA (Not Available): significa dado faltante ou indisponível NaN (Not a Number): representa indefinições matemáticas Inf (Infinito): é um número muito grande ou um limite matemático NULL (Nulo): representa um objeto nulo, sendo útil para preenchimento em aplicações de programação ## Data frame com elemento NA df &lt;- data.frame(var1 = c(1, 4, 2, NA), var2 = c(1, 4, 5, 2)) df ## var1 var2 ## 1 1 1 ## 2 4 4 ## 3 2 5 ## 4 NA 2 ## Resposta booleana para elementos NA is.na(df) ## var1 var2 ## [1,] FALSE FALSE ## [2,] FALSE FALSE ## [3,] FALSE FALSE ## [4,] TRUE FALSE ## Algum elemento é NA? any(is.na(df)) ## [1] TRUE ## Remover as linhas com NAs df_sem_na &lt;- na.omit(df) df_sem_na ## var1 var2 ## 1 1 1 ## 2 4 4 ## 3 2 5 ## Substituir NAs por 0 df[is.na(df)] &lt;- 0 df ## var1 var2 ## 1 1 1 ## 2 4 4 ## 3 2 5 ## 4 0 2 ## Desconsiderar os NAs em funções com o argumento rm.na = TRUE sum(1, 2, 3, 4, NA, na.rm = TRUE) ## [1] 10 ## NaN - not a number 0/0 ## [1] NaN log(-1) ## Warning in log(-1): NaNs produced ## [1] NaN ## Limite matemático 1/0 ## [1] Inf ## Número grande 10^310 ## [1] Inf ## Objeto nulo nulo &lt;- NULL nulo ## NULL 5.4.5 Diretório de trabalho O diretório de trabalho é o endereço da pasta (ou diretório) de onde o R importará ou exportar nossos dados. Podemos utilizar o próprio RStudio para tal tarefa, indo em Session &gt; Set Work Directory &gt; Choose Directory... ou simplesmente utilizar o atalho Ctrl + Shift + H. Podemos ainda utilizar funções do R para definir o diretório. Para tanto, podemos navegar com o aplicativo de gerenciador de arquivos (e.g., Windows Explorer) até nosso diretório de interesse e copiar o endereço na barra superior. Voltamos para o R e colamos esse endereço entre aspas como argumento da função setwd(). É fundamental destacar que no Windows é necessário inverter as barras (\\ por / ou duplicar elas \\\\). Aconselhamos ainda utilizar as funções getwd() para retornar o diretório definido na sessão do R, assim como as funções dir() ou list.files() para listagem dos arquivos no diretório, ambas medidas de conferência do diretório correto. ## Definir o diretório de trabalho setwd(&quot;/home/mude/data/github/livro_aer/dados&quot;) ## Verificar o diretório getwd() ## Listar os arquivos no diretório dir() list.files() 5.4.6 Importar dados Uma das operações mais corriqueiras do R, antes de realizar alguma análise ou plotar um gráfico, é a de importar dados que foram tabulados numa planilha eletrônica e salvos no formato .csv, .txt ou .xlsx. Ao importar esse tipo de dado para o R, o formato que o mesmo assume, se nenhum parâmetro for especificado, é o da classe data frame, prevendo que a planilha de dados possua colunas com diferentes modos. Existem diversas formas de importar dados para o R. Podemos importar utilizando o RStudio, indo na janela Environment e clicar em “Importar Dataset”. Entretanto, aconselhamos o uso de funções que fiquem salvas em um script para aumentar a reprodutibilidade do mesmo. Dessa forma, as três principais funções para importar os arquivos nos três principais extensões (.csv, .txt ou .xlsx) são, respectivamente: read.csv(), read.table() e openxlsx::read.xlsx(), sendo o último do pacote openxlsx. Para exemplificar como importar dados no R, vamos usar os dados de pinguins no Palmer Station, Antarctica Palmer Penguins. Faremos o download diretamente do site da fonte dos dados. Vamos antes escolher um diretório de trabalho com a função setwd(), e em seguida criar um diretório com a função dir.create() chamado “dados”. Em seguida, vamos mudar nosso diretório para essa pasta e criar mais um diretório chamado “tabelas”, e por fim, definir esse diretório para que o conteúdo do download seja armazenado ali. ## Escolher um diretório setwd(&quot;/home/mude/data/github/livro_aer&quot;) ## Criar um diretório &#39;dados&#39; dir.create(&quot;dados&quot;) ## Escolher diretório &#39;dados&#39; setwd(&quot;dados&quot;) ## Criar um diretório &#39;tabelas&#39; dir.create(&quot;tabelas&quot;) ## Escolher diretório &#39;tabelas&#39; setwd(&quot;tabelas&quot;) Agora podemos fazer o download do arquivo .csv e importar a tabela de dados. ## Download download.file(url = &quot;https://github.com/allisonhorst/palmerpenguins/blob/main/inst/extdata/penguins_raw.csv&quot;, destfile = &quot;penguins_raw.csv&quot;, method = &quot;curl&quot;) Agora podemos importar a tabela de dados com a função read.csv(), atribuindo ao objeto penguins_raw. ## Importar a tabela pinguins_raw &lt;- read.csv(&quot;dados/tabelas/penguins_raw.csv&quot;) Esse arquivo foi criado com separador de decimais sendo . e separador de colunas sendo ,. Caso tivesse sido criado com separador de decimais sendo , e separador de colunas sendo ;, usaríamos a função read.csv2(). Para outros formatos, basta usar as outras funções apresentadas, atentando-se para os argumentos específicos de cada função. Caso o download não funcione ou haja problemas com a importação, os dados estao também no pacote palmerpenguins. ## Importar os dados pelo pacote palmerpenguins pinguins_raw &lt;- palmerpenguins::penguins_raw head(pinguins_raw) ## # A tibble: 6 × 17 ## studyName `Sample Number` Species Region Island Stage `Individual ID` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PAL0708 1 Adelie Pengui… Anvers Torge… Adul… N1A1 ## 2 PAL0708 2 Adelie Pengui… Anvers Torge… Adul… N1A2 ## 3 PAL0708 3 Adelie Pengui… Anvers Torge… Adul… N2A1 ## 4 PAL0708 4 Adelie Pengui… Anvers Torge… Adul… N2A2 ## 5 PAL0708 5 Adelie Pengui… Anvers Torge… Adul… N3A1 ## 6 PAL0708 6 Adelie Pengui… Anvers Torge… Adul… N3A2 ## # ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;, ## # `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;, ## # `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;, ## # `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt; 5.4.7 Conferência dos dados importados Uma vez importados os dados para o R, geralmente antes de iniciarmos qualquer manipulação, visualização ou análise de dados, fazemos a conferência desses dados. Dentre todas as funções de verificação, destacamos a importância destas funções apresentadas abaixo para saber se as variáveis foram importadas e interpretadas corretamente e reconhecer erros de digitação, por exemplo: pinguins &lt;- palmerpenguins::penguins ## Primeiras linhas head(pinguins) ## # A tibble: 6 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; ## Últimas linhas tail(pinguins) ## # A tibble: 6 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Chinstrap Dream 45.7 17 195 3650 ## 2 Chinstrap Dream 55.8 19.8 207 4000 ## 3 Chinstrap Dream 43.5 18.1 202 3400 ## 4 Chinstrap Dream 49.6 18.2 193 3775 ## 5 Chinstrap Dream 50.8 19 210 4100 ## 6 Chinstrap Dream 50.2 18.7 198 3775 ## # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; ## Número de linhas e colunas nrow(pinguins) ## [1] 344 ncol(pinguins) ## [1] 8 dim(pinguins) ## [1] 344 8 ## Nome das linhas e colunas rownames(pinguins) colnames(pinguins) ## Estrutura dos dados str(pinguins) ## Resumo dos dados summary(pinguins) ## Verificar NAs any(is.na(pinguins)) which(is.na(pinguins)) ## Remover as linhas com NAs pinguins_na &lt;- na.omit(pinguins) Importante A função na.omit() retira a linha inteira que possui algum NA, inclusive as colunas que possuem dados que você não tem interesse em excluir. Dessa forma, tenha em mente quais dados você realmente quer remover da sua tabela. Além das funções apresentadas, recomendamos olhar os seguintes pacotes que ajudam na conferência dos dados importados: Hmisc, skimr e inspectDF. 5.4.8 Exportar dados Uma vez realizado as operações de manipulação ou tendo dados que foram analisados e armazenados num objeto no formato de data frame ou matriz, podemos exportar esses dados do R para o diretório que definimos anteriormente. Para tanto, podemos utilizar funções de escrita de dados, como write.csv(), write.table() e openxlsx::write.xlsx(). Dois pontos são fundamentais: i) o nome do arquivo tem de estar entre aspas e no final dele deve constar a extensão que pretendemos que o arquivo tenha, e ii) é interessante utilizar os argumentos row.names = FALSE e quote=FALSE, para que o arquivo escrito não tenha o nome das linhas ou aspas em todas as células, respectivamente. ## Exportar dados na extensão .csv write.csv(pinguins_na, &quot;pinguins_na.csv&quot;, row.names = FALSE, quote = FALSE) ## Exportar dados na extensão .txt write.table(pinguins_na, &quot;pinguins_na.txt&quot;, row.names = FALSE, quote = FALSE) ## Exportar dados na extensão .xlsx openxlsx::write.xlsx(pinguins_na, &quot;pinguins_na.xlsx&quot;, row.names = FALSE, quote = FALSE) 5.5 Para se aprofundar Listamos a seguir livros e links com material que recomendamos para seguir com sua aprendizagem em R Base. 5.5.1 Livros Recomendamos aos (às) interessados(as) os livros: i) Crawley The R Book, ii) Davies The Book of R: A First Course in Programming and Statistics, iii) Gillespie e Lovelace Efficient R programming, iv) Holmes e Huber Modern Statistics for Modern Biology, v) Irizarry e Love Data Analysis for the Life Sciences with R, vi) James e colaboradores An Introduction to Statistical Learning: with Applications in R, vii) Kabacoff R in Action: Data analysis and graphics with R, viii) Matloff The Art of R Programming: A Tour of Statistical Software Design, ix) Long e Teetor R Cookbook e x) Wickham Advanced R. 5.5.2 Links Existem centenas de ferramentas online para aprender e explorar o R. Dentre elas, indicamos os seguintes links (em português e inglês): Introdução ao R An Introduction to R - Douglas A, Roos D, Mancini F, Couto A, Lusseau D A (very) shortintroduction to R - Paul Torfs &amp; Claudia Brauer R for Beginners - Emmanuel Paradis Ciência de dados - Ciência de Dados em R - Curso-R - Data Science for Ecologists and Environmental Scientists - Coding Club Estatística - Estatística Computacional com R - Mayer F. P., Bonat W. H., Zeviani W. M., Krainski E. T., Ribeiro Jr. P. J - Data Analysis and Visualization in R for Ecologists - Data Carpentry Miscelânea Materiais sobre R - Beatriz Milz R resources (free courses, books, tutorials, &amp; cheat sheets) - Paul van der Laken 5.6 Exercícios 4.1 Use o R para verificar o resultado da operação 7 + 7 ÷ 7 + 7 x 7 - 7. 4.2 Verifique através do R se 3x2³ é maior que 2x3². 4.3 Crie dois objetos (qualquer nome) com os valores 100 e 300. Multiplique esses objetos (função prod()) e atribuam ao objeto mult. Faça o logaritmo natural (função log()) do objeto mult e atribuam ao objeto ln. 4.4 Quantos pacotes existem no CRAN nesse momento? Execute essa combinação no Console: nrow(available.packages(repos = \"http://cran.r-project.org\")). 4.5 Instale o pacote tidyverse do CRAN. 4.6 Escolha números para jogar na mega-sena usando o R, nomeando o objeto como mega. Lembrando: são 6 valores de 1 a 60 e atribuam a um objeto. 4.7 Crie um fator chamado tr, com dois níveis (“cont” e “trat”) para descrever 300 locais de amostragem, 15 de cada tratamento. O fator deve ser dessa forma cont, cont, cont, ...., cont, trat, trat, ...., trat. 4.8 Crie uma matriz chamada ma, resultante da disposição de um vetor composto por 130 valores aleatórios entre 0 e 10. A matriz deve conter 100 linhas e ser disposta por colunas. 4.9 Crie um data frame chamado df, resultante da composição desses vetores: id: 1:30 sp: sp01, sp02, ..., sp29, sp30 ab: 30 valores aleatórios entre 0 a 5 4.10 Crie uma lista com os objetos criados anteriormente: mega, tr, ma e df. 4.11 Selecione os elementos ímpares do objeto tr e atribua ao objeto tr_impar. 4.12 Selecione as linhas com ids pares do objeto df e atribua ao objeto df_ids_par. 4.13 Faça uma amostragem de 10 linhas do objeto df e atribua ao objeto df_amos10. Use a função set.seed() para fixar a amostragem. 4.14 Amostre 10 linhas do objeto ma, mas utilizando as linhas amostradas do df_amos10 e atribua ao objeto ma_amos10. 4.15 Una as colunas dos objetos df_amos10 e ma_amos10 e atribua ao objeto dados_amos10. Soluções dos exercícios. Organize following: https://jakubnowosad.com/posts/2020-05-26-intro-to-landscape-ecology/ https://youtu.be/dCTOGDnDuvM at 28 minutes Attribute data operations - Vector attribute subsetting, aggrergatyion and joins - Creating new vector attributes - Raster subsetting - Summarizing raster objects Spatial data operations - Spatial subsetting - Topological relations - Spatial joining - - zonal raster operations Geometry operations - on vector - on raster - Vector-raster interactions Coordinate reference systems - Understaning map projections - Reprojecting spatial data - Modifying map projections "],["primeiros-passos-com-uma-raster.html", "Capítulo 6 Primeiros passos com uma raster", " Capítulo 6 Primeiros passos com uma raster Uma raster é um matriz de valores com coordenadas geográficos. Cada pixel de uma raster representa uma região geográfica, e o valor do pixel representa uma característica dessa região (mais sobre dados raster). Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, terra, sf, mapview, tmap. Carregar pacotes: library(tidyverse) library(terra) library(sf) library(mapview) library(tmap) Inicialmente iremos gerar uma raster representando uma paisagem bem simples, de 6 por 6 pixels. Você já deve saber que pixel é a unidade básica de uma imagem (lembra da camera do seu celular, 10Mb ou algo assim?!). Vocês devem ter visto sobre pixels e resolução no mesmo em aulas de geoprocessamento. Aqui podemos tratar o pixel como a resolução. Vamos dizer que temos um pixel de 10 metros (res=10 no bloco de código), ou seja, uma quadrado de 10 por 10m, sendo essa, a menor unidade mapeável. Assim sendo, a resolução tambem tem ligação com escala cartográfica! Vamos gerar e plotar uma paisagem simples em 4 passos. Primeiramente, a função rast cria um objeto do tipo raster. E depois a função values atribui valores, e na sequencia vamos visualisar os valores com plot e text . #Função &quot;rast&quot; gera a paisagem virtual (paisagem simulado) pai_sim &lt;- rast(ncols=6, nrows=6, xmin=1, xmax=60, ymin=1, ymax=60, res=10) #E essa atribui valores (&quot;values&quot;) para os pixels criados acima values(pai_sim) &lt;- 1 plot(pai_sim) #Essa plota text(pai_sim) #Essa coloca os valores dos pixels Figura 6.1: Paisagem simples de 36 pixels. 6.0.1 Obter e carregar dados (raster) Mais uma vez vamos aproveitar os dados de MapBiomas. Agora baixar arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 3.3 MB). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif . Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “utm_cover_AP_rio_2020.tif”: meuSIGr &lt;- file.choose() O código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”. mapbiomas_2020 &lt;- rast(meuSIGr) 6.0.2 Reclassificação Para simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente). # criar uma nova camada de floresta floresta_2020 &lt;- mapbiomas_2020 # Com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar categorias florestais agrupados com valor de 1 floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 Vizualizar para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, text.color = &quot;white&quot;, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;),legend.bg.color = &quot;white&quot;) Figura 6.2: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. "],["primeiros-passos-com-vector.html", "Capítulo 7 Primeiros passos com vector 7.1 Obter e carregar dados (vectores) 7.2 Visualizar os arquivos (camadas vector)", " Capítulo 7 Primeiros passos com vector Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, sf, mapview, tmap. Carregar pacotes: library(tidyverse) library(sf) library(mapview) library(tmap) 7.1 Obter e carregar dados (vectores) Precisamos carregar os dados para rios e pontos de amostragem. Baixar arquivo (vector) com os dados (formato “GPKG”, tamanho 54.9 MB). Mais sobre dados vetoriais. O formato aberto GeoPackage é um contêiner que permite armazenar dados SIG (feições/camadas) em um único arquivo. Por exemplo, um arquivo GeoPackage pode conter vários dados (dados vetoriais e raster) em diferentes sistemas de coordenadas. Todos esses recursos permitem que você compartilhe dados facilmente e evite a duplicação de arquivos. Baixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.gpkg . Lembrando-se de salvar o arquivo (“rivers.gpkg”) em um local conhecido no seu computador. O formato “GPKG” e diferente de “tif” (raster), o processo de importação é, portanto, diferente. Primeira, avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “rivers.GPKG”: meuSIG &lt;- file.choose() Agora vamos olhar o que tem no arquivo. Depois que voces rodar o codigo st_layers(meuSIG), o resultado mostra que o arquivo rivers.GPKG inclui camadas diferentes com pontos (“Point”), linhas (“Line String”) e polígonos (“Polygon”). Alem disso, a coluna “crs_name” mostrar que a sistema de coordenadas é geográfica (WGS84, (EPSG: 4326)\\[https://epsg.io/4326\\], e é diferente do arquivo raster: sf::st_layers(meuSIG) ## Driver: GPKG ## Available layers: ## layer_name geometry_type features fields crs_name ## 1 centerline Line String 52 15 WGS 84 ## 2 forestloss Point 276086 12 WGS 84 ## 3 canalpoly Polygon 3 6 WGS 84 ## 4 extentpoly50km Polygon 1 0 WGS 84 ## 5 midpoints Point 52 17 WGS 84 ## 6 midpoints_hansen Point 52 37 WGS 84 ## 7 cachoeira_caldeirao Point 1 2 WGS 84 ## 8 porto_grande Point 1 1 WGS 84 ## 9 icmbio_base Point 1 1 WGS 84 ## 10 direct_affect Polygon 1 2 WGS 84 ## 11 midpoints_hansen_distances Point 52 43 WGS 84 ## 12 midpoints_hansen_ffr Point 52 82 WGS 84 ## 13 midpoints_hansen_ffril Point 52 91 WGS 84 ## 14 direct_affect_line Line String 1 2 WGS 84 Nós só precisamos de duas dessas camadas. O código abaixo vai carregar as camadas que precisamos e criar os objetos “rsm” e “rsl”. Assim, agora temos dados com: pontos cada 5 km ao longo os rios (“rsm”) e a linha central de rios (“rsl”). # pontos cada 5 km rsm &lt;- sf::st_read(meuSIG, layer = &quot;midpoints&quot;) ## Reading layer `midpoints&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 17 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -52.01259 ymin: 0.7175827 xmax: -51.29688 ymax: 1.330365 ## Geodetic CRS: WGS 84 # linha central de rios rsl &lt;- sf::st_read(meuSIG, layer = &quot;centerline&quot;) ## Reading layer `centerline&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 15 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -52.01443 ymin: 0.7094595 xmax: -51.2924 ymax: 1.352094 ## Geodetic CRS: WGS 84 7.2 Visualizar os arquivos (camadas vector) Visualizar para verificar. Mapa com linha central e pontos de rios em trechos de 5km. ggplot(rsl) + geom_sf(aes(color=rio)) + geom_sf(data = rsm, shape=21, aes(fill=zone)) Figura 7.1: Pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Mapa interativo (funcione somente com internet). Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc) # mapview(rsl, zcol = &quot;rio&quot;) Em andamento ………….. "],["bibliografia.html", "Bibliografia", " Bibliografia "],["annexo-1.html", "A Annexo 1 A.1 Download mapbiomas cover A.2 Crop mapbiomas cover A.3 Plot with legend", " A Annexo 1 Exemplos de código R usado para - baixar Mapbiomas, - recortar para uma região de interesse - plotar com legenda library(plyr) library(tidyverse) library(terra) library(sf) library(readxl) library(tmap) A.1 Download mapbiomas cover Site: https://brasil.mapbiomas.org/colecoes-mapbiomas/. Any zeros are NA (NODATA). http://forum.mapbiomas.ecostage.com.br/t/pixels-com-valor-zero/170/5 . And “27” “Não observado”. No exemplo os arquivos vai ficar no working directory. #Get mapbiomas data # url_text &lt;- &quot;https://storage.googleapis.com/mapbiomas-public/initiatives/brasil/collection_8/lclu/coverage/&quot; layer_names &lt;- paste(&quot;brasil_coverage_&quot;,1985:2022, sep=&quot;&quot;) file_type &lt;- &quot;.tif&quot; filenames_mapbioma_8 &lt;- paste(layer_names, file_type, sep=&quot;&quot;) urlnames_mapbioma_8 &lt;- paste(url_text, layer_names, file_type, sep=&quot;&quot;) #set timeout to 20 minutes as big files and teeny tiny internet connection options(timeout = max((60*20), getOption(&quot;timeout&quot;))) # test with one year - 1985 res &lt;- utils::download.file(url=urlnames_mapbioma_8[1], destfile=filenames_mapbioma_8[1], method=&quot;auto&quot;, quiet = FALSE, mode = &quot;wb&quot;, cacheOK = TRUE) #make list dflist &lt;- data.frame(layer_names = layer_names, urls = urlnames_mapbioma_8, filenames = filenames_mapbioma_8) alist &lt;- split(dflist, f = dflist$layer_names) #make function to automatically process list elements get_mapbiomas &lt;- function(x){ res &lt;- utils::download.file(url=x$urls, destfile=x$filenames, method=&quot;auto&quot;, quiet = FALSE, mode = &quot;wb&quot;, cacheOK = TRUE) res } #run function in blocks lapply(alist[2], get_mapbiomas) lapply(alist[3:5], get_mapbiomas) lapply(alist[6:8], get_mapbiomas) lapply(alist[9:20], get_mapbiomas) lapply(alist[21:30], get_mapbiomas) lapply(alist[31:37], get_mapbiomas) A.2 Crop mapbiomas cover Identify all tif files in a folder. #works one folder at a time get_files &lt;- function(folder_name = NA) { library(tidyverse) folder_location &lt;- folder_name in_files &lt;- list.files(folder_location, pattern = &quot;.tif&quot;, full.names = TRUE) data.frame(folder_id = folder_location, file_id = in_files) |&gt; group_by(folder_id, file_id) |&gt; dplyr::summarise(file_count = dplyr::n()) |&gt; ungroup() -&gt; df_muni_tif return(df_muni_tif) } infolder &lt;- &quot;E:/mapbiomas&quot; df_muni_tif &lt;- get_files(folder_name = infolder) #update df_muni_tif |&gt; dplyr::mutate(state_code = str_sub(folder_id, -2, -1), ) -&gt; df_muni_tif df_muni_tif$state_code &lt;- &quot;AP&quot; Area of interest - format extent for use by terra. #extent from 50 km arouund river upstream of cachoeira caldeirao meuSIG &lt;- file.choose() #&quot;C:\\\\Users\\\\Darren\\\\Documents\\\\gisdata\\\\vector\\\\rivers.GPKG&quot; # &quot;C:\\\\Users\\\\user\\\\Documents\\\\Articles\\\\gis_layers\\\\gisdata\\\\inst\\\\vector\\\\rivers.gpkg&quot; rsl &lt;- st_read(meuSIG, layer = &quot;centerline&quot;) rsl_50km &lt;- st_union(st_buffer(rsl, dist=50000)) myexent &lt;- ext(vect(rsl_50km)) Now to crop and project to desired coordinate system (epsg:31976). # This function reads in file, crops and projects to new coordinate system. # Then exports resutl as Geotiff (.tif). crop_proj &lt;- function(x, state_id = NA, sf_state = NA) { library(plyr) library(tidyverse) library(terra) library(sf) library(stringi) state_sigla = x$state_code rin &lt;- x$file_id rbig &lt;- terra::rast(rin) layer_name &lt;- names(rbig) layer_year &lt;- stri_sub(layer_name,-4,-1) out_name &lt;- paste(&quot;mapbiomas_cover&quot;, layer_year, sep=&quot;_&quot;) e2 &lt;- myexent #Crop rtest_mask &lt;- crop(rbig, e2, snap=&quot;out&quot;) #rtest_mask &lt;- rbig rm(&quot;rbig&quot;) #Project new_crs_utm &lt;- &quot;epsg:31976&quot; rtest_mask &lt;- project(rtest_mask, new_crs_utm, method = &quot;near&quot;) names(rtest_mask) &lt;- out_name #Export #folder &lt;- paste(state_sigla,&quot;_&quot;, &quot;equalarea&quot;, sep =&quot;&quot;) #folder_utm &lt;- paste(state_sigla,&quot;_&quot;, &quot;utm&quot;, sep =&quot;&quot;) #folder_utm_muninorte &lt;- paste(state_sigla,&quot;_&quot;, &quot;utm_muni_norte&quot;, sep =&quot;&quot;) #folder_utm_munimaza &lt;- paste(state_sigla,&quot;_&quot;, &quot;utm_munis_maza_santana&quot;, sep =&quot;&quot;) #folder_utm_cutias &lt;- paste(state_sigla,&quot;_&quot;, &quot;utm_muni_cutias&quot;, sep =&quot;&quot;) #folder_path &lt;- paste(&quot;C:/Users/Darren/Documents/2022_Norris_gdp_deforestaion/AmazonConservation/mapbiomas_ge/state_cover/&quot;, folder_utm_cutias, sep = &quot;&quot;) #outfile &lt;- paste(&quot;ea_cover_&quot;, state_sigla,&quot;_&quot;, # layer_year, &quot;.tif&quot;, sep = &quot;&quot;) folder_utm_rio &lt;- paste(state_sigla,&quot;_&quot;, &quot;utm_rio&quot;, sep =&quot;&quot;) outfile_utm &lt;- paste(&quot;utm_cover_AP_rio_&quot;,layer_year, &quot;.tif&quot;, sep = &quot;&quot;) f &lt;- file.path(folder_utm_rio, outfile_utm) writeRaster(rtest_mask, f, datatype = &quot;INT1U&quot;, NAflag=27, gdal=c(&quot;COMPRESS=DEFLATE&quot;), overwrite = TRUE) #clear temporary files tmpFiles(current =TRUE, remove = TRUE) endtime &lt;- Sys.time() textout &lt;- paste(outfile_utm, &quot;: &quot;, endtime, sep=&quot;&quot;) print(textout) } #run plyr::a_ply(df_muni_tif, .margins = 1, .fun = crop_proj) A.3 Plot with legend Combine all years into multi layer raster. infolder_rio &lt;- &quot;E:/mapbiomas/AP_utm_rio&quot; df_tif_rio &lt;- get_files(folder_name = infolder_rio) r85a22 &lt;- rast(df_tif_rio$file_id) writeRaster(r85a22, &quot;utm_cover_AP_rio_85a22.tif&quot;, datatype = &quot;INT1U&quot;, NAflag=27, gdal=c(&quot;COMPRESS=DEFLATE&quot;), overwrite = TRUE) Legend. mapbiomas8_legenda &lt;- read.csv2(&quot;legend/Codigos-da-legenda-colecao-8.csv&quot;) Plot. class_vals &lt;- mapbiomas8_legenda$Class_ID class_color &lt;- mapbiomas8_legenda$Color names(class_color) &lt;- mapbiomas8_legenda$Class_ID #labels my_label &lt;- mapbiomas8_legenda$Descricao names(my_label) &lt;- mapbiomas8_legenda$Class_ID # Plot one year to check tm_shape(subset(r85a22n_ag, c(1, 2, 37,38))) + tm_raster(style = &quot;cat&quot;, palette = class_color, labels = my_label, title=&quot;&quot;) + tm_scale_bar(breaks = c(0, 10), text.size = 1, position=c(&quot;right&quot;, &quot;bottom&quot;)) # Now all years together. tm_shape(r85a22n_ag) + tm_raster(style = &quot;cat&quot;, palette = class_color, labels = my_label, title=&quot;&quot;) + tm_scale_bar(breaks = c(0, 10), text.size = 1, position=c(&quot;right&quot;, &quot;bottom&quot;)) + tm_facets(ncol=5) + tm_layout(legend.bg.color=&quot;white&quot;, legend.outside = TRUE, legend.outside.position = &quot;right&quot;, panel.labels = c(&#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;,&#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;, &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;,&#39;1996&#39;, &#39;1997&#39;, &#39;1998&#39;, &#39;1999&#39;, &#39;2000&#39;, &#39;2001&#39;, &#39;2002&#39;, &#39;2003&#39;, &#39;2004&#39;, &#39;2005&#39;, &#39;2006&#39;, &#39;2007&#39;, &#39;2008&#39;, &#39;2009&#39;, &#39;2010&#39;, &#39;2011&#39;, &#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;, &#39;2016&#39;, &#39;2017&#39;, &#39;2018&#39;, &#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;, &#39;2022&#39;)) -&gt; figmap png(&quot;figmap.png&quot;, width=6, height=9, units=&quot;in&quot;, res = 600) figmap invisible(dev.off()) "],["soluções-de-exercícios.html", "B Soluções de exercícios", " B Soluções de exercícios "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
