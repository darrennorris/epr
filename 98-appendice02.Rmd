
# Annexo 2

Exemplos de código R usado para 
Geoprocessing to calculate variables for landscape modelling.
Forest cover, distances to humans, distances to water etc.


```{r packages-needed, echo=TRUE, eval=FALSE}
library(plyr)
library(tidyverse)
library(terra)
library(geodata)
library(sf)
library(readxl)
library(tmap)
library(nngeo)
library(rnaturalearth)
library(rnaturalearthdata)
library(rnaturalearthhires)
```

Use Mapbiomas to get map of anthropogenic class across Amapa state.
Aggregated to be compatiable with 
Imazon PrevisIA áreas sob risco de desmatamento na Amazônia: https://previsia.org.br/

```{r packages-needed, echo=TRUE, eval=FALSE}
# to calculate:
# distance to risk of future deforestation (previsa)
# distance to open water (mapbiomas)
# distance to human use (mapbiomas)
# distance to human residence (ibge)
# amazon and cerrado (mapbiomas)
previsia_22 <- rast("data/raster/previsia_2022.tif")
# replace NA's by zero so have continuous cover across land
# NA include water which cannot be deforestated
previsia_22[is.na(previsia_22[])] <- 0 
crs(previsia_22)

# crop to Amapa
#extent from municiapality boundary
longname <- "data/vector/brazil_ninestate/ninestate_poly.shp"
sf_states <- sf::st_read(longname) |> 
  filter(SIGLA_UF == "AP") |> 
  st_transform(terra::crs(previsia_22))
ap_1km <- st_union(st_buffer(sf_states, dist=1000))
ap_1km |> 
  st_transform(crs(ap_1km)) -> ap_1km_4326
#crop coastline
brazil <- ne_countries(country = "Brazil", scale = 10,
                             returnclass = "sf")
# crop to Amapa (just mainland, excludes islands)
ap_close <- crop(vect(ap_1km_4326), vect(brazil))
ap_poly <- st_cast(st_as_sf(ap_close), "POLYGON")
ap_poly$area_km2 <- as.numeric(st_area(ap_poly))/1000000
ap_poly |> 
  filter(area_km2 > 140000) -> ap_crop
 
previsia_22_ap <- crop(previsia_22, vect(ap_1km), mask = TRUE, 
                       snap="out")
names(previsia_22_ap) <- "risco"

# Plot to check
tm_shape(previsia_22_ap) +
  tm_raster(style = "pretty", palette = rev(viridis::viridis(6))) + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "bottom")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "bottom")) +
tm_layout(legend.position = c("left","top"), legend.bg.color="white")


```

Now reclassify.
```{r reclass-previsia}

#reclassify binary (0 = no risk (<0.001), 1 = risk (>=0.001))
m <- c(0, 0.005, 0,
       0.005, 1, 1)
rclmat <- matrix(m, ncol=3, byrow=TRUE)
previsia_22_ap_risk <- classify(previsia_22_ap, rclmat, include.lowest=TRUE)
# plot to check
tm_shape(previsia_22_ap_risk) +
  tm_raster(style = "cat") + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "bottom")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "bottom")) +
tm_layout(legend.position = c("left","top"), legend.bg.color="white")
```

Calculate distances
```{r distance-previsia}

d_risk <- distance(previsia_22_ap_risk, target=0) 
names(d_risk) <- "risk_dist_m"
# plot to check
tm_shape(d_risk/1000) +
  tm_raster(palette = rev(viridis::viridis(100)), 
            n=100, legend.show = FALSE) + 
  #  tm_raster(palette = rev(viridis::viridis(10)), 
  #          n=10) +
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "top")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "top")) +
tm_layout(legend.position = c("left","bottom"), legend.bg.color="white")
```

Mapbiomas.
```{r mapbiomas-amapa}
# distance to open water (mapbiomas)
# distance to human (mapbiomas)
# amazon and cerrado (mapbiomas)

# load and crop mapbiomas
mapbiomas_22 <- rast("E:\\mapbiomas\\brasil_coverage_2022.tif")
# crop to Amapa
mapbiomas_22_ap <- crop(mapbiomas_22, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
rm("mapbiomas_22")

```

Mapbiomas Human (should use modal for 3 years to make more reliable).
```{r mapbiomas-human}

# legend 
#"C:\\Users\\user\\Documents\\rbooks\\epr\\data\\raster\\mapbiomas\\legend\\Codigos-da-legenda-colecao-8.csv"
maplegend <- read.csv2("data/raster/mapbiomas/legend/Codigos-da-legenda-colecao-8.csv")
# two column matrix ("is", "becomes").
# Split anthro into two so can remove anomolus points 
# in middle of forest
class_anthro <- c(14, 15, 18, 19,39, 20, 40, 62, 41, 36, 46, 47, 35, 48, 9, 21,31)
new_anthro <- rep(14, length(class_anthro))
# 24 = urban, 30 = mining
class_anthro_strong <- c(24,30)
new_anthro_strong <- rep(24, length(class_anthro_strong))
class_water <- c(26, 33)
new_water <- rep(26, length(class_water))
dfclass <- data.frame(old = c(class_anthro, class_anthro_strong,
                              class_water), 
                      new = c(new_anthro, new_anthro_strong, 
                              new_water))
m <- as.matrix(dfclass)
# ok apply to all
mapbiomas_22_ap_reclass <- classify(mapbiomas_22_ap, m)
unique(mapbiomas_22_ap_reclass)

# Reclassificação - 
# Criar uma nova camada de floresta (novo objeto de raster copiando mapbiomas_2022, 
# assim para ter os mesmos coordenados, resolução e extensão)
human_2022 <- mapbiomas_22_ap_reclass
# Todos os pixels com valor de 0
values(human_2022) <- 0
# Atualizar com valor de 1 quando pixels originais são de antropico
human_2022[mapbiomas_22_ap_reclass==14] <- 1 
unique(human_2022)
# strong human
human_strong_2022 <- mapbiomas_22_ap_reclass
# Todos os pixels com valor de 0
values(human_strong_2022) <- 0
# Atualizar com valor de 1 quando pixels originais são de antropico
human_strong_2022[mapbiomas_22_ap_reclass==24] <- 1 
unique(human_strong_2022)

same.crs(human_2022, previsia_22_ap_risk) # TRUE
rs_human_2022 <- resample(human_2022, previsia_22_ap_risk, 
                          method = "near")
rs_human_2022 <- crop(rs_human_2022, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
rs_human_strong_2022 <- resample(human_strong_2022,
                              previsia_22_ap_risk, 
                          method = "max")
rs_human_strong_2022 <- crop(rs_human_strong_2022,
                             vect(ap_1km_4326), 
                        mask = TRUE, snap="out")

tmp <- rs_human_2022 + rs_human_strong_2022
rs_human_final <- tmp
values(rs_human_final) <- 0
# Atualizar com valor de 1 quando pixels originais são de antropico
rs_human_final[tmp==1 | tmp == 2] <- 1
# crop to Amapa
rs_human_final <- crop(rs_human_final, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
# Plot to check
tm_shape(rs_human_final) +
  tm_raster(style = "cat") + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "bottom")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "bottom")) +
tm_layout(legend.position = c("left","top"), legend.bg.color="white")

# Now calculate distance
d_human <- distance(rs_human_final, target=0) 
names(d_human) <- "human_dist_m"
# plot to check
tm_shape(d_human/10000) +
  tm_raster(palette = rev(viridis::viridis(100)), 
            n=100, legend.show = FALSE) + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "top")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "top")) +
tm_layout(legend.position = c("left","bottom"), legend.bg.color="white")

```

Strong human - urban and mining. Integrate mapbiomas and IBGE.
Need to include at least all municipality capitals.
```{r strong-human}

#Mapbiomas. No. Includes a mix of classes.
urban_2022 <- mapbiomas_22_ap_reclass
# Todos os pixels com valor de 0
values(urban_2022) <- 0
# Atualizar com valor de 1 quando pixels originais são de antropico
urban_2022[mapbiomas_22_ap_reclass==24] <- 1 
urban_2022 <- resample(human_2022, previsia_22_ap_risk, 
                          method = "near")

urban_2022 <- crop(urban_2022, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
urban_2022 <- crop(urban_2022, vect(brazil), 
                        mask = TRUE, snap="out")

#IBGE 
ibge_file <- "E:\\IBGE\\bc250\\bc250_2021_11_18\\bc250_2021_11_18.gpkg"
st_layers(ibge_file)
# permanent human habitation - 
# lml_aglomerado_rural_p, lml_cidade_p, 
# lml_vila_p, # lml_area_densamente_edificada_a
aglomerado <- st_read(ibge_file, layer = "lml_aglomerado_rural_p") |> 
  st_transform(4326) |> 
  st_intersection(ap_crop) |> st_buffer(1000) |> st_union() |> 
  st_make_valid()
cidade <- st_read(ibge_file, layer = "lml_cidade_p") |> 
  st_transform(4326) |> 
  st_intersection(ap_crop) |> st_buffer(1000) |> st_union() |> 
  st_make_valid() 
vila <- st_read(ibge_file, layer = "lml_vila_p") |> 
  st_transform(4326) |> 
  st_intersection(ap_crop) |> st_buffer(1000) |> st_union() |> 
  st_make_valid()
edif <- st_read(ibge_file, layer = "lml_area_densamente_edificada_a") |> 
  st_make_valid() |>
  st_transform(4326) |> st_intersection(ap_crop) |> st_union() |> 
  st_make_valid()
# union
aglomerado |> 
  st_union(cidade) |> st_make_valid() |>
  st_union(vila) |> st_make_valid() |> st_union(edif) |> 
  st_make_valid()-> sf_human

# to sf
d <- data.frame(avalue = 1)
d$geom = sf_human
sf_human = st_as_sf(d, crs=4326)

# rastreize and distances
r <- rast(previsia_22_ap_risk)
human_2021 <- rasterize(vect(sf_human), r, "avalue", fun="max", 
                         touches = TRUE)
human_2021[is.na(human_2021[])] <- 0
human_2021 <- crop(human_2021, vect(ap_1km_4326), mask=TRUE, snap="out")
# Now calculate distance
d_resident <- distance(human_2021, target=0) 
d_resident <- crop(d_resident, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
names(d_resident) <- "resident_dist_m"

```


Most dominant forest types.
```{r forest-cover}

forest <- mapbiomas_22_ap
values(forest) <- 0
# Atualizar com valor de 3 quando pixels originais são de floresta
# Reclassified to represent a dry to wet gradient
forest[mapbiomas_22_ap==3] <- 2 # Formação Florestal
forest[mapbiomas_22_ap==4] <- 1 # Formação Savânica
forest[mapbiomas_22_ap==6] <- 3 # Floresta Alagável
rs_forest <- resample(forest,
                              previsia_22_ap_risk, 
                          method = "near")
# crop to Amapa
rs_forest <- crop(rs_forest, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
names(rs_forest) <- "forest"

# layer with just forest formation (Ombrofilia - Guyana ecotone)
floresta <- mapbiomas_22_ap
values(floresta) <- 0
# Atualizar com valor de 3 quando pixels originais são de floresta
floresta[mapbiomas_22_ap==3] <- 3 # Formação Florestal
rs_floresta <- resample(floresta,
                              previsia_22_ap_risk, 
                          method = "near")
# crop to Amapa
rs_floresta <- crop(rs_floresta, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")

names(rs_floresta) <- "floresta"

```

Now biomass and forest height.
```{r biomass_forest}
bfile <- "E:\\Avitabile_AGB_Map\\Avitabile_AGB_Map\\Avitabile_AGB_Map.tif"
hfile <- "E:\\Forest_height_2019_SAM.tif"
rast(bfile) |> 
  crop(vect(ap_1km_4326)) -> biomass_ap
biomass_ap[is.na(biomass_ap[])] <- 1 
biomass_ap <- crop(biomass_ap, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
rs_biomass <- resample(biomass_ap,
                              previsia_22_ap_risk, 
                          method = "bilinear")
names(rs_biomass) <- "biomass"
same.crs(rast(hfile), vect(ap_1km_4326)) # TRUE
rast(hfile) |>
  crop(vect(ap_1km_4326), mask = TRUE, snap="out") -> height_ap
# correct errors
height_ap[height_ap>90] <- 0
rs_height <- resample(height_ap,
                              previsia_22_ap, 
                          method = "bilinear")
names(rs_height) <- "height"

```


Water need to include drainage - here using OSM
```{r water-distance}
riverosm <- read_sf("data/vector/osm_ap_rios.shp") |> 
  st_transform(terra::crs(previsia_22))

river_c <- crop(vect(riverosm), vect(ap_1km))
river_ap <- st_buffer(st_as_sf(river_c), dist=50)
river_ap$aval <- 1
r <- rast(previsia_22_ap_risk)
rivers_2022 <- rasterize(vect(river_ap), r, "aval", fun="max", 
                         touches = TRUE)
rivers_2022[is.na(rivers_2022[])] <- 0 
# crop to Amapa
rivers_2022 <- crop(rivers_2022, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
rs_rivers_2022 <- resample(rivers_2022, previsia_22_ap_risk, 
                          method = "near")
rs_rivers_2022 <- crop(rs_rivers_2022, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")
# Mapbiomas water
water_2022 <- mapbiomas_22_ap_reclass 
values(water_2022) <- 0
# Atualizar com valor de 1 quando pixels originais são de agua
water_2022[mapbiomas_22_ap_reclass==26] <- 1 
unique(water_2022)

same.crs(water_2022, previsia_22_ap_risk) # TRUE
rs_water_2022 <- resample(water_2022, previsia_22_ap_risk, 
                          method = "near")
rs_water_2022 <- crop(rs_water_2022, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")

tmp <- rs_water_2022 + rs_rivers_2022
rs_water_final <- tmp
values(rs_water_final) <- 0
# Atualizar com valor de 1 quando pixels originais são de antropico
rs_water_final[tmp==1 | tmp == 2] <- 1
# crop to Amapa
rs_water_final <- crop(rs_water_final, vect(ap_1km_4326), 
                        mask = TRUE, snap="out")

# Plot to check
tm_shape(rs_water_final) +
  tm_raster(style = "cat") + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "bottom")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "bottom")) +
tm_layout(legend.position = c("left","top"), legend.bg.color="white")

# calculate distance to river
# Now calculate distance
d_water <- distance(rs_water_final, target=0) 
names(d_water) <- "water_dist_m"
# plot to check
tm_shape(d_water/10000) +
  tm_raster(palette = rev(viridis::viridis(100)), 
            n=100, legend.show = FALSE) + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_compass(position=c("left", "top")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "top")) +
tm_layout(legend.position = c("left","bottom"), legend.bg.color="white")

```


Export.
```{r export-dist}
all <- c(d_human, d_risk, d_resident, 
         d_water, rs_forest, rs_floresta, 
         rs_biomass, rs_height
         )
all <- crop(all, vect(ap_crop), mask=TRUE, snap = "out")
writeRaster(all, "data/raster/dist.tif", 
              gdal=c("COMPRESS=DEFLATE"), overwrite = TRUE)
```

```{r}
atest <- rast("data/raster/dist.tif")

```

Now crop to study area.
Run across beaches and interviews.
Load data (beaches Lua) and interviews (Michalski interviews)...
```{r load-data}
#extent from 50 km arouund river upstream of cachoeira caldeirao
meuSIG <- "C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg"
rsl <- st_read(meuSIG, layer = "centerline")

interview_file <- "C:\\Users\\user\\Documents\\Articles\\2022_Michalski_interview\\analysis\\Interviews_2011_2015_alldata_106interviewsdn.xlsx"
interviews <- read_excel(interview_file, col_types = c("numeric", "numeric", "text", "numeric", "text", "numeric", "numeric", 
                                                                         "numeric", "numeric", "text", "numeric", 
                                                                         "date", "numeric", "numeric", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "text", "text", "numeric", "numeric", 
                                                                         "text", "text", "numeric", "text", 
                                                                         "numeric", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "numeric", "text", "text", "text", 
                                                                         "text", "text", "text", "numeric", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "numeric", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "numeric", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "text", "text", "text", "text", "text", 
                                                                         "text", "numeric", "text", "text", 
                                                                         "text", "text", "text", "text"))

```

Make extents.
```{r make-extents}
rsl_50km <- st_union(st_buffer(rsl, dist=50000)) |> 
  st_make_valid()
myexent_rsl <- ext(vect(rsl_50km))

interviews_4326 <- st_as_sf(x = interviews,                         
               coords = c("Longitude", "Latitude"),
               crs = 4326)
int_50km <- st_union(st_buffer(interviews_4326, dist=50000)) |> 
  st_make_valid()
myexent_int <- ext(vect(int_50km)) 

int <- st_union(rsl_50km, int_50km)|> 
  st_make_valid()
myexent_final <- ext(vect(int))

area_crop <- crop(vect(brazil), vect(int))

area_poly <- st_cast(st_as_sf(area_crop), "POLYGON")
area_poly$area_m2 <- as.numeric(st_area(area_poly))
area_poly |> 
  filter(area_m2 > 37773416684) -> area_crop
  
```


Crop and export.
```{r new-crop}
newarea <- crop(atest, vect(area_crop), mask=TRUE)
#export
writeRaster(newarea, "data/raster/dist_area.tif", 
              gdal=c("COMPRESS=DEFLATE"), overwrite = TRUE)

```


Sample points.
```{r sample-points}
# 185 * 204 km approx
units::set_units(st_area(area_crop), "km2") #37773.42 [km^2]
point_sample <- st_sample(area_crop, size=4000, type="regular")
d <- data.frame(aid = 1:length(point_sample))
d$geom = point_sample
sf_points = st_as_sf(d, crs=4326)
```

Plot to check. Not working!!!
```{r check-sample-points}

tm_shape(d_human/10000) +
  tm_raster(palette = rev(viridis::viridis(100)), 
            n=100, legend.show = FALSE) + 
tm_shape(ap_1km) + 
  tm_borders(col="black") + 
tm_shape(sf_points) + 
  tm_dots(col="black") + 
tm_compass(position=c("left", "top")) +
tm_scale_bar(breaks = c(0, 100, 200), text.size = 0.5, 
             position=c("left", "top")) +
tm_layout(legend.position = c("left","bottom"), legend.bg.color="white")

```

Check distances between points.
```{r point-distances}
# 3125.68
nngeo::st_nn(sf_points, sf_points, k = 2, returnDist = T)
```

Extract values from raster layers.
```{r extract-values}
sf_points |> 
  bind_cols(extract(newarea, vect(sf_points))) -> sf_points
```

Export.
```{r}
write_sf(sf_points, "data/vector/sample_points.shp")
```


Hillshade example.
```{r hillshade-example}

alt = geodata::elevation_30s(country='CHE', path="data/raster")
slope = terrain(alt, "slope")
aspect = terrain(alt, "aspect")
hill = shade(slope, aspect, angle=30, direction=270)
plot(hill, col=grey(0:100/100), legend=FALSE, main='Switzerland')
plot(alt, col=rainbow(25, alpha=0.45), add=TRUE)

tm_shape(hill) +
 tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE)  +
  tm_shape(alt) +
  tm_raster(alpha = 0.5, palette = terrain.colors(25),
            legend.show = FALSE)

```

Species occurence example
```{r sp-occurence}
# Not enough records - only one for each!
paon <- sp_occurrence(genus= "Panthera", species="onca", 
                      ext=vect(ap_1km), geo=TRUE, removeZeros=TRUE,
                      download=TRUE, ntries=5, nrecs=300) |> 
  filter(country=="Brazil")

ateles <- sp_occurrence(genus= "Ateles", 
                      ext=vect(ap_1km), geo=TRUE, removeZeros=TRUE,
                      download=TRUE, ntries=5, nrecs=300) |> 
  filter(country=="Brazil")


```

