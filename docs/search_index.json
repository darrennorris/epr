[["escala.html", "Capítulo 1 Escala 1.1 Apresentação 1.2 Escala: breve definação 1.3 Pacotes e dados 1.4 Alterando a resolução 1.5 Escala espacial e desenho amostral 1.6 Comparação multiescala 1.7 Próximos passos: repetindo para muitas amostras.", " Capítulo 1 Escala 1.1 Apresentação Nesta capitulo vamos entender a importância de escala na ecologia da paisagem através cálculos com a proporção de floresta. Durante o capitulo você aprenderá a Alterar escala (resolução e extensão espacial), Calcular a área de uma classe de habitat, Desenvolve uma comparação multiescala. É muito importante ficar claro para você o que é escala (e o que não é!), e qual a importância desse conceito na elaboração do desenho amostral, na coleta de dados, nas análises e na tomada de decisão. Nesse tutorial usaremos conteudo baseado no Capítulo 2 do livro Spatial Ecology and Conservation Modeling (Fletcher and Fortin 2018) e “Tutorial Escala” do Dr. Alexandre Martensen. 1.2 Escala: breve definação Todos os processos e padrões ecológicos têm uma dimensão temporal e espacial. Assim sendo, o conceito de escala não somente representar essas dimensões, mas também, ajudar nos apresentá-los de uma forma que facilite o entendimento sobre os processos e padrões sendo estudados. Na ecologia o termo escala refere-se à dimensão ou domínio espaço-temporal de um processo ou padrão. Na ecologia da paisagem, a escala é frequentemente descrita por sua componentes: resolução e extensão. Resolução: menor unidade espacial de medida para um padrão ou processo. Extensão: descreve o comprimento ou tamanho de área sob investigação. Resolução e extensão tendem a covariar – estudos com maior extensão tendem a ter resolução maiores também. Parte dessa covariância é prática: é difícil trabalhar em grandes extensões com dados coletados em tamanhos de resolução finos. No entanto, parte dessa covariância também é conceitual: muitas vezes em grandes extensões, podemos esperar que processos operando em resolução muito finos forneçam somente “ruído” e não dados/informações relevantes sobre os sistemas. Como os desafios computacionais diminuíram e a disponibilidade de dados de alta resolução aumentou, a covariância entre resolução e extensão nas investigações diminuiu. Lembrando, na primeira aula, vimos que a escala espacial pode ser interpretada com base em três dimensoes: no fenômeno de interesse; na amostragem que ocorre; e/ou na análise Para que a Ecologia da Paisagem gere evidências científicas robustas e úteis, a escala nas três dimensões deve ser consistente e apropriada para o estudo. Aqui nos concentramos na dimensão “análise”, e aprendemos como a escala espacial pode ser alterada e representada em modelos ecológicos. 1.3 Pacotes e dados Em geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Neste caso precisamos os seguintes pacotes, que deve esta instalado antes: tidyverse, sf, terra, mapview, tmap. 1.3.1 Pacotes No R, carregar os pacotes necessarios com o codigo: library(tidyverse) library(sf) library(terra) library(mapview) library(tmap) library(eprdados) Caso os pacotes não tenham sido instalados, o R vai avisar atraves um mensagem tipo: Error in library(nomepacote) : there is no package called ‘nomepacote’. Neste caso, para instalá-los consulte o capitulos aqui Capitulo 4 instalação de pacotes e aqui Capitulo 4 pacotes . 1.3.2 Dados Vamos olhar um exemplo do mundo real. Uma pequena amostra do Rio Araguari, perto de Porto Grande. O ponto central é de longitude: -51.406312 latitude: 0.726236. Para visualizar o ponto no Google Earth: https://earthengine.google.com/timelapse#v=0.72154,-51.41543,11.8,latLng&amp;t=2.24&amp;ps=25&amp;bt=19840101&amp;et=20201231&amp;startDwell=0&amp;endDwell=0 . Vammos trabalhar com os dados de MapBiomas, que produz mapeamento anual da cobertura e uso da terra no Brasil desde 1985. Os dados de MapBiomas vem no formato de raster, que tem uma classificação da terra feito a partir da classificação pixel a pixel de imagens das satélites Landsat. Todo processo é feito com algoritmos de aprendizagem de máquina (machine learning) através da plataforma Google Earth Engine, que oferece imensa capacidade de processamento na nuvem. Mais detalhes sobre a metodologia aqui: Metodologia MapBiomas. Para carregar um arquivo raster trabalhamos com o pacote terra. O pacote tem varios funçoes para a análise e modelagem de dados geográficos. Nós podemos ler os dados de cobertura da terra no arquivo “.tif” com a função rast. # arquivo no pacote &quot;eprdados&quot; arquivo &lt;- system.file(&quot;raster/amostra_mapbiomas_2020.tif&quot;, package = &quot;eprdados&quot;) # carregar ramostra &lt;- rast(arquivo) Plotar para verificar. plot(ramostra) Figura 1.1: Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. Podemos também verificar informações sobre o raster (metadados) rodando o nome do objeto: ramostra ## class : SpatRaster ## dimensions : 8, 9, 1 (nrow, ncol, nlyr) ## resolution : 29.89281, 29.89281 (x, y) ## extent : 454659.8, 454928.9, 80160.06, 80399.2 (xmin, xmax, ymin, ymax) ## coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) ## source : amostra_mapbiomas_2020.tif ## name : mapbiomas_2020 ## min value : 3 ## max value : 33 Isso nos mostra informações sobre escala espacial (resolução e extensão) e a sistema de coordenadas (SIRGAS 2000 / UTM zone 22N , EPSG:31976). Além disso é possível obter informações específicas através de funções específicas. # Obter informações sobre escala espacial # resolução, comprimento e largura do pixel em metros res(ramostra) # numero de colunas ncol(ramostra) # numero de linhas nrow(ramostra) 1.3.2.1 Pergunta 1 Com base nos resultados obtidos até agora em relação ao objeto raster ramostra, qual o área do pixel em metros quadrados? Qual o área total da paisagem (raster ramostra) em hectares e quilometros quadrados? Vamos olhar o mapa de novo. plot(ramostra) Figura 1.2: Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. O mapa mostra três classes com valores de 3, 12 e 33. Lembrando, o objetivo principal não é de fazer mapas. Mas, a visualização dos dados é um passo importante para verificar e entender os padrões. Portanto, segue exemplo mostrando uma forma de visualizar o arquivo de raster como mapa. Para entender o que os valores (3, 12, 33) representam no mundo real precisamos de uma referência (legenda). Para a MapBiomas Coleção 6, arquivo: Cod_Class_legenda_Col6_MapBiomas_BR.pdf. Existe também arquivos para fazer as mapas com cores corretas em QGIS ou ArcGIS. Olhando a legenda (Cod_Class_legenda_Col6_MapBiomas_BR.pdf), sabemos que “3”, “12” e “33” representem cobertura de “Formação Florestal”, “Formação Campestre”, e “Rio, Lago e Oceano”. Então podemos fazer um mapa mostrando tais informações. Daqui pra frente vamos aproveitar uma forma mais elegante de apresentar mapas e gráficos. Isso seria atraves a função “ggplot” (pacote ggplot2), que faz parte do “tidyverse”. Mais exemplos no R cookbook : http://www.cookbook-r.com/Graphs/ . E com mais exemplos de mapas e dados espaciais no R: sf e ggplot2 : https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html Capitulo 9 no livro Geocomputation with R : https://geocompr.robinlovelace.net/adv-map.html Primeiramente precisamos incluir as informações relevantes da legenda. Ou seja, incluir os nomes para cada valor de classe. # legenda e cores na sequencia correta classe_valor &lt;- c(3, 12, 33) classe_legenda &lt;- c(&quot;Formação Florestal&quot;, &quot;Formação Campestre&quot;, &quot;Rio, Lago e Oceano&quot;) classe_cores &lt;- c(&quot;#006400&quot;, &quot;#B8AF4F&quot;, &quot;#0000FF&quot;) Agora podemos fazer o mapa com as classes e os cores seguindo o padrão recomendado pela MapBiomas para Coleção 6. # Passo necessario para mostrar os valores ramostra_df &lt;- as.data.frame(ramostra, xy = TRUE) ggplot(ramostra_df, aes(x=x, y=y)) + geom_raster(aes(fill = factor(mapbiomas_2020))) + scale_fill_manual(&quot;classe&quot;, values = classe_cores, labels = classe_legenda) + coord_equal() + geom_text(data = ramostra_df, aes(x = x, y = y, label = mapbiomas_2020)) + theme(legend.position=&quot;top&quot;) + guides(fill=guide_legend(nrow=2,byrow=TRUE)) Figura 1.3: Paisagem com valores e classes de cobertura da terra. Mapbiomas 2020. Uma pequena amostra do Rio Araguari, perto de Porto Grande. 1.4 Alterando a resolução Alterando a resolução serve como exemplo mostrando como os passos/etapas/cálculos mude dependendo o tipo de dados. Ou seja, é preciso adotar metodologias diferentes para dados categóricos (por exemplo classificação de cobertura da terra) e dados contínuos (por exemplo distância até rio). Alterando a resolução às vezes seria necessário, por exemplo, quando preciso padronizar dados/imagens oriundos de fontes diferentes com resoluções diferentes e/ou para reduzir a complexidade da modelagem. Lembrando - em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Agora iremos degradar a resolução desses dados, ou seja, iremos alterar o tamanho dos pixels. Como exemplo, iremos juntar (agregar) 3 pixels em um único pixel. Como você acha que podemos fazer isso? Quais valores esse pixel que vai substituir os 3 originais deve ter? Existem diversas maneiras de se fazer isso, uma das formas é através da média. ramostra_media&lt;-aggregate(ramostra, fact=3, fun=&quot;mean&quot;) ramostra_media &lt;- resample(ramostra, ramostra_media) Visualizar. Os valores calculados pela função não fazem sentido para uma classificação categórica. # Tidy as.data.frame(ramostra_media, xy = TRUE) %&gt;% mutate(mapbiomas_2020 = round(mapbiomas_2020,1)) -&gt; ramostra_media_df # Plot ggplot(ramostra_media_df, aes(x=x, y=y)) + geom_raster(aes(fill = factor(mapbiomas_2020))) + scale_fill_discrete(&quot;valor&quot;) + coord_equal() + geom_text(data = ramostra_media_df, aes(x = x, y = y, label = mapbiomas_2020)) Figura 1.4: Agregação errado para dados categóricos. Uso da média cria valores categóricos errados e impossíveis. Outra opção é utilizar o valor mais comum da área, o que é particularmente adequado quando temos um mapa categórico, como por exemplo floresta/não-floresta. Segue exemplo com o valor mais frequente (modal). ramostra_modal&lt;- aggregate(ramostra, fact=3, fun=&quot;modal&quot;) ramostra_modal &lt;- resample(ramostra, ramostra_modal, method=&quot;near&quot;) Visualizar. Os valores calculados pela função são consistentes com o original e fazem sentido. # Tidy ramostra_modal_df &lt;- as.data.frame(ramostra_modal, xy = TRUE) # Plot ggplot(ramostra_modal_df, aes(x=x, y=y)) + geom_raster(aes(fill = factor(mapbiomas_2020))) + scale_fill_manual(&quot;classe&quot;, values = classe_cores) + coord_equal() + geom_text(data=ramostra_modal_df, aes(x=x, y=y, label=mapbiomas_2020)) Figura 1.5: Agregação pela mais frequente. Em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Aqui por exemplo, mudamos a proporção de cobertura florestal em nossa pequeno paisagem quando juntamos 3 pixels em um único: a proporção de floresta moudou de 4% (3/72) para 11% (1/9). Ou seja, com cada passo mudamos a representção do mundo. Figura 1.6: Mudanças causadas pela agregação. 1.4.0.1 Pergunta 2 Confira o codigo e os resultados obtidos anteriormente, quando mudamos a resolução da ratser ramostra (por exemplo figuras 5.1, 5.2 e 5.3). Explique o que aconteceu. Como e porque moudou os valores em cada caso (média e modal)? 1.5 Escala espacial e desenho amostral Dado o papel que a escala pode desempenhar em nossa compreensão dos padrões e processos ecológicos, como escala deve ser considerada no desenho do estudo? Claramente, a resposta a esta pergunta irá variar dependendo dos fenômenos de interesse, mas ecologistas e estatísticos têm forneceu algumas orientações importantes. As questões-chave incluem o tamanho da unidade de amostragem (resoloção), o tipo de unidade de amostra e localizações da unidade de amostra, incluindo o espacamento entre as amostras (distância entre as amostras) e o tamanho da área de estudo. Com a disponibilidade de imagens de satélite é possível responder questões importantes relacionadas ao desenho do estudo antes de qualquer trabalho de campo. Uma tecnica de geoprocessamento (bordas - Buffers) é um dos mais frequentemente adotados para quantificar escala espacial na ecologia da paisagem. O objetivo é criar buffers circulares de diferentes extensões ao redor dos sitios de amostragem (pontos, pixels, manchas, transetos lineares etc). Aqui, vamos entender a escala em que a cobertura de floresta muda ao redor dos rios. Para isso, quantificamos a quantidade de floresta que ocorre em várias distâncias em pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Para ilustrar esta abordagem geral, usamos o banco de dados MapBiomas Coleção 6 de 2020, e vincule esses dados de cobertura da terra aos pontos de amostragem em rios. 1.5.1 Obter e carregar dados (vectores) Precisamos carregar os dados para rios e pontos de amostragem. Baixar arquivo (vector) com os dados (formato “GPKG”, tamanho 54.9 MB). Este arquivo contém diferentes camadas vetoriais usadas para avaliar impactos de barragens hidroelétricas em tracajas ((Bárcenas-García et al. 2022)) e ariranhas ((Raffo et al. 2022)). Mais sobre dados vetoriais. O formato aberto GeoPackage é um contêiner que permite armazenar dados SIG (feições/camadas) em um único arquivo. Por exemplo, um arquivo GeoPackage pode conter vários dados (dados vetoriais e raster) em diferentes sistemas de coordenadas. Todos esses recursos permitem que você compartilhe dados facilmente e evite a duplicação de arquivos. Baixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.gpkg . Lembrando-se de salvar o arquivo (“rivers.gpkg”) em um local conhecido no seu computador. O formato “GPKG” e diferente de “tif” (raster), o processo de importação é, portanto, diferente. Primeira, avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “rivers.GPKG”: meuSIG &lt;- file.choose() Agora vamos olhar o que tem no arquivo. Depois que voces rodar o codigo st_layers(meuSIG), o resultado mostra que o arquivo rivers.GPKG inclui camadas diferentes com pontos (“Point”), linhas (“Line String”) e polígonos (“Polygon”). Alem disso, a coluna “crs_name” mostrar que a sistema de coordenadas é geográfica (WGS84, (EPSG: 4326)\\[https://epsg.io/4326\\], e é diferente do arquivo raster: sf::st_layers(meuSIG) ## Driver: GPKG ## Available layers: ## layer_name geometry_type features fields crs_name ## 1 centerline Line String 52 15 WGS 84 ## 2 forestloss Point 276086 12 WGS 84 ## 3 canalpoly Polygon 3 6 WGS 84 ## 4 extentpoly50km Polygon 1 0 WGS 84 ## 5 midpoints Point 52 17 WGS 84 ## 6 midpoints_hansen Point 52 37 WGS 84 ## 7 cachoeira_caldeirao Point 1 2 WGS 84 ## 8 porto_grande Point 1 1 WGS 84 ## 9 icmbio_base Point 1 1 WGS 84 ## 10 direct_affect Polygon 1 2 WGS 84 ## 11 midpoints_hansen_distances Point 52 43 WGS 84 ## 12 midpoints_hansen_ffr Point 52 82 WGS 84 ## 13 midpoints_hansen_ffril Point 52 91 WGS 84 ## 14 direct_affect_line Line String 1 2 WGS 84 Nós só precisamos de duas dessas camadas. O código abaixo vai carregar as camadas que precisamos e criar os objetos “rsm” e “rsl”. Assim, agora temos dados com: pontos cada 5 km ao longo os rios (“rsm”) e a linha central de rios (“rsl”). # pontos cada 5 km rsm &lt;- sf::st_read(meuSIG, layer = &quot;midpoints&quot;) ## Reading layer `midpoints&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 17 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -52.01259 ymin: 0.7175827 xmax: -51.29688 ymax: 1.330365 ## Geodetic CRS: WGS 84 # linha central de rios rsl &lt;- sf::st_read(meuSIG, layer = &quot;centerline&quot;) ## Reading layer `centerline&#39; from data source ## `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 52 features and 15 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -52.01443 ymin: 0.7094595 xmax: -51.2924 ymax: 1.352094 ## Geodetic CRS: WGS 84 1.5.2 Visualizar os arquivos (camadas vector) Visualizar para verificar. Mapa com linha central e pontos de rios em trechos de 5km. ggplot(rsl) + geom_sf(aes(color=rio)) + geom_sf(data = rsm, shape=21, aes(fill=zone)) Figura 1.7: Pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Mapa interativo (funcione somente com internet) Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc) # mapview(rsl, zcol = &quot;rio&quot;) 1.5.3 Obter e carregar dados (raster) Mais uma vez vamos aproveitar os dados de MapBiomas. Agora baixar arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 3.3 MB). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif . Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “utm_cover_AP_rio_2020.tif”: meuSIGr &lt;- file.choose() O código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”. mapbiomas_2020 &lt;- rast(meuSIGr) 1.5.4 Visualizar os arquivos (camadas raster e vector) Visualizar para verificar. É possível de visualizar camadas de raster e vetor juntos com funcões no pacote Tmap (https://r-tmap.github.io/tmap-book/index.html). # Passo necessario para agilizar o processamento mapbiomas_2020_modal&lt;-aggregate(mapbiomas_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(mapbiomas_2020_modal) + tm_raster(title = &quot;Classe&quot;, style = &quot;cat&quot;, palette = &quot;Set3&quot;) + tm_shape(rsl) + tm_lines(col=&quot;blue&quot;) + tm_shape(rsm) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_compass(position=c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;), legend.bg.color=&quot;white&quot;) Figura 1.8: Cobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. 1.5.5 Reclassificação Para simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente). # criar uma nova camada de floresta floresta_2020 &lt;- mapbiomas_2020 # Com valor de 0 values(floresta_2020) &lt;- 0 # Atualizar categorias florestais agrupados com valor de 1 floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 Vizualizar para verificar. # Passo necessario para agilizar o processamento floresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=&quot;modal&quot;) # Plot tm_shape(floresta_2020_modal) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_shape(rsl) + tm_lines(col=&quot;blue&quot;) + tm_shape(rsm) + tm_dots(size = 0.2, col = &quot;yellow&quot;) + tm_scale_bar(breaks = c(0, 25, 50), text.size = 1, text.color = &quot;white&quot;, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;),legend.bg.color = &quot;white&quot;) Figura 1.9: Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio. 1.6 Comparação multiescala Em seguida, com as coordenadas dos pontos das localizações das amostras calculamos a quantidade de floresta que circunda cada local de amostragem em diferentes extensões. rsm_31976 &lt;- st_transform(rsm, 31976) # Buffer rsm_31976_b1000 &lt;- st_buffer(rsm_31976[1, ], dist = 1000) # Recorte com buffer de 1000 metros (mudando a extensão). buffer.forest1.1km &lt;- crop(floresta_2020, snap=&quot;out&quot;, rsm_31976_b1000) # Máscara para que os pixels fora do polígono sejam nulos. buffer.forest1.1km &lt;- mask(buffer.forest1.1km, rsm_31976_b1000, touches=TRUE) names(buffer.forest1.1km) &lt;- &quot;forest_2020_1km&quot; Vizualizar para verificar. # Plot tm_shape(buffer.forest1.1km) + tm_raster(style = &quot;cat&quot;, palette = c(&quot;0&quot; = &quot;#E974ED&quot;, &quot;1&quot; =&quot;#129912&quot;), legend.show = FALSE) + tm_shape(rsm_31976[1, ]) + tm_symbols(shape =21, col = &quot;yellow&quot;, border.col = &quot;black&quot;, border.lwd = 0.2, size=0.5) + tm_shape(rsm_31976_b1000) + tm_borders(col = &quot;black&quot;, lwd = 4, lty = &quot;dashed&quot;) + tm_add_legend(type = &quot;fill&quot;, labels = c(&quot;não-floresta&quot;, &quot;floresta&quot;), col = c(&quot;#E974ED&quot;, &quot;#129912&quot;), title = &quot;Classe&quot;) + tm_compass(position=c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 0.5, 1), text.size = 1, position=c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;), legend.bg.color = &quot;white&quot;) Figura 1.10: Ilustração da determinação da quantidade de habitat ao redor de um ponto. Para um determinada extensão, o habitat de interesse é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e o número de células (pixels) que contém o habitat é somado e multiplicado pela área de cada pixel. 1.6.1 Pergunta 3 Qual é a extensão em número de pixels desse recorte (buffer.forest1.1km)? Temos valores de 0 (não-floresta) e 1 (floresta). Então, para saber a aréa de floresta podemos somar o número de células (pixels) que contém o habitat e multiplica pela área de cada pixel conforme o codigo: # 1) Somatório. # No caso igual o numero de pixels de floresta. # Para todo a paisagem, somatorio &quot;global&quot;. # Não deve incluir pixels nulos, então use &quot;na.rm = TRUE&quot;. soma_floresta &lt;- global(buffer.forest1.1km, &quot;sum&quot;, na.rm = TRUE) soma_floresta ## sum ## forest_2020_1km 943 # 2) Área de cada pixel. # Sabemos o sistema de coordenadas (EPSG = 31976). # EPSG 31976 é uma sistema projetado com unidade em metros. buffer.forest1.1km ## class : SpatRaster ## dimensions : 68, 68, 1 (nrow, ncol, nlyr) ## resolution : 29.89281, 29.89281 (x, y) ## extent : 465959.3, 467992, 90921.47, 92954.18 (xmin, xmax, ymin, ymax) ## coord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) ## source(s) : memory ## varname : utm_cover_AP_rio_2020 ## name : forest_2020_1km ## min value : 0 ## max value : 1 # Portanto, o tamanho de cada pixel é igual. area_pixel_m2 &lt;- 29.89281 * 29.89281 area_pixel_m2 ## [1] 893.5801 # 3) Calculos de aréa. # Aréa de floresta m2 area_floresta_m2 &lt;- soma_floresta * area_pixel_m2 area_floresta_m2 ## sum ## forest_2020_1km 842646 # Aréa de floresta hectares area_floresta_ha &lt;- area_floresta_m2 / 10000 area_floresta_ha ## sum ## forest_2020_1km 84.2646 Para uma comparação multiescala, vamos repetir o mesmo processo, mas agora com distancias de 250, 500, 1000, 2000 e 4000 metros, doubrando a escala (extensão) em cada passo. Figura 1.11: Cobertura florestal em extensões diferentes ao redor de um local de amostragem. Aspectos quantitativos das paisagens mudam fundamentalmente com a escala. Por exemplo, nesse caso, parece que a proporção de floresta aumenta à medida que a extensão aumenta de 500 para 4000 metros. Esta percepção visual é confirmada pelos valores calculados, onde as áreas são: raio 250 m = 0 hectares de floresta raio 500 m = 6,3 hectares de floresta raio 1000 m = 84,3 hectares de floresta raio 2000 m = 502.6 hectares de floresta raio 4000 m = 3351.0 hectares de floresta 1.6.2 Pergunta 4 Usando os valores listadas acima de raio e área de floresta para os diferentes buffers circulares, calcule a proporção de floresta em cada uma das diferentes extensões de buffer. Apresente 1) os resultados incluindo cálculos. 2) um gráfico com valores de extensão no eixo x e proporção da floresta no eixo y. 3) Em menos de 200 palavras apresente a sua interpretação do gráfico. 1.6.3 Pergunta 5 A modelagem multiescala quantifica as condições do ambiente em múltiplas escalas alterando o resolução ou a extensão da análise e, em seguida, avaliando qual das escalas consideradas explica melhor um padrão ou processo. Escolha 1 espécie aquático e 1 espécie terrestre que ocorram na região a montante das hidrelétricas no Rio Araguari. Com base nas diferenças entre extensões (indicados no exemplo anterior) e as características funcionais das espécies (por exemplo área de vida), escolher as extensões mais adequadas para um estudo multiescala de cada espécie. 1.7 Próximos passos: repetindo para muitas amostras. Neste exemplo comparamos a área de floresta em torno de um único ponto de amostragem. Para calcular o mesmo para todos os 52 pontos, seriam necessárias varias repetições (52 pontos x 5 extensões = 260 repetições). Poderíamos escrever código para executar esse processo automaticamente. Felizmente, alguém já escreveu funções para fazer isso e muito mais. O próximo tutorial sobre métricas de paisagem mostrará exemplos usando o pacote “landscapemetrics” (https://r-spatialecology.github.io/landscapemetrics/). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
