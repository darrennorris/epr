[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ecologia de Paisagens com R",
    "section": "",
    "text": "Bem-vindos\nEste é um trabalho em andamento do 1ª edição: “Ecologia de Paisagens com R”.\nEste é um material introdutório destinado principalmente a estudantes de graduação e cursos de pós-graduação em ecologia e áreas correlatas.\nO objetivo é de apresentar os capacidades e opções para desenvolver e integrar pesquisas na Ecologia da Paisagem no ambiente estatística de R.\nEsperamos que ele seja utilizado tanto por quem quer se aprofundar em análises comumente utilizadas em Ecologia da Paisagem, quanto por quem não tem nenhuma ou poucas habilidades quantitativas."
  },
  {
    "objectID": "index.html#agradecimentos",
    "href": "index.html#agradecimentos",
    "title": "Ecologia de Paisagens com R",
    "section": "Agradecimentos",
    "text": "Agradecimentos\nEste livro não é apenas o resulto dos autores. Mas é o resultado de muitas pessoas na comunidade R e Ecologia da Paisagem no Brasil. Muito obrigado!"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Prefácio à primeira edição",
    "section": "",
    "text": "Há quem diga que a velocidade com que a tecnologia e a ciência avançam tende a tornar livros e manuais sobre métodos rapidamente obsoletos. A evolução dos computadores pessoais e a ampliação do acesso a estes e à Internet têm transformado o jeito como aprendemos e ensinamos.\nPortanto, um livro aberto e disponível livremente que as pessoas possam compartilhar e contribuir torna-se uma opção cada vez mais relevante.\nO conteudo e organização dos capítulos esta separado em partes.\nO primeiro grupo – que inclui dos capítulos x ao y, inclui os aspectos mais gerais da estrutura do livro, seus objetivos e sobre o funcionamento da linguagem R. No segundo grupo de capítulos (do x ao y), temos contato com análises específicas e atualmente usadas em Ecologia da Paisasgem, incluindo …."
  },
  {
    "objectID": "intro.html#o-que-você-vai-aprender",
    "href": "intro.html#o-que-você-vai-aprender",
    "title": "Introdução",
    "section": "O que você vai aprender",
    "text": "O que você vai aprender\nEcologia da Paisagem é um campo vasto e não há como dominar tudo lendo um único livro. Este livro visa fornecer uma base sólida nas ferramentas mais importantes e conhecimento suficiente para encontrar os recursos para aprender mais quando necessário. Um modelo das etapas de um projeto típico de Ecologia da Paisagem se parece com….."
  },
  {
    "objectID": "intro.html#como-este-livro-está-organizado",
    "href": "intro.html#como-este-livro-está-organizado",
    "title": "Introdução",
    "section": "Como este livro está organizado",
    "text": "Como este livro está organizado\nA descrição anterior das ferramentas da Ecologia da Paisagem é organizada aproximadamente de acordo com a ordem em que você as usa em uma análise (embora, é claro, você as itere várias vezes). Em nossa experiência, no entanto, aprender a importar e organizar os dados primeiro não é o ideal, porque 80% do tempo é rotineiro e chato e, nos outros 20% do tempo, é estranho e frustrante. Esse é um péssimo lugar para começar a aprender um novo assunto! Em vez disso, começaremos com a visualização e transformação dos dados que já foram importados e organizados. Dessa forma, quando você ingerir e organizar seus próprios dados, sua motivação permanecerá alta porque você sabe que a dor vale o esforço.\nDentro de cada capítulo, tentamos aderir a um padrão consistente: comece com alguns exemplos motivadores para que você possa ver o quadro geral e depois mergulhe nos detalhes. Cada seção do livro é combinada com exercícios para ajudá-lo a praticar o que aprendeu. Embora possa ser tentador pular os exercícios, não há melhor maneira de aprender do que praticar em problemas reais."
  },
  {
    "objectID": "intro.html#o-que-você-não-vai-aprender",
    "href": "intro.html#o-que-você-não-vai-aprender",
    "title": "Introdução",
    "section": "O que você não vai aprender",
    "text": "O que você não vai aprender"
  },
  {
    "objectID": "intro.html#prerequisites",
    "href": "intro.html#prerequisites",
    "title": "Introdução",
    "section": "Prerequisites",
    "text": "Prerequisites\nFizemos algumas suposições sobre o que você já sabe para aproveitar ao máximo este livro. Você deve ser geralmente alfabetizado numericamente, e com conhecimento previsa de ecologia, geoprocessamento e uso de sistemas de informação geografica.\nVocê precisa de quatro coisas para executar o código deste livro: R, RStudio, uma coleção de pacotes R chamada tidyverse e um punhado de outros pacotes. Os pacotes são as unidades fundamentais do código R reproduzível. Eles incluem funções reutilizáveis, documentação que descreve como usá-los e dados de amostra.\n\nR\nPara fazer o download do R, acesse CRAN, a comprehensive R archive nnetwork, https://cloud.r-project.org. Uma nova versão principal do R é lançada uma vez por ano e há 2 a 3 versões secundárias a cada ano. É uma boa ideia atualizar regularmente. A atualização pode ser um pouco complicada, especialmente para as versões principais que exigem a reinstalação de todos os seus pacotes, mas adiar só piora as coisas. Recomendamos R 4.2.0 ou posterior para este livro.\n\n\nRStudio\nRStudio é um ambiente de desenvolvimento integrado, ou IDE, para programação R, que você pode baixar em https://posit.co/download/rstudio-desktop/. O RStudio é atualizado algumas vezes por ano e avisa automaticamente quando uma nova versão é lançada, para que não haja necessidade de verificar novamente. É uma boa ideia atualizar regularmente para aproveitar os melhores e mais recentes recursos. Para este livro, certifique-se de ter pelo menos o RStudio 2022.02.0.\n\n\nO universo arrumado - tidyverse\nVocê também precisará instalar alguns pacotes do R. Um pacote do R é uma coleção de funções, dados e documentação que estende os recursos do R base. O uso de pacotes é a chave para o uso bem-sucedido do R. A maioria dos pacotes que você aprenderá neste livro faz parte do chamado tidyverse. Todos os pacotes no tidyverse compartilham uma filosofia comum de programação de dados e R e são projetados para trabalhar juntos.\nVocê pode instalar o tidyverse completo com uma única linha de código:\n\ninstall.packages(\"tidyverse\")\n\nNo seu computador, digite essa linha de código no console e pressione enter para executá-lo. R irá baixar os pacotes do CRAN e instalá-los em seu computador.\nVocê não poderá usar as funções, objetos ou arquivos de ajuda em um pacote até carregá-lo com library(). Depois de instalar um pacote, você pode carregá-lo usando a função library():\n\nlibrary(tidyverse)\n\nIsso diz a você que o tidyverse carrega nove pacotes: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, alignr. Eles são considerados o núcleo do tidyverse porque você os usará em quase todas as análises.\nOs pacotes no tidyverse mudam com bastante frequência. Você pode ver se há atualizações disponíveis executando tidyverse_update().\n\n\nOutros pacotes\nExistem muitos outros pacotes excelentes que não fazem parte do tidyverse porque resolvem problemas em um domínio diferente ou são projetados com um conjunto diferente de princípios subjacentes. Isso não os torna melhores ou piores, apenas diferentes. Em outras palavras, o complemento do tidyverse não é o universo bagunçado, mas muitos outros universos de pacotes inter-relacionados. Ao lidar com mais projetos de Ecologia da Paisagem com R, você aprenderá novos pacotes e novas formas de pensar sobre os dados.\nUsaremos outras pacotes de fora do tidyverse neste livro. Por exemplo, usaremos os seguintes pacotes porque eles fornecem conjuntos de funcões e dados interessantes para trabalharmos no processo de aprendizado de R:\n\ninstall.packages(c(\"sp\", \"sf\",\"raster\", \"mapview\",\"tmap\", \n                   \"terra\", \"kableExtra\", \"landscapemetrics\"))"
  },
  {
    "objectID": "escala-met.html",
    "href": "escala-met.html",
    "title": "Escala e metricas",
    "section": "",
    "text": "Objetivo não é de apresentar grandes detalhes sobre os cálculos/métodos estatísticas ou os funções no R."
  },
  {
    "objectID": "escala.html#alterando-a-resolução",
    "href": "escala.html#alterando-a-resolução",
    "title": "1  Escala",
    "section": "1.1 Alterando a resolução",
    "text": "1.1 Alterando a resolução\nAlterando a resolução serve como exemplo mostrando como os passos/etapas/cálculos mude dependendo o tipo de dados. Ou seja, é preciso adotar metodologias diferentes para dados categóricos (por exemplo classificação de cobertura da terra) e dados contínuos (por exemplo distância até rio).\nAlterando a resolução às vezes seria necessário, por exemplo, quando preciso padronizar dados/imagens oriundos de fontes diferentes com resoluções diferentes e/ou para reduzir a complexidade da modelagem. Lembrando - em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima.\nAgora iremos degradar a resolução desses dados, ou seja, iremos alterar o tamanho dos pixels. Como exemplo, iremos juntar (agregar) 3 pixels em um único pixel. Como você acha que podemos fazer isso? Quais valores esse pixel que vai substituir os 3 originais deve ter? Existem diversas maneiras de se fazer isso, uma das formas é através da média.\n\nramostra_media&lt;-aggregate(ramostra, fact=3, fun=\"mean\")\nramostra_media &lt;- resample(ramostra, ramostra_media)\n\nVisualizar. Os valores calculados pela função não fazem sentido para uma classificação categórica.\n\n# Tidy\nas.data.frame(ramostra_media, xy = TRUE) %&gt;% \n  mutate(mapbiomas_2020 = round(mapbiomas_2020,1)) -&gt; ramostra_media_df\n# Plot\nggplot(ramostra_media_df, aes(x=x, y=y)) +\n  geom_raster(aes(fill = factor(mapbiomas_2020))) +\n  scale_fill_discrete(\"valor\") + \n  coord_equal() + \n  geom_text(data = ramostra_media_df, aes(x = x, y = y, \n                label = mapbiomas_2020)) \n\n\n\n\nAgregação errado para dados categóricos. Uso da média cria valores categóricos errados e impossíveis.\n\n\n\n\n Outra opção é utilizar o valor mais comum da área, o que é particularmente adequado quando temos um mapa categórico, como por exemplo floresta/não-floresta. Segue exemplo com o valor mais frequente (modal).\n\nramostra_modal&lt;- aggregate(ramostra, fact=3, fun=\"modal\")\nramostra_modal &lt;- resample(ramostra, ramostra_modal, method=\"near\")\n\nVisualizar. Os valores calculados pela função são consistentes com o original e fazem sentido.\n\n# Tidy\nramostra_modal_df &lt;- as.data.frame(ramostra_modal, xy = TRUE) \n# Plot\nggplot(ramostra_modal_df, aes(x=x, y=y)) +\n  geom_raster(aes(fill = factor(mapbiomas_2020))) +\n  scale_fill_manual(\"classe\", values = classe_cores) + \n  coord_equal() + \ngeom_text(data=ramostra_modal_df, aes(x=x, y=y, label=mapbiomas_2020))\n\n\n\n\nAgregação pela mais frequente.\n\n\n\n\n\nEm cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Aqui por exemplo, mudamos a proporção de cobertura florestal em nossa pequeno paisagem quando juntamos 3 pixels em um único: a proporção de floresta moudou de 4% (3/72) para 11% (1/9). Ou seja, com cada passo mudamos a representção do mundo.\n\n\n\n\n\nMudanças causadas pela agregação.\n\n\n\n\n\n1.1.0.1 Pergunta 2\nConfira o codigo e os resultados obtidos anteriormente, quando mudamos a resolução da ratser ramostra (por exemplo figuras 5.1, 5.2 e 5.3). Explique o que aconteceu. Como e porque moudou os valores em cada caso (média e modal)?"
  },
  {
    "objectID": "escala.html#escala-espacial-e-desenho-amostral",
    "href": "escala.html#escala-espacial-e-desenho-amostral",
    "title": "1  Escala",
    "section": "1.2 Escala espacial e desenho amostral",
    "text": "1.2 Escala espacial e desenho amostral\nDado o papel que a escala pode desempenhar em nossa compreensão dos padrões e processos ecológicos, como escala deve ser considerada no desenho do estudo? Claramente, a resposta a esta pergunta irá variar dependendo dos fenômenos de interesse, mas ecologistas e estatísticos têm forneceu algumas orientações importantes. As questões-chave incluem o tamanho da unidade de amostragem (resoloção), o tipo de unidade de amostra e localizações da unidade de amostra, incluindo o espacamento entre as amostras (distância entre as amostras) e o tamanho da área de estudo.\nCom a disponibilidade de imagens de satélite é possível responder questões importantes relacionadas ao desenho do estudo antes de qualquer trabalho de campo. Uma tecnica de geoprocessamento (bordas - Buffers) é um dos mais frequentemente adotados para quantificar escala espacial na ecologia da paisagem.\nO objetivo é criar buffers circulares de diferentes extensões ao redor dos sitios de amostragem (pontos, pixels, manchas, transetos lineares etc). Aqui, vamos entender a escala em que a cobertura de floresta muda ao redor dos rios. Para isso, quantificamos a quantidade de floresta que ocorre em várias distâncias em pontos ao longo dos rios a montante das hidrelétricas no Rio Araguari. Para ilustrar esta abordagem geral, usamos o banco de dados MapBiomas Coleção 6 de 2020, e vincule esses dados de cobertura da terra aos pontos de amostragem em rios.\n\n1.2.1 Obter e carregar dados (vectores)\nPrecisamos carregar os dados para rios e pontos de amostragem. Baixar arquivo (vector) com os dados (formato “GPKG”, tamanho 54.9 MB). Este arquivo contém diferentes camadas vetoriais usadas para avaliar impactos de barragens hidroelétricas em tracajas (Bárcenas-García et al. (2022)) e ariranhas (Raffo et al. (2022)).\nMais sobre dados vetoriais. O formato aberto GeoPackage é um contêiner que permite armazenar dados SIG (feições/camadas) em um único arquivo. Por exemplo, um arquivo GeoPackage pode conter vários dados (dados vetoriais e raster) em diferentes sistemas de coordenadas. Todos esses recursos permitem que você compartilhe dados facilmente e evite a duplicação de arquivos.\nBaixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.gpkg . Lembrando-se de salvar o arquivo (“rivers.gpkg”) em um local conhecido no seu computador.\nO formato “GPKG” e diferente de “tif” (raster), o processo de importação é, portanto, diferente. Primeira, avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “rivers.GPKG”:\n\nmeuSIG &lt;- file.choose()\n\nAgora vamos olhar o que tem no arquivo. Depois que voces rodar o codigo st_layers(meuSIG), o resultado mostra que o arquivo rivers.GPKG inclui camadas diferentes com pontos (“Point”), linhas (“Line String”) e polígonos (“Polygon”). Alem disso, a coluna “crs_name” mostrar que a sistema de coordenadas é geográfica (WGS84, (EPSG: 4326)[https://epsg.io/4326], e é diferente do arquivo raster:\n\nsf::st_layers(meuSIG)\n\nDriver: GPKG \nAvailable layers:\n                   layer_name geometry_type features fields crs_name\n1                  centerline   Line String       52     15   WGS 84\n2                  forestloss         Point   276086     12   WGS 84\n3                   canalpoly       Polygon        3      6   WGS 84\n4              extentpoly50km       Polygon        1      0   WGS 84\n5                   midpoints         Point       52     17   WGS 84\n6            midpoints_hansen         Point       52     37   WGS 84\n7         cachoeira_caldeirao         Point        1      2   WGS 84\n8                porto_grande         Point        1      1   WGS 84\n9                 icmbio_base         Point        1      1   WGS 84\n10              direct_affect       Polygon        1      2   WGS 84\n11 midpoints_hansen_distances         Point       52     43   WGS 84\n12       midpoints_hansen_ffr         Point       52     82   WGS 84\n13     midpoints_hansen_ffril         Point       52     91   WGS 84\n14         direct_affect_line   Line String        1      2   WGS 84\n\n\n\nNós só precisamos de duas dessas camadas. O código abaixo vai carregar as camadas que precisamos e criar os objetos “rsm” e “rsl”. Assim, agora temos dados com: pontos cada 5 km ao longo os rios (“rsm”) e a linha central de rios (“rsl”).\n\n# pontos cada 5 km\nrsm &lt;- sf::st_read(meuSIG, layer = \"midpoints\")\n\nReading layer `midpoints' from data source \n  `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg' \n  using driver `GPKG'\nSimple feature collection with 52 features and 17 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -52.01259 ymin: 0.7175827 xmax: -51.29688 ymax: 1.330365\nGeodetic CRS:  WGS 84\n\n# linha central de rios\nrsl &lt;- sf::st_read(meuSIG, layer = \"centerline\")\n\nReading layer `centerline' from data source \n  `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg' \n  using driver `GPKG'\nSimple feature collection with 52 features and 15 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: -52.01443 ymin: 0.7094595 xmax: -51.2924 ymax: 1.352094\nGeodetic CRS:  WGS 84\n\n\n\n\n\n1.2.2 Visualizar os arquivos (camadas vector)\nVisualizar para verificar. Mapa com linha central e pontos de rios em trechos de 5km.\n\nggplot(rsl) +\n  geom_sf(aes(color=rio)) +\n  geom_sf(data = rsm, shape=21, aes(fill=zone))\n\n\n\n\nPontos ao longo dos rios a montante das hidrelétricas no Rio Araguari.\n\n\n\n\n Mapa interativo (funcione somente com internet) Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc)\n\n#\nmapview(rsl, zcol = \"rio\") \n\n\n\n\nLinhas dos rios a montante das hidrelétricas no Rio Araguari.\n\n\n\n\n\n\n1.2.3 Obter e carregar dados (raster)\nMais uma vez vamos aproveitar os dados de MapBiomas. Agora baixar arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 3.3 MB). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif . Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “utm_cover_AP_rio_2020.tif”:\n\nmeuSIGr &lt;- file.choose()\n\nO código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”.\n\nmapbiomas_2020 &lt;- rast(meuSIGr)\n\n\n\n1.2.4 Visualizar os arquivos (camadas raster e vector)\nVisualizar para verificar. É possível de visualizar camadas de raster e vetor juntos com funcões no pacote Tmap (https://r-tmap.github.io/tmap-book/index.html).\n\n# Passo necessario para agilizar o processamento\nmapbiomas_2020_modal&lt;-aggregate(mapbiomas_2020, fact=10, fun=\"modal\")\n# Plot\ntm_shape(mapbiomas_2020_modal) +\n  tm_raster(title = \"Classe\", style = \"cat\", palette = \"Set3\") + \ntm_shape(rsl) + \n  tm_lines(col=\"blue\") + \ntm_shape(rsm) + \n  tm_dots(size = 0.2, col = \"yellow\") + \ntm_compass(position=c(\"left\", \"top\")) +\ntm_scale_bar(breaks = c(0, 25, 50), text.size = 1, \n             position=c(\"left\", \"bottom\")) +\ntm_layout(legend.position = c(\"right\",\"top\"), legend.bg.color=\"white\")\n\n\n\n\nCobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio.\n\n\n\n\n\n\n\n\n1.2.5 Reclassificação\n\nPara simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente).\n\n# criar uma nova camada de floresta\nfloresta_2020 &lt;- mapbiomas_2020\n# Com valor de 0\nvalues(floresta_2020) &lt;- 0\n# Atualizar categorias florestais agrupados com valor de 1\nfloresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 \n\n\nVizualizar para verificar.\n\n# Passo necessario para agilizar o processamento\nfloresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=\"modal\")\n# Plot\ntm_shape(floresta_2020_modal) +\n  tm_raster(style = \"cat\", \n            palette = c(\"0\" = \"#E974ED\", \"1\" =\"#129912\"), legend.show = FALSE) + \n  tm_add_legend(type = \"fill\", labels = c(\"não-floresta\", \"floresta\"),\n    col = c(\"#E974ED\", \"#129912\"), title = \"Classe\") +\ntm_shape(rsl) + \n  tm_lines(col=\"blue\") + \ntm_shape(rsm) + \n  tm_dots(size = 0.2, col = \"yellow\") + \ntm_scale_bar(breaks = c(0, 25, 50), text.size = 1, \n             text.color = \"white\", position=c(\"left\", \"bottom\")) +\ntm_layout(legend.position = c(\"right\",\"top\"),legend.bg.color = \"white\")\n\n\n\n\nFloresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio."
  },
  {
    "objectID": "escala.html#comparação-multiescala",
    "href": "escala.html#comparação-multiescala",
    "title": "1  Escala",
    "section": "1.3 Comparação multiescala",
    "text": "1.3 Comparação multiescala\nEm seguida, com as coordenadas dos pontos das localizações das amostras calculamos a quantidade de floresta que circunda cada local de amostragem em diferentes extensões.\n\nrsm_31976 &lt;- st_transform(rsm, 31976) \n# Buffer\nrsm_31976_b1000 &lt;- st_buffer(rsm_31976[1, ], dist = 1000)\n\n# Recorte com buffer de 1000 metros (mudando a extensão).\nbuffer.forest1.1km &lt;- crop(floresta_2020, snap=\"out\", rsm_31976_b1000)\n# Máscara para que os pixels fora do polígono sejam nulos.\nbuffer.forest1.1km &lt;- mask(buffer.forest1.1km, rsm_31976_b1000, touches=TRUE)\nnames(buffer.forest1.1km) &lt;- \"forest_2020_1km\"\n\n\nVizualizar para verificar.\n\n# Plot\ntm_shape(buffer.forest1.1km) +\n  tm_raster(style = \"cat\", \n            palette = c(\"0\" = \"#E974ED\", \n                        \"1\" =\"#129912\"), legend.show = FALSE) + \ntm_shape(rsm_31976[1, ]) + \n  tm_symbols(shape =21, col = \"yellow\", \n            border.col = \"black\", border.lwd = 0.2, size=0.5) + \ntm_shape(rsm_31976_b1000) +\n  tm_borders(col = \"black\", lwd = 4, lty = \"dashed\") + \ntm_add_legend(type = \"fill\",  labels = c(\"não-floresta\", \"floresta\"),\n    col = c(\"#E974ED\", \"#129912\"), title = \"Classe\") + \ntm_compass(position=c(\"left\", \"top\")) +\ntm_scale_bar(breaks = c(0, 0.5, 1), text.size = 1, \n             position=c(\"left\", \"bottom\")) +\ntm_layout(legend.position = c(\"right\",\"top\"), legend.bg.color = \"white\")\n\n\n\n\nIlustração da determinação da quantidade de habitat ao redor de um ponto. Para um determinada extensão, o habitat de interesse é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e o número de células (pixels) que contém o habitat é somado e multiplicado pela área de cada pixel.\n\n\n\n\n\n1.3.1 Pergunta 3\nQual é a extensão em número de pixels desse recorte (buffer.forest1.1km)?\n\n\nTemos valores de 0 (não-floresta) e 1 (floresta). Então, para saber a aréa de floresta podemos somar o número de células (pixels) que contém o habitat e multiplica pela área de cada pixel conforme o codigo:\n\n# 1) Somatório. \n# No caso igual o numero de pixels de floresta. \n# Para todo a paisagem, somatorio \"global\".\n# Não deve incluir pixels nulos, então use \"na.rm = TRUE\".\nsoma_floresta &lt;- global(buffer.forest1.1km, \"sum\", na.rm = TRUE) \nsoma_floresta\n\n                sum\nforest_2020_1km 943\n\n# 2) Área de cada pixel.\n# Sabemos o sistema de coordenadas (EPSG = 31976).\n# EPSG 31976 é uma sistema projetado com unidade em metros.\nbuffer.forest1.1km\n\nclass       : SpatRaster \ndimensions  : 68, 68, 1  (nrow, ncol, nlyr)\nresolution  : 29.89281, 29.89281  (x, y)\nextent      : 465959.3, 467992, 90921.47, 92954.18  (xmin, xmax, ymin, ymax)\ncoord. ref. : SIRGAS 2000 / UTM zone 22N (EPSG:31976) \nsource(s)   : memory\nname        : forest_2020_1km \nmin value   :               0 \nmax value   :               1 \n\n# Portanto, o tamanho de cada pixel é igual.\narea_pixel_m2 &lt;- 29.89281 * 29.89281\narea_pixel_m2\n\n[1] 893.5801\n\n# 3) Calculos de aréa.\n# Aréa de floresta m2\narea_floresta_m2 &lt;- soma_floresta * area_pixel_m2\narea_floresta_m2\n\n                   sum\nforest_2020_1km 842646\n\n# Aréa de floresta hectares\narea_floresta_ha &lt;- area_floresta_m2 / 10000\narea_floresta_ha\n\n                    sum\nforest_2020_1km 84.2646\n\n\n\nPara uma comparação multiescala, vamos repetir o mesmo processo, mas agora com distancias de 250, 500, 1000, 2000 e 4000 metros, doubrando a escala (extensão) em cada passo.\n\n\n\n\n\nCobertura florestal em extensões diferentes ao redor de um local de amostragem.\n\n\n\n\n Aspectos quantitativos das paisagens mudam fundamentalmente com a escala. Por exemplo, nesse caso, parece que a proporção de floresta aumenta à medida que a extensão aumenta de 500 para 4000 metros. Esta percepção visual é confirmada pelos valores calculados, onde as áreas são:\n\nraio 250 m = 0 hectares de floresta\nraio 500 m = 6,3 hectares de floresta\nraio 1000 m = 84,3 hectares de floresta\nraio 2000 m = 502.6 hectares de floresta\nraio 4000 m = 3351.0 hectares de floresta\n\n\n\n1.3.2 Pergunta 4\nUsando os valores listadas acima de raio e área de floresta para os diferentes buffers circulares, calcule a proporção de floresta em cada uma das diferentes extensões de buffer. Apresente 1) os resultados incluindo cálculos. 2) um gráfico com valores de extensão no eixo x e proporção da floresta no eixo y. 3) Em menos de 200 palavras apresente a sua interpretação do gráfico.\n\n\n\n1.3.3 Pergunta 5\nA modelagem multiescala quantifica as condições do ambiente em múltiplas escalas alterando o resolução ou a extensão da análise e, em seguida, avaliando qual das escalas consideradas explica melhor um padrão ou processo. Escolha 1 espécie aquático e 1 espécie terrestre que ocorram na região a montante das hidrelétricas no Rio Araguari. Com base nas diferenças entre extensões (indicados no exemplo anterior) e as características funcionais das espécies (por exemplo área de vida), escolher as extensões mais adequadas para um estudo multiescala de cada espécie."
  },
  {
    "objectID": "escala.html#próximos-passos-repetindo-para-muitas-amostras.",
    "href": "escala.html#próximos-passos-repetindo-para-muitas-amostras.",
    "title": "1  Escala",
    "section": "1.4 Próximos passos: repetindo para muitas amostras.",
    "text": "1.4 Próximos passos: repetindo para muitas amostras.\nNeste exemplo comparamos a área de floresta em torno de um único ponto de amostragem. Para calcular o mesmo para todos os 52 pontos, seriam necessárias varias repetições (52 pontos x 5 extensões = 260 repetições).\nPoderíamos escrever código para executar esse processo automaticamente. Felizmente, alguém já escreveu funções para fazer isso e muito mais. O próximo tutorial sobre métricas de paisagem mostrará exemplos usando o pacote “landscapemetrics” (https://r-spatialecology.github.io/landscapemetrics/).\n\n\n\n\n\nBárcenas-García, Andrea, Fernanda Michalski, James P. Gibbs, e Darren Norris. 2022. “Amazonian Run-of-River Dam Reservoir Impacts Underestimated: Evidence from a Beforeafter Controlimpact Study of Freshwater Turtle Nesting Areas”. Aquatic Conservation: Marine and Freshwater Ecosystems 32 (3): 508–22. https://doi.org/10.1002/aqc.3775.\n\n\nFletcher, Robert, e Marie-Josée Fortin. 2018. Spatial Ecology and Conservation Modeling. Springer International Publishing. https://doi.org/10.1007/978-3-030-01989-1.\n\n\nRaffo, Deborah C. Dávila, Darren Norris, Sandra Maria Hartz, e Fernanda Michalski. 2022. “Anthropogenic Influences on the Distribution of a Threatened Apex-Predator Around Sustainable-Use Reserves Following Hydropower Dam Installation”. PeerJ 10 (outubro): e14287. https://doi.org/10.7717/peerj.14287."
  },
  {
    "objectID": "metricas.html#apresentação",
    "href": "metricas.html#apresentação",
    "title": "2  Métricas da paisagem",
    "section": "2.1 Apresentação",
    "text": "2.1 Apresentação\nAs métricas da paisagem nos ajudam a entender as mudanças na paisagem de diferentes perspectivas (visual, ecológica, cultural).\nAsssim sendo, análises com métricas de paisagem é um atividade fundamental na ecologia da paisagem. Nesta capitulo aprenderemos sobre como analisar a cobertura da terra com métricas de paisagem em R. As tecnicas será ilustrada através cálculos usando a cobertura florestal ao redor do Rio Araguari. Ao longo do caminho, revisaremos modelos lineares e não lineares, aprenderemos sobre manipulação de dados em R e aprenderemos como criar gráficos com o pacote ggplot2.\nNo capitulo você aprenderá a:\n\nImportar e plotar dados raster em R e mapear locais de amostragem com os pacotes terra, sf e tmap.\nCalcular métricas de paisagem com o pacote landscapemetrics.\nCalcular métricas de paisagem em locais de amostragem e dentro de um buffer ao redor deles (comparação multiescala).\nConstruir gráficos com o pacote ggplot2.\nComparação de padrões lineares e não-lineares."
  },
  {
    "objectID": "metricas.html#métricas-da-paisagem-e-pacote-landscapemetrics",
    "href": "metricas.html#métricas-da-paisagem-e-pacote-landscapemetrics",
    "title": "2  Métricas da paisagem",
    "section": "2.2 Métricas da paisagem e pacote “landscapemetrics”",
    "text": "2.2 Métricas da paisagem e pacote “landscapemetrics”\nAs métricas de paisagem são a forma que os ecólogos de paisagem usam para descrever os padrões espaciais de paisagens para depois avaliar a influência destes padrões espaciais nos padrões e processos ecológicos.\nlandscapemetrics tem funções para calcular métricas de paisagem em paisagems categóricos (onde tem uma classificação de cobertura de terra/habitat - modelo mancha-corredor-matriz), em um fluxo de trabalho organizado. O pacote pode ser usado como um substituto do FRAGSTATS (McGarigal et al. 1995, https://doi.org/10.2737/PNW-GTR-351), pois oferece um fluxo de trabalho reproduzível para análise de paisagem em um único ambiente (Professor McGarigal se aposentou, então FRAGSTATS não é mais apoiado). landscapemetrics também permite cálculos de quatro métricas teóricas de complexidade da paisagem: entropia marginal, entropia condicional, entropia conjunta e informação mútua (Nowosad e Stepinski 2019 https://doi.org/10.1007/s10980-019-00830-x).\n\n2.2.1 Pacotes\nAlém do “landscapemetrics”, precisamos carregar alguns pacotes a mais para facilitar a organização e apresentação de dados espaciais (vector e raster) e os resultados.\nCarregar pacotes (que deve esta instalado antes):\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(raster)\nlibrary(terra)\nlibrary(tmap)\nlibrary(gridExtra)\nlibrary(kableExtra)\nlibrary(mgcv)\n\nAgora, digite o código abaixo e veja o resultado. Leia com atenção e preste particular atenção na organização da página de ajuda.\n\nlibrary(landscapemetrics)\n?landscapemetrics\n\nNo final da página você vai encontrar a palavra “Index”. Clique nela e você verá todas as funções do pacote. Desca até as lsm_. . . e clique em algumas delas ali. Explorar! Para listar todas as métricas disponíveis, você pode usar a função list_lsm() . A função também permite mostrar métricas filtradas por nível, tipo ou nome da métrica. Para obter mais informações sobre as métricas, consulte os arquivos de ajuda correspondentes ou https://r-spatialecology.github.io/landscapemetrics.\nDigite o código abaixo e veja o resultados, mostrando exemplos das métricas diferentes.\n\n# métricas de agregação, nível de fragmento\nlandscapemetrics::list_lsm(level = \"patch\", type = \"aggregation metric\")\n# métricas de agregação, nível de classe\nlandscapemetrics::list_lsm(level = \"class\", type = \"aggregation metric\")\n# \nlandscapemetrics::list_lsm(metric = \"area\")\n# ajudar com opções da função\n?landscapemetrics::list_lsm\n\nNesse pacote o formato geral para uma função é o seguinte “lsm_nível_métrica”:\n\nA primeira parte é sempre lsm_ (“landscapemetric”), seguinda do “nível_” e por fim a “métrica”. Ou seja, todas as funções que calculam métricas começam com lsm_ …….\nDaí você deve incluir o nível da análise “p” para patch (ou seja, para a mancha/fragmento), “c” para classe e “l” para landscape ou seja, métricas para a paisagem como um todo.\nE daí existem inúmeras métricas, como por exemplo a cpland que é o percentual de área central - “core area” na paisagem, como vimos na aula teórica. Assim sendo, a função lsm_c_cpland vai calacular a métrica porcentagem da área central em cada classe. Lembrando existem metricas que podem se calculados nos trés niveis, e metricas que so pode se calculados somente para um nivel espcifco.\n\nDigite o código abaixo e veja o resultados, mostrando exemplos das métricas diferentes.\n\n# ajudar com opções para uma função especifica\n?landscapemetrics::lsm_c_cpland\n\n\n2.2.1.1 Pergunta 1\nDescreva brevemente 2 métricas de cada nível usando ajudar (usando ? e/ou list_lsm) e/ou a leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises). Incluindo na descrição - o nome, porque serve, unidades de medida, e relevância ecológica."
  },
  {
    "objectID": "metricas.html#dados",
    "href": "metricas.html#dados",
    "title": "2  Métricas da paisagem",
    "section": "2.3 Dados",
    "text": "2.3 Dados\nExistem varios formas de importar e exportar dados geoespaciais. Aqui, precisamos o arquivo com os dados de MapBiomas “utm_cover_AP_rio_2020.tif”, que voces baixaram no tutorial anterior (tutorial Escala https://rpubs.com/darren75/escala).\nLink: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif\nLembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora, nós podemos carregar os dados de cobertura da terra “utm_cover_AP_rio_2020.tif” com a função rast.\n\n# Selecionar e carregar arquivo \"utm_cover_AP_rio_2020.tif\"\nmapbiomas_2020 &lt;- rast(file.choose())\n# Reclassificação - \n# Criar uma nova camada de floresta (novo objeto de raster copiando mapbiomas_2020, \n# assim para ter os mesmos coordenados, resolução e extensão)\nfloresta_2020 &lt;- mapbiomas_2020\n# Todos os pixels com valor de 0\nvalues(floresta_2020) &lt;- 0\n# Atualizar com valor de 1 quando pixels originais são de floresta (classe 3 e 4)\nfloresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 \n\nPlotar para verificar, incluindo nomes e os cores para classes de floresta (valor = 1) e não-floresta (valor = 0).\n\n# Passo necessario para agilizar o processamento\nfloresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=\"modal\")\n# Plot\ntm_shape(floresta_2020_modal) +\n  tm_raster(style = \"cat\", \n            palette = c(\"0\" = \"#E974ED\", \"1\" =\"#129912\"), legend.show = FALSE) + \n  tm_add_legend(type = \"fill\", labels = c(\"não-floresta\", \"floresta\"),\n    col = c(\"#E974ED\", \"#129912\"), title = \"Classe\") + \ntm_layout(legend.bg.color = \"white\")\n\nSe esta todo certo, voces devem ter uma imagem assim:\n\n\n\n\n\nFloresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta.\n\n\n\n\n\n2.3.1 Exibir dados raster e sobreposição com locais de amostragem\nAgora temos a paisagem, precisamos tambem os pontos de amostra. Por isso, precisamos carregar os dados de rios e pontos de amostragem que usamos no tutorial Escala - arquivo “rivers.GPKG”. Vamos carregar as camadas que voces baixaram no tutorial anterior. Baixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.GPKG . Lembrando-se de salvar o arquivo (“rivers.GPKG”) em um local conhecido no seu computador.\nAgora, com o proximo bloco de codigo, podemos selecionar o arquivo “rivers.GPKG”, e carregar primeiramente a camada “midpoints” e depois “centerline”.\nNo exemplo, usamos %&gt;%, que estabelece a ligação entre os passos do processo. Ou seja, %&gt;% passa o objeto resultante automaticamente para a próxima função como primeiro argumento. Primeiramente carregamos os dados e em seguida converter (reprojeção) as coordenadas para o mesmo sistema de referência que o arquivo raster (com a função st_transform).\n\n#  Selecionar o arquivo \"rivers.GPKG\",\nmeuSIG &lt;- file.choose()\n# Carregar pontos cada 5 km, camada midpoints\nrsm_31976 &lt;- sf::st_read(meuSIG, layer = \"midpoints\") %&gt;% \n  st_transform(31976) \n# Carregar linha central de rios, camada centerline\nrsl_31976 &lt;- sf::st_read(meuSIG, layer = \"centerline\") %&gt;% \n  st_transform(31976) \n\n\nVisualizer para verificar.\n\n# Passo necessario para agilizar o processamento\nfloresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=\"modal\")\n# Plot\ntm_shape(floresta_2020_modal) +\n  tm_raster(style = \"cat\", \n            palette = c(\"0\" = \"#E974ED\", \"1\" =\"#129912\"), legend.show = FALSE) + \n  tm_add_legend(type = \"fill\", labels = c(\"não-floresta\", \"floresta\"),\n    col = c(\"#E974ED\", \"#129912\"), title = \"Classe\") + \ntm_shape(rsl_31976) + \n  tm_lines(col=\"blue\") + \ntm_shape(rsm_31976) + \n  tm_dots(size = 0.2, col = \"yellow\") + \ntm_layout(legend.bg.color=\"white\")\n\nDepois de executar (“run”) o código acima, você deverá ver a figura a seguir.\n\n\n\n\n\nCobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio (linha azul)."
  },
  {
    "objectID": "metricas.html#calculo-de-métricas",
    "href": "metricas.html#calculo-de-métricas",
    "title": "2  Métricas da paisagem",
    "section": "2.4 Calculo de métricas",
    "text": "2.4 Calculo de métricas\nPara ilustrar como rodar as funções e cálculos com landscapemetrics, vamos calcular a área central na paisagem. Vamos estudar uma classe (floresta), portanto vamos incluir as métricas para nível de classe. Além disso, as métricas de paisagem em nível de classe são mais eficazes na definição de processos ecológicos (Tischendorf, L. Can landscape indices predict ecological processes consistently?. Landscape Ecology 16, 235–254 (2001). https://doi.org/10.1023/A:1011112719782.).\nPara calcular as métricas de paisagem dentro de um certo buffer em torno de pontos de amostra, existe a função sample_lsm(). Através da função sample_lsm() podemos calcular mais de 50 métricas da paisagem, dentro de extensões (raios/distancias) diferentes.\n\n2.4.1 Ponto único, raio único, métrica única\nMétricas de área central (“core area”) são consideradas medidas da qualidade de hábitat, uma vez que indica quanto existe realmente de área efetiva de um fragmento, após descontar-se o efeito de borda. Vamos calcular a percentual de área central (“core area”) no entorno de um ponto de amostragem. Isso seria, a percentual de áreas centrais (excluídas as bordas de 30 m) de cada classe em relação à área total da paisagem.\nPara a função sample_lsm() funcionar, precisamos informar (i) a paisagem (arquivo de raster), (ii) ponto (arquivo vector), (iii) raio, (iv) forma do buffer (círculo ou quadrado) e por final (v) a métrica desejada. Cada opção tem especificações particulares assim para que a função pode receber dados em formatos diferentes e produzir resultados confiorme necessidades de diversos casos.\n\nminha_amostra_1000 &lt;- sample_lsm(landscape = floresta_2020, \n                                 y = rsm_31976[1, ], \n                            size = 1000, shape = \"circle\", \n                            metric = \"cpland\", \n                            edge_depth = 1) \n\nDepois que executar (“run”), podemos olhar os dados com o codigo a seguir. Os dados deve ter os valores (coluna value) da métrica (coluna metric) de cada classe (coluna class):\n\nminha_amostra_1000\n\n\n\n\n\n\nlayer\nlevel\nclass\nid\nmetric\nvalue\nplot_id\npercentage_inside\n\n\n\n\n1\nclass\n0\nNA\ncpland\n66.94191\n1\n99.9608\n\n\n1\nclass\n1\nNA\ncpland\n19.07745\n1\n99.9608\n\n\n\n\n\n\n\n\n2.4.1.1 Pergunta 2\nO modelo mancha-corredor-matriz é frequentemente adotado na ecologia da paisagem. Com base nas aulas teóricas e usando os valores no objeto minha_amostra_1000 apresentados na tabela acima, identificar qual classe representar a matriz na paisagem. Há alguma informação faltando que limita a sua capacidade de identificar qual classe representar a matriz? Se sim, o que precisa ser adicionado? Justifique as suas respostas de forma clara e concisa.\n\n\n\n\n\n2.4.2 Ponto único, distâncias variados, métrica única\n\n\n\n\n\nCobertura florestal em extensões diferentes ao redor de um ponto de amostragem.\n\n\n\n\nPara uma comparação multiescala, vamos calcular a mesma métrica, no mesmo ponto, mas agora com extensões diferentes. Continuando o exemplo no tutorial anteriio (Escala), vamos repetir o mesmo processo, mas agora com raios de 250, 500, 1000, 2000, 4000, 8000 e 16000 metros, doubrando a escala (extensão) em cada passo.\n\nPara obter resultados com extensões diferentes, precisamos primeiramente repetir o código, ajustando para cada extensão, e depois juntar os resultados. O código a seguir calculará a mesma métrica para as diferentes distâncias. No exemplo, usamos %&gt;%, que estabelece a ligação entre os passos do processo. Neste caso, para incluir uma coluna nova (raio) para manter o valor das diferentes distâncias.\n\n# raio 250 metros\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 250, shape = \"circle\", \n           metric = \"cpland\") %&gt;% \n  mutate(raio = 250) -&gt; minha_amostra_250 \n# raio 500 metros\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 500, shape = \"circle\", \n           metric = \"cpland\")  %&gt;% \n  mutate(raio = 500) -&gt; minha_amostra_500\n# raio 1 km (1000 metros)\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 1000, shape = \"circle\", \n           metric = \"cpland\")  %&gt;% \n  mutate(raio = 1000) -&gt; minha_amostra_1000\n# raio 2 km\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 2000, shape = \"circle\", \n           metric = \"cpland\") %&gt;% \n  mutate(raio = 2000) -&gt; minha_amostra_2000\n# raio 4 km\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 4000, shape = \"circle\", \n           metric = \"cpland\")  %&gt;% \n  mutate(raio = 4000) -&gt; minha_amostra_4000\n# raio 8 km\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 8000, shape = \"circle\", \n           metric = \"cpland\")  %&gt;% \n  mutate(raio = 8000) -&gt; minha_amostra_8000\n# raio 16 km\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 16000, shape = \"circle\", \n           metric = \"cpland\")  %&gt;% \n  mutate(raio = 16000) -&gt; minha_amostra_16000\n\n\nE agora, o código a seguir juntará os resultados das diferentes extensões.\n\nbind_rows(minha_amostra_250, \n          minha_amostra_500, \n          minha_amostra_1000, \n          minha_amostra_2000, \n          minha_amostra_4000, \n          minha_amostra_8000, \n          minha_amostra_16000) -&gt; amostras_metrica\n\nDepois que executar (“run”), podemos olhar os dados “amostras_metrica” com o codigo a seguir.\n\namostras_metrica\n\nOs dados deve ter os valores (coluna value) da métrica (coluna metric) de cada classe (coluna class) para cada distância (coluna raio):\n\n\n\n\n\nlayer\nlevel\nclass\nid\nmetric\nvalue\nplot_id\npercentage_inside\nraio\n\n\n\n\n1\nclass\n0\nNA\ncpland\n79.4\n1\n99\n250\n\n\n1\nclass\n0\nNA\ncpland\n86.9\n1\n100\n500\n\n\n1\nclass\n1\nNA\ncpland\n0.7\n1\n100\n500\n\n\n1\nclass\n0\nNA\ncpland\n66.9\n1\n100\n1000\n\n\n1\nclass\n1\nNA\ncpland\n19.1\n1\n100\n1000\n\n\n1\nclass\n0\nNA\ncpland\n57.6\n1\n100\n2000\n\n\n1\nclass\n1\nNA\ncpland\n26.9\n1\n100\n2000\n\n\n1\nclass\n0\nNA\ncpland\n36.2\n1\n100\n4000\n\n\n1\nclass\n1\nNA\ncpland\n42.2\n1\n100\n4000\n\n\n1\nclass\n0\nNA\ncpland\n35.8\n1\n100\n8000\n\n\n1\nclass\n1\nNA\ncpland\n45.4\n1\n100\n8000\n\n\n1\nclass\n0\nNA\ncpland\n37.1\n1\n100\n16000\n\n\n1\nclass\n1\nNA\ncpland\n46.3\n1\n100\n16000\n\n\n\n\n\n\n\n\n\n2.4.2.1 Faça um gráfico\n\n\n\n\n\n\n\n\n\nUma imagem vale mais que mil palavras. Portanto, gráficos/figuras/imagens são uma das mais importantes formas de comunicar a ciência. Os dados apresentados em uma tabela podem ser difíceis de entender. Portanto, a primeira pergunta que você deve se fazer é se você pode transformar aquela tabela (chata e feia) em algum tipo de gráfico. Lembrando, sempre pode incluir a tabela como anexo.\nAqui, vamos fazer um grafico com os dados amostras_metrica, usando o pacote ggplot2.\nO ggplot2 faz parte do conjunto de pacotes tidyverse, e é um pacote de visualização de dados. “gg” se refere a uma gramática de gráficos. A ideia principal é criar um gráfico como se fosse uma frase, onde cada elemento do gráfico seria uma palavra, organizados em uma sequencia logica para construir uma frase completo (gráfico final). Você fornece os dados, informa ao ggplot2 como mapear variáveis para estética, quais tipos/formatos gráficas usar e ele cuida dos detalhes.\nIsto nos permite construir gráficos tão complexos quanto quisermos. Os gráficos criados com ggplot2 são, em geral, mais elegantes do que os gráficos tradicionais do R. Para mais exemplos e tutoriais com mais detalhes veja os capitulos sobre ggplot2 nos livros:\n\nCiência de Dados com R\n\nAnálises Ecológicas no R\nNo livro em ingles R Graphics Cookbook .\nE sempre pode buscar exemplos no Google, por exemplo digitando: ggplot2 grafico de barra no Google, tem mais de 50 mil resultados com paginas de imagens, codigo pronto e exemplos no YouTube.\n\nO ggplot2 exige que os dados a serem plotados estejam em um “dataframe” (tabela de dados). Ou seja, sempre teremos que transformar os dados para dataframe ou construir um dataframe com os dados que possuímos. Dataframe é um formato comum e fácil de trabalhar. Por exemplo, se você importar uma planilha de dados, o resultado seria como dataframe (para mais detalhes veja Estrutura e manipulação de objetos e lendo dados ). Além disso, o resultado dos funções de landscapemetrics é sempre um dataframe, ou seja os resultados da função sample_lsm() são prontos para um grafico.\n\nO principal função a ser utilizado é ggplot(). Para ggplot, precisamos os dados (dataframe), e depois cria o “mapeamento” das variáveis, normalmente usando aes (de aesthetics). Ou seja, você especifica quais são as variáveis dos eixos x e y dentro de aes(). Através dele vamos definir qual é a variável preditora/explanatora (eixo x) e qual é a variável resposta (eixo y) em nosso conjunto de dados. Depois da função ggplot(), na sequencia no codigo nós especificamos qual tipo de grafico com um “geom”. Por exemplo, geom_point() para plotar pontos, geom_boxplot() para um boxplot, etc. Para a lista completa de geoms e todas as outras opções do pacote, visite a página do projeto ggplot2 https://ggplot2.tidyverse.org/index.html .\nAqui vamos fazer um gráfico com valores de extensão no eixo x e proporção da floresta central no eixo y. Assim sendo, com o codigo a segir, vamos informar (i) os dados, selecionando classe de floresta atraves de um filtro e acresentando uma coluna nova (“ext_m”) com a extensão em metros, (ii) as colunas para os eixos x e y, (iii) tipo de grafico (grafico de pontos - geom_point() e grafico de linha - geom_line()), (iv) nomes para os eixos. No exemplo, usamos %&gt;%, que estabelece a ligação entre os passos do processo, ligando os dados (amostras_metrica) e o grafico ggplot. Note que no codigo a seguir, adicionamos um geom com um “+”. No ggplot2, nós criamos gráficos em camadas, e adicionamos camada a camada com um “+”. Assim, é posivel ajustar qualquer elemento do grafico.\n\n# arrumar os dados\namostras_metrica %&gt;% \n  filter(class==1) %&gt;% mutate(ext_m = 2*raio) %&gt;%\n# fazer o grafico\n  ggplot(aes(x=ext_m, y=value)) + \n  geom_point() +  geom_line() +\n  labs(x = \"Extensão (metros)\", \n       y = \"Área central de floresta (porcentagem da paisagem)\")\n\nDepois de executar (“run”) o código acima, você deverá ver o grafico a seguir.\n\n\n\n\n\n\n\n\n\n\n\n2.4.2.2 Pergunta 3\nEm vez de extensão, você preciso incluir o tamanho (área do circulo) correspondente a cada raio. Incluir uma cópia do código ajustado para produzir uma figura com tamanho (área em quilômetros quadrados) no eixo x.\n\n\n\n\n\n2.4.3 Faça um gráfico elegante\nPodemos ajustar qualquer elemento do grafico com ggplot2. Agora, vamos mudar as unidades de metros para quilometros, aumentar o tamanho dos pontos, incluir uma linha reta para ilustrar a tendência geral, colocar o titulo longo do eixo y em duas linhas, e aumentar o tamanho da fonte para o texto ficar mais claro.\n\n# arrumar os dados\namostras_metrica %&gt;% \n  filter(class==1) %&gt;% \n  mutate(ext_m = 2*raio, \n         ext_km = (2*raio)/1000) %&gt;%\n# fazer o grafico\n  ggplot(aes(x=ext_km, y=value)) + \n  geom_point(size = 4) + \n  geom_line() +\n  stat_smooth(method = \"lm\", se = FALSE, color = \"green\", \n              linetype = \"dashed\") + \n  labs(x = \"Extensão (quilômetros)\", \n       y = \"Área central de floresta\\n(porcentagem da paisagem)\") + \n  theme(text = element_text(size = 18)) \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nComparação da área central de floresta em diferentes extensões.\n\n\n\n\n\n2.4.3.1 Pergunta 4\nEm menos de 200 palavras apresente a sua interpretação do gráfico em figura 5.2.\n\n\n\n\n\n2.4.4 Modelos linear e não linear\nUm dos desafios mais frequentes é como melhor representar os dados observados para gerar evidências científicas robustas e informações confiáveis. Nós vimos que as mudancas na métrica porcentagem de área central de floresta não segue uma linha reta em relação de escala (extensão). Para ir além de uma descrição simplista dos padrões observados, na ecologia da paisagem uma variedade de modelos estatísticos são usados.Não vamos rodar modelos (ainda), mas é importante entender algumas das opções disponíveis ao interpretar os gráficos.\nPor exemplo, modelos de regressão são amplamente usados em diversas aplicações para descrever a relação entre uma variável resposta Y e uma variável explicativa x. Os modelos lineares são uma generalização dos testes de hipótese clássicos mais simples (Modelos linear e Modelos lineares). Uma regressão linear, só pode ser aplicada para dados em que tanto a variável preditora quanto a resposta são contínuas, enquanto uma análise de variância é utilizada quando a variável preditora/explicativa é categórica. Os modelos lineares generalizados não têm essa limitação, podemos usar variáveis contínuas ou categóricas indistintamente (Modelos Lineares Generalizados).\nMas, no caso de padroes ecologicas, sera que um modelo linear é o melhor modelo para representar a relação que explica “y” em função de “x”? Um número crescente de pesquisadores compartilham o sentimento de que as relações entre variáveis biológicas/ecologicas são melhores descritas por funções não lineares. Processos ecologicas (como por exemplo crescimento, mortalidade, dispersão, e competição) raramente são relacionadas linearmente às variáveis explicativas.\nA principal vantagem do modelo não linear sobre o linear é que 1) sua escolha está associada à conhecimento prévio sobre a relação a ser modelada e 2) geralmente apresenta interpretação prática para os parâmetros. Em modelos não-linear dados observados de uma variável resposta são descritos por uma função de uma ou mais variáveis explicativas que é não linear seus parâmetros. Assim como nos modelos lineares o objetivo é identificar e estabelecer a relação entre variáveis explicativas e resposta. Entretanto, enquanto os modelos lineares definem, em geral, relações empíricas/teoricas, os modelos não-lineares são, em grande parte das vezes, motivados pelo conhecimento do tipo de relação entre as variáveis. Desta forma, as aplicações surgem nas diversas áreas onde relações físicas, biológicas, cinéticas, químicas, fisiológicas, dentre outras, são estabelecidas por funções não lineares que devem ter coeficientes (parâmetros) identificados (estimados) a partir de dados observados, dados experimentais e/ou dados simulados.\nComo as mudanças na estrutura da paisagem caracterizam-se por serem não-lineares, para desenvolver análises estatísticas robustos pode (i) aplicar uma transformação (por exemplo, “log”) ou (ii) adotar modelos não-lineares.\n\n\n\n\n\nComparação de padrões lineares e não-lineares.\n\n\n\n\n\n2.4.4.1 Pergunta 5\nComparar os resultados apresentados nas figuras com modelos lineares e não-lineares. Como podemos estabelecer qual seria o melhor modelo? Qual modelo seria mais adequado para identificar limiares no padrão de área central de floresta?"
  },
  {
    "objectID": "metricas.html#ponto-único-distâncias-variados-métricas-variadas",
    "href": "metricas.html#ponto-único-distâncias-variados-métricas-variadas",
    "title": "2  Métricas da paisagem",
    "section": "2.5 Ponto único, distâncias variados, métricas variadas",
    "text": "2.5 Ponto único, distâncias variados, métricas variadas\nNo exemplo anterior comparamos uma métrica da paisagem em torno de um único ponto de amostragem. Mas sabemos que uma combinação de várias métricas de paisagem diferentes é necessária para entender os padrões na paisagem. Aqui mostraremos como incluir cálculos de diferentes métricas de paisagem ao mesmo tempo.\n\n\n\n\n\nIlustração da determinação de métricas da paisagem diferentes ao redor de um ponto. Exemplo com a estrutura da paisagem representado com trés caracteristicas (A) Área central, (B) Borda e (C) Vizinho mais próximo. O habitat de interesse (classe) é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e as métricas calculadas. E em seguida o processo é repetido em diferentes extensões.\n\n\n\n\n\n\n\nNão deve calcular todas as métricas disponíveis, mas sim, escolher aquelas que podem ser realmente adequadas para sua pergunta de pesquisa.\n\nCalculando todas as métricas se chama um “tiro no escuro”, algo cujo resultado se desconhece ou é imprevisível. Isso não é recomendado. Para fazer uma escolha melhor (mais robusta), seguindo princípios básicos da ciência, precisamos ler os estudos anteriores (artigos) para obter as métricas mais relevantes para nosso objetivo, pergunta e/ou a hipótese a ser testada. Aqui, como exemplo illustrativa vamos calcular alguns das métricas mais comums. Mas, isso não representa necessariamente as métricas mais adequados ou recommendadas.\n\nMétricas de área e borda (area and edge metrics). Quantificam a composição da paisagem:\n\npland = percentage of landscape. Percentagem da paisagem. Porcentagem de cobertura da classe na paisagem.\ned = edge density . Densidade de borda que é igual à soma dos comprimentos (m) de todos os segmentos de borda que envolvem o fragmento, dividida pela área total da paisagem (m²), sendo posteriormente convertido em hectares.\ncpland = core area percentage of landscape. Percentual de área central (“core”) na paisagem. Percentual de áreas centrais (excluídas as bordas de 30 m) em relação à área total da paisagem. O termo “Core area” foi traduzido como área central ou área núcleo. Aqui vamos adotar área central.\n\nMétricas de agregação. Quantificam a configuração da paisagem:\n\nenn = euclidian nearest neighbour distance. Distância euclidiana do vizinho mais próximo.\nenn_cv = Coefficient of variation of euclidean nearest-neighbor distance. Coeficiente de variação da distância euclidiana do vizinho mais próximo. A métrica resume cada classe como o Coeficiente de variação das distâncias euclidianas do vizinho mais próximo entre as manchas pertencentes à classe. O valor de enn_cv = 0 se a distância euclidiana do vizinho mais próximo for idêntica para todas as manchas. Aumenta, sem limite, à medida que a variação do ENN aumenta.\nenn_sd = Standard deviation of euclidean nearest-neighbor distance. Desvio padrão da distância euclidiana do vizinho mais próximo.\npd = Patch density. Densidade das manchas.\ncohesion = Cohesion index. Índice de coesão das manchas.\n\n\nPara incluir cálculos de diferentes métricas de paisagem ao mesmo tempo, precisamos acrescentar somente uma nova linha de codigo. Uma nova linha, que cria um objeto com os nomes das funções para as métricas que queremos calcular….. Também precisamos usar a opção “what” na função para aceitar os nomes das funções.\n\n# Objeto com os nomes das funções para calcular as métricas desejadas.\nminhas_metricas &lt;- c(\"lsm_c_pland\", \"lsm_c_ed\", \"lsm_c_cpland\", \n                     \"lsm_c_enn_mn\", \"lsm_c_enn_sd\", \"lsm_c_enn_cv\", \n                     \"lsm_c_pd\",\"lsm_c_cohesion\")\n\n# 8 Métricas calculadas para cada extensão\n# raio 250 metros\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 250, shape = \"circle\", \n           what = minhas_metricas) %&gt;% \n  mutate(raio = 250) -&gt; metricas_amostra_250 \n# raio 500 metros\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 500, shape = \"circle\", \n           what = minhas_metricas)  %&gt;% \n   mutate(raio = 500) -&gt; metricas_amostra_500\n# raio 1 km (1000 metros)\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 1000, shape = \"circle\", \n           what = minhas_metricas)  %&gt;% \n   mutate(raio = 1000) -&gt; metricas_amostra_1000\n# raio 2 km (2000 metros)\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 2000, shape = \"circle\", \n           what = minhas_metricas) %&gt;% \n  mutate(raio = 2000) -&gt; metricas_amostra_2000\n# raio 4 km (4000 metros)\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 4000, shape = \"circle\", \n           what = minhas_metricas)  %&gt;% \n  mutate(raio = 4000)  -&gt; metricas_amostra_4000\n# raio 8 km (8000 metros)\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 8000, shape = \"circle\", \n           what = minhas_metricas)  %&gt;% \n  mutate(raio = 8000) -&gt; metricas_amostra_8000\n# raio 16 km (16000 metros)\nsample_lsm(floresta_2020, y = rsm_31976[1, ], \n           size = 16000, shape = \"circle\", \n           what = minhas_metricas)  %&gt;% \n  mutate(raio = 16000) -&gt; metricas_amostra_16000\n\nE agora, o código a seguir juntará os resultados das diferentes extensões.\n\nbind_rows(metricas_amostra_250, \n          metricas_amostra_500, \n          metricas_amostra_1000, \n          metricas_amostra_2000, \n          metricas_amostra_4000, \n          metricas_amostra_8000, \n          metricas_amostra_16000) -&gt; amostras_metricas\n\nDepois que executar (“run”), podemos olhar os dados com o codigo a seguir.\n\namostras_metricas\n\nOs dados deve ter os valores (coluna value) das métricas (coluna metric) de cada classe (coluna class) para cada distância (coluna raio):\n\n\n\n\n\nlayer\nlevel\nclass\nid\nmetric\nvalue\nplot_id\npercentage_inside\nraio\n\n\n\n\n1\nclass\n0\nNA\ncohesion\n100.00\n1\n99.3\n250\n\n\n1\nclass\n0\nNA\ncpland\n79.36\n1\n99.3\n250\n\n\n1\nclass\n0\nNA\ned\n0.00\n1\n99.3\n250\n\n\n1\nclass\nNA\nNA\nenn_cv\nNA\n1\n99.3\n250\n\n\n1\nclass\nNA\nNA\nenn_mn\nNA\n1\n99.3\n250\n\n\n1\nclass\nNA\nNA\nenn_sd\nNA\n1\n99.3\n250\n\n\n1\nclass\n0\nNA\npd\n5.13\n1\n99.3\n250\n\n\n1\nclass\n0\nNA\npland\n100.00\n1\n99.3\n250\n\n\n1\nclass\n0\nNA\ncohesion\n99.96\n1\n100.1\n500\n\n\n1\nclass\n1\nNA\ncohesion\n73.61\n1\n100.1\n500\n\n\n\n\n\n\n\nAgorta, vamos fazer um grafico com os dados amostras_metricas, usando o pacote ggplot2. Para ajudar na visualização incluímos quais métricas são para composição e configuração e nomes que são mais fáceis de entender.\n\nmetricas_composicao &lt;- c(\"pland\", \"ed\", \"cpland\")\n# arrumar dados\namostras_metricas %&gt;% \n  filter(class==1) %&gt;%\n  mutate(ext_km = (2*raio)/1000, \n         met_cat = if_else(metric %in% metricas_composicao, \n                           \"composição\", \"configuração\")) %&gt;%\n# fazer grafico\n  ggplot(aes(x=ext_km, y=value)) + \n  geom_point() + \n  geom_line() +\n  facet_wrap(met_cat~metric, scales = \"free_y\") +\n  labs(title = \"Comparação multiescala de várias métricas\",\n    x = \"extensão (quilômetros)\", \n    y = \"metric value\")\n\n\n\n\n\n2.5.0.1 Pergunta 6\nCom base nos resultados apresentados (figura e tabela) caracterisar as mudançãs na paisagem em função de extensões diferentes. Olhando os graficos prever como seria o padrão para extensões maiores (lembrando que valores são doubrados - por exemplo raio de 250 metros gerar uma extensão de 500 metros). Seria relevante repetir incluindo calculos para extensões maiores (por exemplo 64 km e 128 km)? Justifique sua caracterização e previsões de forma clara e concisa, apoie sua escolha com exemplos da literatura científica.\n\n\n2.5.0.2 Pergunta 7\nUsando como base o conteudo das aulas, leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises), e/ou exemplos apresentados aqui no tutorial, selecione pelo menos seis métricas de nível classe para caracterizar a paisagem de estudo e objectivos da sua projeto. Justifique sua seleção de forma clara e concisa, apoie sua escolha com exemplos da literatura científica."
  },
  {
    "objectID": "codigo-R.html",
    "href": "codigo-R.html",
    "title": "Codigo e R",
    "section": "",
    "text": "Objetivo não é de apresentar grandes detalhes sobre os cálculos/métodos estatísticas ou os funções no R."
  },
  {
    "objectID": "codigo-livro.html#organização-do-codigo-no-livro",
    "href": "codigo-livro.html#organização-do-codigo-no-livro",
    "title": "3  Codigo no livro",
    "section": "3.1 Organização do codigo no livro",
    "text": "3.1 Organização do codigo no livro\nO capitulo está organizado em etapas de processamento, com blocos de código em caixas cinzas:\n\ncodigo de R para executar\n\nPara segue os passos, os blocos de código precisam ser executados em sequência. Se você pular uma etapa, ou rodar fora de sequência o próximo bloco de código provavelmente não funcionará.\nAs linhas de codigo de R dentro de cada caixa tambem preciso ser executados em sequência. O simbolo # é usado para incluir comentarios sobre os passos no codgio (ou seja, linhas começando com # não é codigo de executar).\n\n# Passo 1\ncodigo de R passo 1 # texto e numeros tem cores diferentes\n# Passo 2\ncodigo de R passo 2\n# Passo 3\ncodigo de R passo 3\n\nAlem disso, os simbolos #&gt; e/ou [1] no início de uma linha indica o resultado que você verá no console de R.\n\n# Passo 1\n1+1\n[1] 2\n\n# Passo 2\nx &lt;- 1 + 1\n# Passo 3\nx\n[1] 2\n\n# Passo 4\nx + 1\n[1] 3"
  },
  {
    "objectID": "codigo-raster.html",
    "href": "codigo-raster.html",
    "title": "4  Primeiros passos com uma raster",
    "section": "",
    "text": "Uma raster é um matriz de valores com coordenadas geográficos. Cada pixel de uma raster representa uma região geográfica, e o valor do pixel representa uma característica dessa região (mais sobre dados raster).\nEm geral é necessário baixar alguns pacotes para que possamos fazer as nossas análises. Precisamos os seguintes pacotes, que deve esta instalado antes:\n\ntidyverse,\nterra,\nsf,\nmapview,\ntmap.\n\nCarregar pacotes:\n\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(mapview)\nlibrary(tmap)\n\nInicialmente iremos gerar uma raster representando uma paisagem bem simples, de 6 por 6 pixels. Você já deve saber que pixel é a unidade básica de uma imagem (lembra da camera do seu celular, 10Mb ou algo assim?!). Vocês devem ter visto sobre pixels e resolução no mesmo em aulas de geoprocessamento. Aqui podemos tratar o pixel como a resolução. Vamos dizer que temos um pixel de 10 metros (res=10 no bloco de código), ou seja, uma quadrado de 10 por 10m, sendo essa, a menor unidade mapeável. Assim sendo, a resolução tambem tem ligação com escala cartográfica!\nVamos gerar e plotar uma paisagem simples em 4 passos. Primeiramente, a função rast cria um objeto do tipo raster. E depois a função values atribui valores, e na sequencia vamos visualisar os valores com plot e text .\n\n#Função \"rast\" gera a paisagem virtual (paisagem simulado)\npai_sim &lt;- rast(ncols=6, nrows=6, \n                xmin=1, xmax=60, \n                ymin=1, ymax=60, \n                res=10) \n#E essa atribui valores (\"values\") para os pixels criados acima\nvalues(pai_sim) &lt;- 1 \nplot(pai_sim) #Essa plota\ntext(pai_sim) #Essa coloca os valores dos pixels\n\n\n\n\nPaisagem simples de 36 pixels.\n\n\n\n\n\n\n4.0.1 Obter e carregar dados (raster)\nMais uma vez vamos aproveitar os dados de MapBiomas. Agora baixar arquivo raster com cobertura de terra no entorno dos rios em 2020, (formato “.tif”, tamanho 3.3 MB). Link: https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif . Lembrando-se de salvar o arquivo (“utm_cover_AP_rio_2020.tif”) em um local conhecido no seu computador. Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “utm_cover_AP_rio_2020.tif”:\n\nmeuSIGr &lt;- file.choose()\n\nO código abaixo vai carregar os dados e criar o objeto “mapbiomas_2020”.\n\nmapbiomas_2020 &lt;- rast(meuSIGr)\n\n\n\n\n\n4.0.2 Reclassificação\n\nPara simplificar nossa avaliação de escala, reclassificamos a camada mapbiomas_2020 em uma camada binária de floresta/não-floresta. Essa tarefa de geoprocessamento pode ser realizada anteriormente usando SIG (QGIS). Aqui vamos reclassificar as categorias de cobertura da terra (agrupando diferentes áreas de cobertura florestal tipos) usando alguns comandos genéricos do R para criar uma nova camada com a cobertura de floresta em toda a região de estudo. Para isso, criamos um mapa do mesmo resolução e extensão, e então podemos redefinir os valores do mapa. Neste caso, queremos agrupar a cobertura da terra categorias 3 e 4 (Formação Florestal e Formação Savânica, respectivamente).\n\n# criar uma nova camada de floresta\nfloresta_2020 &lt;- mapbiomas_2020\n# Com valor de 0\nvalues(floresta_2020) &lt;- 0\n# Atualizar categorias florestais agrupados com valor de 1\nfloresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] &lt;- 1 \n\n\nVizualizar para verificar.\n\n# Passo necessario para agilizar o processamento\nfloresta_2020_modal&lt;-aggregate(floresta_2020, fact=10, fun=\"modal\")\n# Plot\ntm_shape(floresta_2020_modal) +\n  tm_raster(style = \"cat\", \n            palette = c(\"0\" = \"#E974ED\", \"1\" =\"#129912\"), \n            legend.show = FALSE) + \n  tm_add_legend(type = \"fill\", labels = c(\"não-floresta\", \"floresta\"),\n    col = c(\"#E974ED\", \"#129912\"), title = \"Classe\") +\ntm_scale_bar(breaks = c(0, 25, 50), text.size = 1, \n             text.color = \"white\", position=c(\"left\", \"bottom\")) +\ntm_layout(legend.position = c(\"right\",\"top\"),legend.bg.color = \"white\")\n\n\n\n\nFloresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio."
  },
  {
    "objectID": "codigo-vector.html#obter-e-carregar-dados-vectores",
    "href": "codigo-vector.html#obter-e-carregar-dados-vectores",
    "title": "5  Primeiros passos com vector",
    "section": "5.1 Obter e carregar dados (vectores)",
    "text": "5.1 Obter e carregar dados (vectores)\nPrecisamos carregar os dados para rios e pontos de amostragem. Baixar arquivo (vector) com os dados (formato “GPKG”, tamanho 54.9 MB). Mais sobre dados vetoriais. O formato aberto GeoPackage é um contêiner que permite armazenar dados SIG (feições/camadas) em um único arquivo. Por exemplo, um arquivo GeoPackage pode conter vários dados (dados vetoriais e raster) em diferentes sistemas de coordenadas. Todos esses recursos permitem que você compartilhe dados facilmente e evite a duplicação de arquivos.\nBaixar o arquivo Link: https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.gpkg . Lembrando-se de salvar o arquivo (“rivers.gpkg”) em um local conhecido no seu computador.\nO formato “GPKG” e diferente de “tif” (raster), o processo de importação é, portanto, diferente. Primeira, avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo “rivers.GPKG”:\n\nmeuSIG &lt;- file.choose()\n\nAgora vamos olhar o que tem no arquivo. Depois que voces rodar o codigo st_layers(meuSIG), o resultado mostra que o arquivo rivers.GPKG inclui camadas diferentes com pontos (“Point”), linhas (“Line String”) e polígonos (“Polygon”). Alem disso, a coluna “crs_name” mostrar que a sistema de coordenadas é geográfica (WGS84, (EPSG: 4326)[https://epsg.io/4326], e é diferente do arquivo raster:\n\nsf::st_layers(meuSIG)\n\nDriver: GPKG \nAvailable layers:\n                   layer_name geometry_type features fields crs_name\n1                  centerline   Line String       52     15   WGS 84\n2                  forestloss         Point   276086     12   WGS 84\n3                   canalpoly       Polygon        3      6   WGS 84\n4              extentpoly50km       Polygon        1      0   WGS 84\n5                   midpoints         Point       52     17   WGS 84\n6            midpoints_hansen         Point       52     37   WGS 84\n7         cachoeira_caldeirao         Point        1      2   WGS 84\n8                porto_grande         Point        1      1   WGS 84\n9                 icmbio_base         Point        1      1   WGS 84\n10              direct_affect       Polygon        1      2   WGS 84\n11 midpoints_hansen_distances         Point       52     43   WGS 84\n12       midpoints_hansen_ffr         Point       52     82   WGS 84\n13     midpoints_hansen_ffril         Point       52     91   WGS 84\n14         direct_affect_line   Line String        1      2   WGS 84\n\n\n\nNós só precisamos de duas dessas camadas. O código abaixo vai carregar as camadas que precisamos e criar os objetos “rsm” e “rsl”. Assim, agora temos dados com: pontos cada 5 km ao longo os rios (“rsm”) e a linha central de rios (“rsl”).\n\n# pontos cada 5 km\nrsm &lt;- sf::st_read(meuSIG, layer = \"midpoints\")\n\nReading layer `midpoints' from data source \n  `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg' \n  using driver `GPKG'\nSimple feature collection with 52 features and 17 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -52.01259 ymin: 0.7175827 xmax: -51.29688 ymax: 1.330365\nGeodetic CRS:  WGS 84\n\n# linha central de rios\nrsl &lt;- sf::st_read(meuSIG, layer = \"centerline\")\n\nReading layer `centerline' from data source \n  `C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg' \n  using driver `GPKG'\nSimple feature collection with 52 features and 15 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: -52.01443 ymin: 0.7094595 xmax: -51.2924 ymax: 1.352094\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "codigo-vector.html#visualizar-os-arquivos-camadas-vector",
    "href": "codigo-vector.html#visualizar-os-arquivos-camadas-vector",
    "title": "5  Primeiros passos com vector",
    "section": "5.2 Visualizar os arquivos (camadas vector)",
    "text": "5.2 Visualizar os arquivos (camadas vector)\nVisualizar para verificar. Mapa com linha central e pontos de rios em trechos de 5km.\n\nggplot(rsl) +\n  geom_sf(aes(color=rio)) +\n  geom_sf(data = rsm, shape=21, aes(fill=zone))\n\n\n\n\nPontos ao longo dos rios a montante das hidrelétricas no Rio Araguari.\n\n\n\n\n Mapa interativo (funcione somente com internet) Mostrando agora com fundo de mapas “base” (OpenStreetMap/ESRI etc)\n\n#\nmapview(rsl, zcol = \"rio\") \n\n\n\n\nLinhas dos rios a montante das hidrelétricas no Rio Araguari."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliografia",
    "section": "",
    "text": "Bárcenas-García, Andrea, Fernanda Michalski, James P. Gibbs, and Darren\nNorris. 2022. “Amazonian Run-of-River\nDam Reservoir Impacts Underestimated: Evidence from a\nBeforeafter Controlimpact Study of Freshwater\nTurtle Nesting Areas.” Aquatic Conservation: Marine and\nFreshwater Ecosystems 32 (3): 508–22. https://doi.org/10.1002/aqc.3775.\n\n\nFletcher, Robert, and Marie-Josée Fortin. 2018. Spatial Ecology and\nConservation Modeling. Springer International Publishing. https://doi.org/10.1007/978-3-030-01989-1.\n\n\nRaffo, Deborah C. Dávila, Darren Norris, Sandra Maria Hartz, and\nFernanda Michalski. 2022. “Anthropogenic Influences on the\nDistribution of a Threatened Apex-Predator Around Sustainable-Use\nReserves Following Hydropower Dam Installation.” PeerJ\n10 (October): e14287. https://doi.org/10.7717/peerj.14287."
  }
]